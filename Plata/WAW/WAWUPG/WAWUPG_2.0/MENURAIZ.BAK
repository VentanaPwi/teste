* MENURAIZ.PRG - MENU (PROGRAMA PRINCIPAL DO SISTEMA)
*************
PARAMETERS tcPARAMEXE

_SCREEN.Caption = 'UPGRADER - Atualizador de versão de sistema'

* SOMENTE NO AMBIENTE DE DESENVOLVIMENTO
IF _VFP.StartMode <> 4 && MODO DE DESENVOLVIMENTO
*	SET PATH TO 'G:\TESTESVF\PLATA\WAW\WAWUPG' ADDITIVE
	SET PATH TO 'G:\TESTESVF\plata\WAW\WAWUPG' ADDITIVE
ENDIF

SET CLASSLIB TO 'ZIPCLASS'

SET TALK OFF
SET ESCAPE OFF
SET EXCL OFF
SET DELE ON
SET DATE BRITISH
SET CURSOR ON
SET NOTIFY OFF
SET SAFETY OFF
SET READBORDER ON
SET DECIMAL TO 8
SET REPROCESS TO 3 SECONDS
SET POINT TO ','
SET SEPA TO '.'
SET EXACT OFF
SET NEAR OFF
SET CONFIRM ON
SET CLOCK STATUS
SET CENTURY ON
SET MEMOWIDTH TO 512
SET HOURS TO 24
SET ENGINEBEHAVIOR 80
SET REPORTBEHAVIOR 90

IF TYPE('tcPARAMEXE')<>'C'
	tcPARAMEXE = ''
ENDIF
tcPARAMEXE = ALLTRIM(UPPER(tcPARAMEXE))+' '

_SCREEN.WINDOWSTATE	= 2		&& tela cheia
_SCREEN.VISIBLE		= .T.
_SCREEN.MAXBUTTON	= .F.

IF EMPTY(tcPARAMEXE)
	CLEAR ALL
	PRIVATE tcPARAMEXE AS STRING
	tcPARAMEXE = ''
ENDIF
CLEAR PROGRAM
CLOSE ALL

LOCAL lcARQUIVO, lcARQUIVO2, lcCONTEUDO AS String
LOCAL llERRO AS Logical

LOCAL lcPATH AS String
STORE '' TO lcPATH

* ARQUIVO CONFIGURADOR DE PASTAS
lcARQUIVO	= 'UPGRADER.PWI'
IF NOT FILE(lcARQUIVO)
	DO MENS WITH 'ARQUIVO CONFIGURADOR DE EXTENSÕES AUSENTE! ('+lcARQUIVO+')'
	RETURN
ENDIF
TRY 
	USE &lcARQUIVO IN 0 ALIAS UPGRADER
CATCH
FINALLY
ENDTRY

IF NOT USED('UPGRADER')
	DO MENS WITH 'PROBLEMAS AO ABRIR ARQUIVO CONFIGURADOR DE EXTENSÕES! ('+lcARQUIVO+')'
	RETURN
ENDIF

SET RESOURCE OFF

* ROTINA DE TRATAMENTO DE ERRO SOMENTE NO AMBIENTE DE PRODUÇÃO
IF _VFP.StartMode = 4 && MODO DE PRODUÇÃO
	ON ERROR DO ROTERRO WITH ERROR(),MESSAGE(),PROGRAM(),LINENO()
ENDIF

ON SHUTDOWN QUIT
SET STATUS BAR OFF

PUBLIC goAPLICATIVO,gOCONEXAO AS Object
PUBLIC goZIP AS ZIPCLASS OF ZIPCLASS.VCX
	
GOAPLICATIVO 	= CREATEOBJECT("APLICATIVO")
GOCONEXAO 		= CREATEOBJECT("CONECTADB")

LOCAL lcDIRETORIO, lcFILEWAW, lcFILEVPADRAO, lcPATHWAW, lcPATHVOLPE AS String
STORE '' TO lcDIRETORIO, lcFILEWAW, lcFILEVPADRAO, lcPATHWAW, lcPATHVOLPE

LOCAL lnARQWAW AS Integer
STORE 0 TO lnARQWAW

goAPLICATIVO.VOLPEPADRAO = 0

lcDIRETORIO = FULLPATH('')

IF 'GERAR' $ tcPARAMEXE
	DO FORM 'GERAR'
ELSE
	* VERIFICA SE TEM ARQUIVO NA PASTA CORRENTE PRA PRÉ-CARREGAR
	CREATE CURSOR TMPARQ(DS_ARQUIVO C(50))

	*lcDIRETORIO	= ADDBS(FULLPATH(''))

	lcPATHWAW = FULLPATH('')

	IF 'UPGRADE' $ lcPATHWAW
		lcPATHVOLPE = ADDBS(FULLPATH('..'))	
	ENDIF

	IF NOT EMPTY(lcPATHVOLPE)
		lnARQWAW	= ADIR(laARQSWAW,FORCEPATH('*.WAW',ALLTRIM(lcPATHVOLPE)))
	ENDIF
	
	IF EMPTY(lnARQWAW)
		lnARQWAW = ADIR(laARQSWAW,FORCEPATH('*.WAW',ALLTRIM(lcPATHWAW)))
	ELSE
		lcPATHWAW	= lcPATHVOLPE
	ENDIF

	FOR LNI = 1 TO lnARQWAW
		SELE TMPARQ
		SCATTER NAME loREG BLANK
			loREG.DS_ARQUIVO = laARQSWAW[lni,1]
			APPEND BLANK
		GATHER NAME loREG
	ENDFOR
	lnARQ = RECCOUNT('TMPARQ')

	LOCAL lcPATHARQ AS String
	STORE '' TO lcPATHARQ

	DO CASE
		CASE lnARQ > 1
			DO FORM ESCOLHERARQUIVOS TO lcPATHARQ
			
			IF EMPTY(lcPATHARQ)
				RETURN(.F.)
			ENDIF

		CASE lnARQ =1
			lcPATHARQ= ALLTRIM(TMPARQ.DS_ARQUIVO)
		OTHERWISE
			lcPATHARQ=''
	ENDCASE

	goCONEXAO.FILEWAW = lcPATHWAW + lcPATHARQ

	IF NOT FILE(goCONEXAO.FILEWAW)
		goAPLICATIVO.WAWATIVO 	= 0
		goCONEXAO.PATHWAW		= ''
		*RETURN .F.
	ELSE
		goCONEXAO.PATHWAW		= goCONEXAO.FILEWAW
		goAPLICATIVO.WAWATIVO	= 1
		GOZIP = NEWOBJECT('ZIPCLASS','ZIPCLASS.VCX')
	ENDIF

	IF goAPLICATIVO.WAWATIVO = 0
*		DO FORM lcDIRETORIO+'PRINCIPAL'
		DO FORM 'PRINCIPAL'
	ELSE
		DO FORM PRINCIPAL WITH tcPARAMEXE
	ENDIF
ENDIF

CLEAR ALL
RETURN

PROC STARTAFILE
***************
LPARAMETERS tcARQUIVO AS String
	IF TYPE('tcARQUIVO') <> 'C'
		tcARQUIVO = ''	
	ENDIF
	IF EMPTY(tcARQUIVO)
		RETURN
	ENDIF
	IF NOT FILE(tcARQUIVO)
		DO MENS WITH 'ARQUIVO NÃO ENCONTRADO: '+tcARQUIVO
		RETURN
	ENDIF

	DECLARE LONG ShellExecute IN "shell32.dll" ;
		LONG HWND, STRING lpszOp, ;
		STRING lpszFile, STRING lpszParams, ;
		STRING lpszDir, LONG nShowCmd

	=SHELLEXECUTE( 0, 'Open', FULLPATH(tcARQUIVO), 0, 0, 1)

RETURN

PROC ESPERANDO
**************
LPARAMETER tcMESS AS String
	WAIT WINDOW tcMESS NOWAIT NOCLEAR
RETURN

PROC MENS
*********
PARAMETERS tcMENSAGEM,tnERRO
* MENSAGEM AO USUARIO, SE TNERRO=1 A MENSAGEM É MAIS GRAVE.
	IF TYPE('tnERRO')<>'N'
		tnERRO = 0
	ENDIF
	tnERRO = IIF(tnERRO>0,48,64)
	=MESSAGEBOX(tcMENSAGEM,'AVISO',48)
RETURN

PROC SIMOUNAO
*************
PARAMETERS tcPERGUNTA, tcTITULO, tnDEFAULT
	LOCAL lnBOTAO AS Number
	IF tnDEFAULT=1
		tnBOTAO = 0
	ELSE
		tnBOTAO = 256
	ENDIF
	IF MESSAGEBOX( tcPERGUNTA, tcTITULO, 32+4+tnBOTAO )=6
		RETURN(.T.)
	ENDIF
RETURN(.F.)

FUNC TIRANONUM
**************		PEGA APENAS OS NUMEROS DE UMA STRING
LPARAMETERS lcCAMPO
LOCAL lcSONUM AS String
LOCAL lnI AS INTEGER
lcSONUM = ''
FOR lnI = 1 TO LEN(lcCAMPO)
	lcALGA = SUBS(lcCAMPO,lnI,1)
	IF lcALGA $ '0987654321'
		lcSONUM = lcSONUM + lcALGA
	ENDIF
ENDFOR
RETURN(lcSONUM)

FUNC TEMPFILE
*************
	LOCAL lcCPOOUT, lcTEMP AS String
	LOCAL lnI AS Number
	lcTEMP	 = GETENV("TEMP")+'\'
	FOR lnI = 1 TO 100
		lcCPOOUT = lcTEMP+SYS(3)+'.TMP'
		IF NOT FILE(lcCPOOUT)
			EXIT
		ENDIF
	ENDFOR
RETURN(lcCPOOUT)

FUNC STRZERO
************
LPARAMETERS tnVALOR,tnTAM
	LOCAL lcOUT AS STRING
	lcOUT = STR(tnVALOR,tnTAM)
	lcOUT = STRTRAN(lcOUT," ","0")
RETU(lcOUT)

FUNC FNOMDIA
************
LPARAMETERS tdDAY
	IF VARTYPE(tdDAY)='T'
		tdDAY = TTOD(tdDAY)
	ENDIF
	tdDAY1 = IIF(TYPE('tdDAY')='D',DOW(tdDAY),tdDAY)
	LOCAL tnDAY1 AS INTEGER
	tnDAY1 = IIF(TYPE('tdDAY')='D',DOW(tdDAY),tdDAY)
RETURN SUBS('DomingoSegundaTerça  Quarta Quinta Sexta  Sábado ',(tnDAY1-1)*7+1,7)

FUNC FNOMMES
************
LPARAMETERS tdMES
	IF TYPE('tdMES') = 'T'
		tdMES = TTOD(tdMES)
	ENDIF
	IF NOT TYPE('tdMES') $ 'DN'
		tdMES = DATE()
	ENDIF
	LOCAL lnMES AS Integer
	IF TYPE('tdMES') = 'D'
		lnMES = MONTH(tdMES)
	ELSE
		IF tdMES > 12 OR tdMES < 1
			tdMES = MONTH(DATE())
		ENDIF
		lnMES = tdMES
	ENDIF
	lcMES = SUBS('Janeiro  FevereiroMarço    Abril    Maio     Junho    Julho    Agosto   Setembro Outubro  Novembro Dezembro ',(lnMES-1)*9+1, 9)
RETURN(lcMES) 

PROC ROTERRO
************
PARAMETERS tnMYERRO, tcMYMESS, tcMYPROG, tnMYLINH
	DO CASE
	CASE tnMYERRO = 1705
		DO MENS WITH 'ACESSO NÃO PERMITIDO NO MOMENTO! '+CHR(13)+CHR(13)+;
		'Um Arquivo está bloqueado pela rede, por um processo ou por outro usuário.'
	OTHERWISE
		=MESSAGEBOX('Ocorreu uma falha no seu aplicativo e ele terá que ser encerrado! Anote a mensagem de erro e entre em contato com o suporte técnico do seu software. ERRO: '+CHR(13)+;
		ALLTRIM(STR(tnMYERRO)) + '=' + tcMYMESS + CHR(13) +;
		' LINHA ' + ALLTRIM(STR(tnMYLINH)) + ':' + tcMYPROG, 'ERRO',48)
		IF TYPE('_SCREEN.ACTIVEFORM')='O'
			_SCREEN.ActiveForm.release()
		ELSE
			CANCEL
		ENDIF
	ENDCASE
RETURN

* APARTIR DAQUI ALTERAÇÃO PARA WAW
FUNC SBDVEM
***********
*DECRIPTA SENHA DE CONEXÃO
PARAMETERS tcHIDEN
	tcHIDEN = ALLTRIM(tcHIDEN)
	LOCAL lcSENHA, lcSEMENTE, lcLETRA AS String
	lcSENHA = ''
	lcSEMENTE = SUBSTR(tcHIDEN,2,1)
	LOCAL X, Y AS INTEGER

	FOR X = LEN(tcHIDEN) TO 3 STEP -3
		Y = VAL( SUBSTR(tcHIDEN,X-2,3) ) -ASC(lcSEMENTE)
		lcLETRA = ''
		IF Y>27 AND Y<256
			lcLETRA = CHR(Y)
		ENDIF
		lcSENHA = lcSENHA + lcLETRA
	ENDFOR
RETURN(lcSENHA)

* ROTINAS DE CONEXAO E ACESO AOS DADOS (SQL)

FUNC PESQUISASQL
****************
PARAMETERS tcSINTAXE, tcARQUIVO
	IF USED(tcARQUIVO)
		USE IN &tcARQUIVO
	ENDIF
	LOCAL lnQTDDATAS, lnXI, lnOCO AS Integer
	LOCAL lcAUX, lcLETRA, lcTAG1, lcTAG2 AS String
	STORE 0 TO lnQTDDATAS, lnXI, lnOCO
	STORE '' TO lcAUX, lcLETRA, lcTAG1, lcTAG2

	lnOCO = AT(CHR(9),tcSINTAXE)
	IF lnOCO > 0
		DO MENS WITH '<TAB> no meio da sintaxe SQL'+CHR(13)+;
					SUBSTR(tcSINTAXE,MAX(1,lnOCO-15),30)
	ENDIF

	* TRATAMENTO DE CAMPOS DATETIME
	IF 'TO_CHART(' $ tcSINTAXE
		lcTAG1 = 'TO_CHART('
		lcTAG2 = ')TO_CHART'
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS'
				lcNEW1 = "DATE_FORMAT("
				lcNEW2 = ",'%D/%m/%Y %H:%I:%S')"
			CASE goCONEXAO.BANCO = 'POS'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY HH24:MI:SS')"
			CASE goCONEXAO.BANCO = 'ORA'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY HH24:MI:SS')"
			CASE goCONEXAO.BANCO = 'DBC'
				lcNEW1 = 'TTOC('
				lcNEW2 = ")"
			OTHERWISE
				lcNEW1 = 'CONVERT(VARCHAR(19),'
				lcNEW2 = ',120)'
		ENDCASE
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG1, lcNEW1 )
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG2, lcNEW2 )
	ENDIF

	* TRATAMENTO DE CAMPOS DATA
	IF 'TO_CHAR(' $ tcSINTAXE
		lcTAG1 = 'TO_CHAR('
		lcTAG2 = ')TO_CHAR'
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS'
				lcNEW1 = 'DATE_FORMAT('
				lcNEW2 = ",'%D/%m/%Y')"
			CASE goCONEXAO.BANCO = 'POS'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY')"
			CASE goCONEXAO.BANCO = 'ORA'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY')"
			CASE goCONEXAO.BANCO = 'DBC'
				lcNEW1 = 'DTOC('
				lcNEW2 = ")"
			OTHERWISE
				lcNEW1 = 'CONVERT(VARCHAR(10),'
				lcNEW2 = ',103)'
		ENDCASE
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG1, lcNEW1 )
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG2, lcNEW2 )
	ENDIF

	* CAMPOS DIA DA SEMANA
	IF 'FNOMDIA(' $ tcSINTAXE
		STORE '' TO lcNEW1, lcNEW2
		lcTAG1 = 'FNOMDIA('
		lcTAG2 = ')FNOMDIA'
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS'
				**
			CASE goCONEXAO.BANCO = 'POS'
				**
			CASE goCONEXAO.BANCO = 'ORA'
				**
			CASE goCONEXAO.BANCO = 'DBC'
				**
			OTHERWISE
				lcNEW1 = "SUBSTR('DomingoSegundaTerça  Quarta Quinta Sexta  Sábado ',(DATEPART(dw,"
				lcNEW2 = ')-1)*7+1,7)'
		ENDCASE
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG1, lcNEW1 )
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG2, lcNEW2 )
	ENDIF

	* TRATAMENTO DE CAMPOS NULOS
	IF 'ISNULL(' $ tcSINTAXE
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS' &&&  LINHA ALTERADA  &&&
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','COALESCE(')
			CASE goCONEXAO.BANCO = 'POS'
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','COALESCE(')
			CASE goCONEXAO.BANCO = 'ORA'
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','NVL(')
			CASE goCONEXAO.BANCO = 'DBC'
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','NVL(')
			OTHERWISE
				* NÃO PRECISA FAZER (PADRÃO MS-SQL SERVER)
		ENDCASE
	ENDIF

	* TRATAMENTOS ESPECIAIS DE SINTAXE
	DO CASE
		CASE goCONEXAO.BANCO = 'DBC'
			tcSINTAXE = TRATASQLFOX(tcSINTAXE)
		CASE goCONEXAO.BANCO = 'POS'
			tcSINTAXE = TRTSINPGSQL(tcSINTAXE)
			tcSINTAXE = TRTFUNPGSQL(tcSINTAXE)
		CASE goCONEXAO.BANCO = 'ORA'
			tcSINTAXE = TRATASQLORACLE(tcSINTAXE)
		CASE goCONEXAO.BANCO = 'MYS'
			tcSINTAXE = TRATAMYSQL(tcSINTAXE)
		OTHERWISE
			tcSINTAXE = TRATASQLMSSQL(tcSINTAXE)
	ENDCASE

	DO CASE
		CASE goCONEXAO.BANCO = 'DBC'
			* BANCO DE DADOS NATIVO DO FOX, NÃO UTILIZA DRIVER ODBC. TODAS AS PESQUISAS FUNCIONAM COM COMANDOS NATIVOS.
			tcSINTAXE	= STRTRAN( tcSINTAXE, CHR(13)+CHR(10), ' ' )
			tcSINTAXE	= STRTRAN( tcSINTAXE, CHR(09), '' )
	ENDCASE

	* EXECUTA COMANDO NA BASE
	gnSQLOK = SQLEXEC(goCONEXAO.ALCA,tcSINTAXE,tcARQUIVO)
        
	IF gnSQLOK<0
		=AERROR(laERRO)

		lcNUMERRO	= ALLTRIM(STR(laERRO(1)))
		lcERRO		= laERRO(3)

		lnRESP	= MESSAGEBOX('ERRO NO ACESSO À BASE DE DADOS: ' + CHR(13)+CHR(10)+;
								SYS(16)+CHR(13)+CHR(10)+;
								lcNUMERRO+CHR(13)+CHR(10)+;
								lcERRO,'AVISO: SQL-ERRO',48+2+256)
		IF lnRESP = 3
			_CLIPTEXT	= tcSINTAXE
			DEBUG
			SUSP
		ENDIF
		IF lnRESP = 4
			_CLIPTEXT = tcSINTAXE
		ENDIF
	ELSE
		* TRATAMENTO DE ARREDONDAMENTO DAS CASAS DECIMAIS SOMENTE NO ORACLE
		** DEVIDO A BUG DO DRIVER {MICROSOFT ODBC PARA ORACLE} AO EFETUAR FUNÇÕES COMO SUM, MAX, MIN E ETC...
		LOCAL ARRAY laCAMPOS[1]
		
		LOCAL lnXI AS Integer
		STORE 0 TO lnXI
		
		LOCAL lcMACRO, lcFIELDS AS String
		STORE '' TO lcMACRO, lcFIELDS

		LOCAL llOK AS Logical
		STORE .F. TO llOK

		IF 'ORACLE' $ UPPER(goCONEXAO.DRIVER)
			=AFIELDS(laCAMPOS,tcARQUIVO)
			FOR lnXI = 1 TO ALEN(laCAMPOS,1)
				IF 'VL_' $ UPPER(laCAMPOS[lnXI,1]) AND laCAMPOS[lnXI,2] = 'N' AND laCAMPOS[lnXI,3] = 20 AND laCAMPOS[lnXI,4] = 0
					lcFIELDS = lcFIELDS + ',CAST(' + laCAMPOS[lnXI,1] + ' AS N(20,2)) AS ' + laCAMPOS[lnXI,1]
					llOK = .T.
				ELSE
					lcFIELDS = lcFIELDS + ',' + laCAMPOS[lnXI,1]
				ENDIF
			ENDFOR
			IF llOK
				lcFIELDS = SUBSTR(lcFIELDS,2)
				lcMACRO = 'SELECT ' + lcFIELDS + ' FROM ' + tcARQUIVO + ' INTO CURSOR ' + tcARQUIVO + ' READWRITE'
				&lcMACRO
			ENDIF
		ENDIF
	ENDIF
RETURN

PROC VERERROCONEXAO
****************
* TRATA ERRO DE CONEXÃO COM BANCO DE DADOS OU SERVIDOR (PROBLEMAS DE REDE)
* RETORNA .T. SE É UM ERRO DE CONEXÃO
LPARAMETERS tuERRO1 AS Variant, tuERRO2 AS Variant
	LOCAL llRETORNO AS Logical
	STORE .F. TO llRETORNO
	
	LOCAL lcERRO1, lcERRO2 AS String
	DO CASE
		CASE VARTYPE(tuERRO1) = 'C'
			lcERRO1 = tuERRO1
		CASE VARTYPE(tuERRO1) = 'N'
			lcERRO1 = ALLTRIM(STR(tuERRO1))
		OTHERWISE
			lcERRO1 = ''
	ENDCASE
	DO CASE
		CASE VARTYPE(tuERRO2) = 'C'
			lcERRO2 = tuERRO2
		CASE VARTYPE(tuERRO2) = 'N'
			lcERRO2 = ALLTRIM(STR(tuERRO2))
		OTHERWISE
			lcERRO2 = ''
	ENDCASE
	
	DO CASE
		CASE goCONEXAO.BANCO = 'DBC'
				llRETORNO = .F.

		CASE goCONEXAO.BANCO = 'POS'
			IF lcERRO1 == '08S01' AND lcERRO2 == '27'
				llRETORNO = .T.
			ENDIF
			
		CASE goCONEXAO.BANCO = 'ORA'
			IF lcERRO2 == '3113' OR lcERRO2 == '3114' OR lcERRO2 == '12571'
				llRETORNO = .T.
			ENDIF
		
		CASE 'SQL SERVER' $ UPPER(goCONEXAO.DRIVER)
			IF (lcERRO1 == '08S01' AND lcERRO2 == '11') OR;
			   (lcERRO1 == '08S01' AND lcERRO2 == '0') OR;
			   (lcERRO1 == '01000' AND lcERRO2 == '10054')
				llRETORNO = .T.
			ENDIF			

		OTHERWISE
			llRETORNO = .F.
	ENDCASE
	
	LOCAL lcMACRO AS String
	
RETURN(llRETORNO)

PROC REPETIRQUERY
*****************
*TENTA RE-EXECUTAR UMA QUERY NO BANCO APÓS UMA QUEDA DE CONEXÃO
	* EXECUTA COMANDO NA BASE
	LOCAL lnSQLOK AS INTEGER
	lnSQLOK = SQLEXEC(goCONEXAO.ALCA,goCONEXAO.LASTCOMMAND,goCONEXAO.LASTCURSOR)
	RETURN lnSQLOK
RETURN

FUNC RETORNASET
***************
LPARAMETERS tcPARAMETRO, tcDATATYPE, tnLOAD
	IF TYPE('tcPARAMETRO') <> 'C'
		RETURN('')
	ENDIF
	tcPARAMETRO	= ALLTRIM(tcPARAMETRO)
	IF TYPE('tcDATATYPE') <> 'C'
		tcDATATYPE = 'C'
	ENDIF
	IF TYPE('tnLOAD') <> 'N'
		tnLOAD = 1
	ENDIF
	LOCAL lcCONTEUDO, lcCOMANDO, lcPOINT, lcSEPA AS String
	lcPOINT = SET("Point")
	lcSEPA	= SET('SEPA')
	SET POINT TO ','
	SET SEPA TO '.'
	LOCAL luRETORNO
	IF tnLOAD = 1
		* PROPRIEDADE DO APLICATIVO
		lcCONTEUDO = STREXTRACT(goAPLICATIVO.ZWS,;
					'<'+tcPARAMETRO+'>',;
					'</'+tcPARAMETRO+'>')
		IF tcPARAMETRO = 'SEGMENTO.PICTURE'
			IF EMPTY(lcCONTEUDO) OR ISNULL(lcCONTEUDO)
				lcCONTEUDO	= 'X.XX.XXX'
			ENDIF
		ENDIF
	ELSE
		* REGISTRO VINDO DA TABELA NO BANCO DE DADOS
		lcCOMANDO = 'SELECT DS_CONTEUDO FROM TS_PARAMETROS'+;
					' WHERE TG_INICIO=0 AND DS_PARAMETRO='+XX(tcPARAMETRO)
		=PESQUISASQL(LCCOMANDO,'TMPZWS')
		lcCONTEUDO	= TMPZWS.DS_CONTEUDO
		USE IN TMPZWS
	ENDIF
	* FORMATANDO NO TIPO DE DADO SOLICITADO
	DO CASE
		CASE tcDATATYPE = 'C'
			luRETORNO = ALLTRIM(lcCONTEUDO)
		CASE tcDATATYPE = 'N'
			luRETORNO = VAL(lcCONTEUDO)
		CASE tcDATATYPE = 'D'
			luRETORNO = CTOD(lcCONTEUDO)
		CASE tcDATATYPE = 'L'
			luRETORNO = IIF(lcCONTEUDO='.T.',.T.,.F.)
	ENDCASE
	SET POINT TO lcPOINT
	SET SEPA TO lcSEPA
RETURN(luRETORNO)

FUNC TRATASQLFOX
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	IF ' CASE WHEN ' $ lcCPOOUT
		lcCPOOUT = STRTRAN( lcCPOOUT, ' CASE WHEN '	, ' IIF( '	)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' THEN '			, ' , '		)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' ELSE '			, ' , '		)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' END '			, ' ) '		)
	ENDIF
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LPAD(', 'PADL(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'RPAD(', 'PADR(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(')
RETURN(lcCPOOUT)

FUNC TRTSINPGSQL
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(')
	lcCPOOUT = STRTRAN( lcCPOOUT, "\'", "\.'" )
RETURN(lcCPOOUT)

FUNC TRTFUNPGSQL
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = REMOVERTOPSQL(lcCPOOUT,'LIMIT')
	lcCPOOUT = STRTRAN( lcCPOOUT, ' SPACE( ', ' LPAD(" ",')
RETURN(lcCPOOUT)

FUNC TRATASQLORACLE
*******************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT, lcP1, lcP2 AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT	= tcCPOIN
	lcCPOOUT	= STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(' )
	lcCPOOUT	= STRTRAN( lcCPOOUT, ' SPACE( ', ' LPAD(" ",' )
	* TRATANDO POR PARTES
	IF 'FROM' $ lcCPOOUT
		lcP1 = STREXTRACT(lcCPOOUT,'','FROM',1,4)
		lcP2 = STREXTRACT(lcCPOOUT,'FROM','',1,0)
		lcP2 = STRTRAN( lcP2, ' AS ', ' ')
		lcP1 = REMOVERTOPSQL(lcP1,'ROWNUM')
		lcCPOOUT = lcP1+lcP2
	ENDIF
	IF 'DATE_PART(' $ lcCPOOUT
		LOCAL lcAUX, lcCONTEUDO AS String
		LOCAL lnXI AS Integer
		FOR lnXI = 1 TO OCCURS('DATE_PART(',lcCPOOUT)
			lcCONTEUDO = STREXTRACT(lcCPOOUT,'DATE_PART(',')',lnXI)
			IF EMPTY(lcCONTEUDO)
				LOOP
			ENDIF
			DO CASE
				CASE 'DAY' $ lcCONTEUDO
					lcAUX = STREXTRACT( lcCONTEUDO, ',' , '' ) + ", 'DD'" 
					lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
				CASE 'MONTH' $ lcCONTEUDO
					lcAUX = STREXTRACT( lcCONTEUDO, ',' , '' ) + ", 'MM'"
					lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
				CASE 'YEAR' $ lcCONTEUDO
					lcAUX = STREXTRACT( lcCONTEUDO, ',' , '' ) + ", 'YYYY'"
					lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
				OTHERWISE
					LOOP
			ENDCASE										
		ENDFOR
		lcCPOOUT= STRTRAN(lcCPOOUT,'DATE_PART(','TO_CHAR(')
	ENDIF
RETURN(lcCPOOUT)

FUNC TRATAMYSQL
***************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT, lcAUX, lcP1, lcP2 AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT	= tcCPOIN
	lcCPOOUT 	= STRTRAN( lcCPOOUT, ' INTEGER' , ' DECIMAL(11,0)' )
	lcCPOOUT 	= STRTRAN( lcCPOOUT, '\' , '\\' )
	lcCPOOUT 	= REMOVERTOPSQL(lcCPOOUT,'LIMIT')
	IF ('CONCAT(' $ lcCPOOUT) AND (')CONCAT' $ lcCPOOUT)
		LOCAL lcAUX, lcCONTEUDO AS String
		LOCAL lnXI AS Integer
		FOR lnXI = 1 TO OCCURS('CONCAT(',lcCPOOUT)
			lcCONTEUDO = STREXTRACT(lcCPOOUT,'CONCAT(',')CONCAT',lnXI)
			IF EMPTY(lcCONTEUDO)
				LOOP
			ENDIF
			lcAUX 	= STRTRAN( lcCONTEUDO, '||' , ',' )
			lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
			lcCPOOUT= STRTRAN(lcCPOOUT,')CONCAT',')',1,1)
		NEXT
	ENDIF
	IF (' NUMERIC(' $ lcCPOOUT)
		lcCPOOUT	= STRTRAN(lcCPOOUT,' NUMERIC(',' DECIMAL(')
	ENDIF
	
	IF ('COALESCE(' $ lcCPOOUT)
		LOCAL lcAUX, lcCAMPO, lcCONTEUDO AS String
		LOCAL lnXI AS Integer
		FOR lnXI = 1 TO OCCURS('COALESCE(',lcCPOOUT)
			lcCONTEUDO = STREXTRACT(lcCPOOUT,'COALESCE(',')',lnXI)
			IF EMPTY(lcCONTEUDO)
				LOOP
			ENDIF

			lcCAMPO	= STREXTRACT(lcCONTEUDO,'',',',1)			
			lcAUX	= STREXTRACT(lcCONTEUDO,',','',1)
			IF ALLTRIM(lcAUX) == '0'
				lcCPOOUT	= STRTRAN(lcCPOOUT,'COALESCE(' + lcCAMPO + ',' + lcAUX + ')','COALESCE(' + lcCAMPO + ', 0.0)',1,1)
			ENDIF
		NEXT
	ENDIF
	
	IF ('COUNT(*)' $ lcCPOOUT)
		lcCPOOUT	= STRTRAN(lcCPOOUT,'COUNT(*)','COALESCE(COUNT(*),0.0)')
	ENDIF
RETURN(lcCPOOUT)

FUNC TRATASQLMSSQL
******************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT, lcCONTEUDO, lcSUBSTITUI, lcAUX AS String
	LOCAL lnXI, lnOCO AS Integer
	STORE '' TO lcCPOOUT, lcCONTEUDO, lcSUBSTITUI, lcAUX
	STORE 0 TO lnXI, lnOCO
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = STRTRAN( lcCPOOUT, '||' , '+' )
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTR(', 'SUBSTRING(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LENGTH(', 'LEN(')
	IF 'LPAD(' $ lcCPOOUT
		FOR lnXI = 1 TO 100
			lcCONTEUDO	= STREXTRACT(lcCPOOUT,'LPAD(',')')
			IF EMPTY(lcCONTEUDO)
				EXIT
			ENDIF
			lnOCO		= RAT( ',' , lcCONTEUDO )
			lcSUBSTITUI	= 'CAST( ' + ;
							LEFT( lcCONTEUDO,lnOCO-1 ) + ;
							' AS CHAR(' + ;
							RIGHT( lcCONTEUDO,lnOCO-2 ) + '))'
			lcCPOOUT	= STRTRAN( lcCPOOUT, 'LPAD(' + lcCONTEUDO + ')', lcSUBSTITUI )
		ENDFOR
	ENDIF
	IF 'RPAD(' $ lcCPOOUT
		FOR lnXI = 1 TO 100
			lcCONTEUDO	= STREXTRACT(lcCPOOUT,'RPAD(',')')
			IF EMPTY(lcCONTEUDO)
				EXIT
			ENDIF
			lnOCO		= RAT( ',' , lcCONTEUDO )
			lcSUBSTITUI	= 'CAST( ' + ;
							LEFT( lcCONTEUDO,lnOCO-1 ) + ;
							' AS ' + ;
							RIGHT( lcCONTEUDO,lnOCO-2 ) + ')'
			lcCPOOUT	= STRTRAN( lcCPOOUT, 'LPAD('+lcCONTEUDO+')', lcSUBSTITUI )
		ENDFOR
	ENDIF
	IF 'DATE_PART(' $ lcCPOOUT
		FOR lnXI = 1 TO 100
			lcCONTEUDO	= STREXTRACT(lcCPOOUT,'DATE_PART(',')')
			IF EMPTY(lcCONTEUDO)
				EXIT
			ENDIF
			lcAUX		= UPPER(STREXTRACT(lcCONTEUDO, "'", "'," ))
			IF NOT lcAUX $ 'DAY,MONTH,YEAR'
				LOOP
			ENDIF
			lcSUBSTITUI	= UPPER(lcAUX) + '(' + ;
							UPPER(STREXTRACT(lcCONTEUDO, "',")) + ')'
			lcCPOOUT	= STRTRAN( lcCPOOUT, 'DATE_PART('+lcCONTEUDO+')', lcSUBSTITUI )
		ENDFOR
	ENDIF
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LENGTH(', 'LEN(')
RETURN(lcCPOOUT)

FUNC REMOVERTOPSQL
******************
LPARAMETERS tcSQL, tcOUTROS
	LOCAL lcOUT AS String
	lcOUT = tcSQL
	IF ' TOP ' $ lcOUT
		LOCAL lcAUX, lcLETRA AS String
		LOCAL lnOCO AS Integer
		lcAUX	= ''
		lnOCO	= AT(' TOP ',lcOUT)
		FOR lnXI = lnOCO+5 TO LEN(lcOUT)
			lcLETRA = SUBSTR(lcOUT,lnXI,1)
			IF EMPTY(lcLETRA)
				EXIT
			ENDIF
			lcAUX = lcAUX + lcLETRA
		ENDFOR
		lcOUT	= STRTRAN(lcOUT,' TOP '+lcAUX,'')
		IF 'LIMIT' $ tcOUTROS
			lcOUT	= lcOUT + ' LIMIT '+lcAUX
		ENDIF
	ENDIF
RETURN(lcOUT)

PROC ATUSQL
***********************************************************************
* ATUSQL - ATUALIZA BASE SQL DE ACORDO COM A AÇÃO DESEJADA	- *
***********************************************************************
PARAMETERS tcACTION, tcTABELA, tcOUTROS, tcCAMPOSUPDATE
	* PARAMETRO1 - ACAO (A/M/D)
	* PARAMETRO2 - TABELA
	* PARAMETRO3 - STRING CONTENDO PALAVRAS-CHAVE
	* PARAMETRO4 - CAMPOS EXCEÇÕES (SE VAI GRAVAR OU NÃO, DEPENDE DAS PALAVRAS-CHAVE)
	* PALAVRAS-CHAVE:
	* NOAUTOINC = INDICA QUE O PK_ID NÃO É AUTONUMERAÇÃO (PRECISA GRAVA-LO)
	* NOSTOP = SE DER ERRO, NÃO PARA A APLICAÇÃO E LOGA O REGISTRO (USADO EM IMPORTAÇÕES)
	* UPDATE=NO = INDICA QUE OS CAMPOS RELACIONADOS DEVEM SER IGNORADOS
	* UPDATE=YES= INDICA QUE OS SÓ CAMPOS RELACIONADOS DEVEM SER GRAVADOS
	* ERRO=CONTINUE = INDICA QUE EM CASO DE ERRO NA GRAVACAO DEVE AVISAR, IGNORAR E PROSSEGUIR
	* ERRO=LOG = INDICA QUE NÃO VAI DAR MENSAGEM DE ERRO SQL, APENAS GERAR LOG
	IF TYPE('tcACTION') <> 'C'
		DO MENS WITH 'Nenhuma ação foi informada (ATUSQL)'
		RETURN
	ENDIF
	IF EMPTY(ALIAS())
		DO MENS WITH 'Nenhuma tabela selecionada (ATUSQL)'
		RETURN
	ENDIF
	IF NOT tcACTION $ 'AMD'
		DO MENS WITH 'Ação informada não foi reconhecida: ('+tcACTION+') ATUSQL'
		RETURN
	ENDIF
	IF TYPE('tcTABELA') <> 'C'
		tcTABELA = ALIAS()
	ENDIF
	IF TYPE('tcOUTROS') <> 'C'
		tcOUTROS = ''
	ENDIF
	IF TYPE('tcCAMPOSUPDATE') <> 'C'
		tcCAMPOSUPDATE = ''
	ENDIF
	tcCAMPOSUPDATE = VIRGULAR(tcCAMPOSUPDATE)

	lnUPDATE = 0
	IF 'UPDATE=NO' $ tcOUTROS
		lnUPDATE = 1
		tcCAMPOSUPDATE	= STRTRAN( tcCAMPOSUPDATE, 'DH_INCLUSAO', '' )
		tcCAMPOSUPDATE	= STRTRAN( tcCAMPOSUPDATE, 'DH_ALTERACAO', '' )
		tcCAMPOSUPDATE	= STRTRAN( tcCAMPOSUPDATE, 'FK_OWNER', '' )
	ENDIF
	IF 'UPDATE=YES' $ tcOUTROS
		lnUPDATE = 2
		tcCAMPOSUPDATE	= tcCAMPOSUPDATE + ',DH_INCLUSAO,DH_ALTERACAO,FK_OWNER,'
	ENDIF

	PRIVATE ARRAY laERRO[1]
	PRIVATE lnSQLOK, lnRESP, lnIDENTITY, lnCONTEUXID, lnRESPIDENTITY AS Integer
	PRIVATE lcATUSQL, lcERRO, lcALIASUI, lcCMDIDENTITY, lcMOTIVO, pcSINTAXELIXEIRA, lcALIASFOX AS String
	LOCAL lcAUX AS String

	* OBJETO PARA ATUALIZAÇÃO DE ESTOQUE (SALDO ON-LINE)
	PRIVATE poESTOQUE AS Object
	poESTOQUE	= CREATEOBJECT('EMPTY')
	* PROPRIEDADES GERAIS
	=ADDPROPERTY(poESTOQUE,'FK_PROANT','')
	=ADDPROPERTY(poESTOQUE,'FK_PROATU','')
	=ADDPROPERTY(poESTOQUE,'FK_ESTANT','')
	=ADDPROPERTY(poESTOQUE,'FK_ESTATU','')
	=ADDPROPERTY(poESTOQUE,'TG_ESTANT',0)
	=ADDPROPERTY(poESTOQUE,'TG_ESTATU',0)
	=ADDPROPERTY(poESTOQUE,'QT_ESTANT',0)
	=ADDPROPERTY(poESTOQUE,'QT_ESTATU',0)
	* CONTROLE DE ATUALIZAÇÃO POR FOR E TAMANHO
	=ADDPROPERTY(poESTOQUE,'FK_CORANT',SPACE(3))
	=ADDPROPERTY(poESTOQUE,'FK_CORATU',SPACE(3))
	=ADDPROPERTY(poESTOQUE,'FK_TAMANT',SPACE(3))
	=ADDPROPERTY(poESTOQUE,'FK_TAMATU',SPACE(3))
	* PROPRIEDADES PARA CONTROLE DE QTD DE NOTAS FISCAIS (E/S)
	=ADDPROPERTY(poESTOQUE,'TG_ORIANT','')
	=ADDPROPERTY(poESTOQUE,'TG_ORIATU','')
	* PROPRIEDADES PARA CONTROLE DE CONSIGNAÇÃO
	=ADDPROPERTY(poESTOQUE,'TG_CONANT',0)
	=ADDPROPERTY(poESTOQUE,'TG_CONATU',0)
	* PROPRIEDADES PARA CONTROLE DE PENDÊNCIA DE PRODUTOS (VENDAS)
	=ADDPROPERTY(poESTOQUE,'TG_PENANT',0)
	=ADDPROPERTY(poESTOQUE,'TG_PENATU',0)
	=ADDPROPERTY(poESTOQUE,'TG_PENTEM',0)

	* VARIAVEIS PARA RESERVA DE PRODUTOS
	PRIVATE poRESERVA AS Object
	poRESERVA	= CREATEOBJECT('EMPTY')
	* PROPRIEDADES GERAIS
	=ADDPROPERTY(poRESERVA,'FK_PROANT','')
	=ADDPROPERTY(poRESERVA,'FK_PROATU','')
	=ADDPROPERTY(poRESERVA,'FK_ESTANT','')
	=ADDPROPERTY(poRESERVA,'FK_ESTATU','')
	=ADDPROPERTY(poRESERVA,'TG_RESANT',0)
	=ADDPROPERTY(poRESERVA,'TG_RESATU',0)
	=ADDPROPERTY(poRESERVA,'QT_RESANT',0)
	=ADDPROPERTY(poRESERVA,'QT_RESATU',0)

	* GRAVA ESPELHO DO REGISTRO PARA ARMAZENAR NA LIXEIRA DO SISTEMA
	pcSINTAXELIXEIRA	= ''

	lnSQLOK		= -1				&& CONTROLE DE OPERAÇÃO BEM SUCEDIDA
	luPK_ID		= PK_ID
	lcATUSQL	= ''
	lcALIASFOX  = ALIAS()

	pnAUTOINC = 0
	IF TYPE(ALIAS()+'.PK_ID') = 'N' AND NOT 'NOAUTOINC' $ tcOUTROS
		* POR DEFAULT OS PK NUMERICOS SÃO AUTONUMERAÇÃO
		pnAUTOINC = 1
	ENDIF

	* SE FOR FOXPRO E AUTONUMERAÇÃO, PEGA PROX.NUMERO (RECNO)
	IF pnAUTOINC=1 AND tcACTION='A'
		IF 'FOXPRO' $ UPPER(goCONEXAO.DRIVER)
			lcPROXIMO = 'SELECT RECCOUNT('+XX(tcTABELA)+') AS PROXIMO FROM DUAL'
			=PESQUISASQL(lcPROXIMO,'TMPLASTPK')
			luPK_ID		= TMPLASTPK.PROXIMO+1
			USE IN TMPLASTPK
			pnAUTOINC=0
			SELE &lcALIASFOX
			REPLACE PK_ID WITH luPK_ID
		ENDIF
	ENDIF

	* MONTA SINTAXE COMPLETA
	DO MONTASQLC

	* TRATAMENTOS ESPECIAIS DE SINTAXE
	DO CASE
		CASE goCONEXAO.BANCO = 'DBC'
			lcATUSQL = TRATASQLFOX(lcATUSQL)
		CASE goCONEXAO.BANCO = 'POS'
			lcATUSQL = TRTSINPGSQL(lcATUSQL)
		CASE goCONEXAO.BANCO = 'ORA'
			lcATUSQL = TRATASQLORACLE(lcATUSQL)
		CASE goCONEXAO.BANCO = 'MYS'
			lcATUSQL = TRATAMYSQL(lcATUSQL)
		OTHERWISE
			lcATUSQL = TRATASQLMSSQL(lcATUSQL)
	ENDCASE

	lcATUSQL	= lcATUSQL

	* EXECUTA COMANDO NA BASE
	lnSQLOK		= SQLEXEC(goCONEXAO.ALCA,lcATUSQL)

	IF lnSQLOK<0
		=AERROR(laERRO)
		lcNUMERRO	= ALLTRIM(STR(laERRO(1)))
		lcERRO		= laERRO(3)

		DO CASE
			CASE goAPLICATIVO.TESTE
				* TRATAMENTO DE ERRO CONTORNAVEL (AREA DE TESTES)
				lnRESP	= MESSAGEBOX('ERRO NO COMANDO À BASE DE DADOS: ' + CHR(13)+CHR(10)+;
									SYS(16)+CHR(13)+CHR(10)+;
									lcNUMERRO+CHR(13)+CHR(10)+;
									lcERRO,'AVISO: SQL-ERRO',48+2+256)
				IF lnRESP = 3
					IF goAPLICATIVO.TESTE
						DEBUG
						SUSPEND
					ELSE
						DO ROTERRO WITH 0-laERRO(1), lcERRO, SYS(16), 0
					ENDIF
				ENDIF
				IF lnRESP = 4
					_CLIPTEXT = lcATUSQL
				ENDIF
			OTHERWISE
				* TRATAMENTO DE ERRO CONVENCIONAL (AMBIENTE DE PRODUÇÃO)

				* TRATAMENTO DE ERRO COMUM
				DO ROTERRO WITH 0-laERRO(1), lcERRO, SYS(16), 0
				RETURN
		ENDCASE
	ENDIF
	IF 'ORACLE' $ UPPER(goCONEXAO.DRIVER)
		=SQLEXEC(goCONEXAO.ALCA,'COMMIT')
	ENDIF

	IF tcACTION='A' AND pnAUTOINC=1
		* SE FOI UM INSERT, PEGAR O CAMPO C/ AUTOINCREMENTO (IDENTITY)
		lcALIASUI	= ALIAS()
		lnIDENTITY	= 0
		DO PEGAULTINC WITH tcTABELA
		SELECT &lcALIASUI
		IF lnIDENTITY>0
			* ATUALIZA CAMPO AUTO-NUMERAÇÃO NA BASE LOCAL
			REPLACE PK_ID WITH lnIDENTITY
		ELSE
			lnSQLOK = -2
			* EXCLUIR REGISTRO (NAO FOI INCLUIDO NO SQL)
			DELETE
			SKIP-1
			IF BOF() AND NOT EOF()
				SKIP
			ENDIF
		ENDIF
	ENDIF

	IF NOT EMPTY(lcALIASFOX)
		SELECT &lcALIASFOX
	ENDIF
RETURN(PK_ID)

PROC PEGAULTINC
***************
LPARAMETERS tcTABELA AS String
	IF TYPE('tcTABELA') <> 'C'
		tcTABELA	= ''
	ENDIF
	IF EMPTY(tcTABELA)
		RETURN
	ENDIF
	DO CASE
		CASE goCONEXAO.BANCO = 'MYS' &&&  LINHA ALTERADA  &&&
			lcCMDIDENTITY	= 'SELECT MAX(PK_ID) ULTIMAINC FROM '+tcTABELA 
		CASE 'POSTGRES' $ UPPER(goCONEXAO.DRIVER)
			lcCMDIDENTITY	= "SELECT CURRVAL('"+tcTABELA+"_S'::text) AS ULTIMAINC" &&tcSEQUENCIA
		CASE goCONEXAO.BANCO = 'ORA'
			lcCMDIDENTITY	= 'SELECT '+tcTABELA+'_S.CURRVAL AS ULTIMAINC FROM DUAL'
		CASE goCONEXAO.BANCO = 'DBC'
			* FALTA: MÉTODO PARA PEGAR ÚLTIMO REGISTRO NO FOX
		OTHERWISE
			*SQL SERVER
			lcCMDIDENTITY	= 'SELECT @@IDENTITY AS ULTIMAINC'
	ENDCASE
	lnRESPIDENTITY	= SQLEXEC(goCONEXAO.ALCA,lcCMDIDENTITY,'TMPLASTPK')

	lcMOTIVO = ''
	IF lnRESPIDENTITY<0
		lcMOTIVO = 'EXEC-SQL'
	ENDIF
	IF TYPE('ULTIMAINC')<>'N'
		lcMOTIVO = 'SEM PK_ID'
	ENDIF
	IF ULTIMAINC<=0
		lcMOTIVO = 'PK_ID SEM CONTEUDO'
	ENDIF
	IF NOT EMPTY(lcMOTIVO)
		DO MENS WITH 'ERRO NA INCLUSÃO (P/RETORNAR PK_ID): '+lcMOTIVO+' ATUSQL'
	ELSE
		*RETORNA ULTIMA INSERÇÃO
		lnIDENTITY = ULTIMAINC
	ENDIF
	USE IN TMPLASTPK
RETURN

PROC MONTASQLC
*******************
* MONTA COMANDO DE ACORDO COM A ACAO EXECUTADA NA BASE LOCAL
* OBS: A ACAO É EFETUADA NO DBF (CURSOR LOCAL) E DEPOIS PRECISA QUE SEJA ATUALIZADA
* ---- A BASE SQL. ASSIM ESTE COMANDO É MONTADO PARA SER EXECUTADO E EFETUAR ESTA TAREFA

	*CONDICAO
	LOCAL lcSQLCONDI AS String
	lcSQLCONDI = " WHERE PK_ID="+XX(luPK_ID)

	* MONTA NOME DA TABELA NO SQL
	IF tcTABELA = 'TMP'
		RETURN
	ENDIF

	* MONTA SINTAXE DE CADA COMANDO, DEPENDENDO DA AÇÃO
	LOCAL lnORIGEM, lcCPOORIGEM, lcCOMANDO, lcCPOAUX AS String
	STORE '' TO lnORIGEM, lcCPOORIGEM, lcCPOAUX

	* VARIAVEIS DE ATUALIZAÇÃO DE ESTOQUE
	LOCAL llresBXATU AS Logical
	LOCAL lcestCOMANDO, lcestTABANT, lcestTGES AS String
	STORE .F. TO llresBXATU
	STORE '' TO lcestCOMANDO, lcestTABANT, lcestTGES

	lcCPOAUX = ''
	DO CASE
		CASE tcACTION = 'D'
			* DELETAR REGISTRO (DELETE)
			lcATUSQL = 'DELETE FROM '+tcTABELA+lcSQLCONDI

			* GRAVANDO ESPELHO DO REGISTRO
			lcCOMANDO = 'SELECT * FROM '+tcTABELA+lcSQLCONDI

			* CONTROLE DE ATUALIZAÇÃO DE ESTOQUE E CONSIGNAÇÃO
			IF tcTABELA = 'ES_MOVIMENTOS'
				lcestTABANT		= ALIAS()
				TEXT TO lcestCOMANDO NOSHOW PRETEXT 7
					SELECT
						*
					FROM
						ES_MOVIMENTOS
					<<CONDICAO>>
				ENDTEXT
				lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<TABELA>>',tcTABELA)
				lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<CONDICAO>>',lcSQLCONDI)
				=PESQUISASQL(lcestCOMANDO,'TMPESTAUX')
				SELE TMPESTAUX

				* ATUALIZAÇÃO DA QTD ON-LINE
				poESTOQUE.FK_PROATU		= TMPESTAUX.FK_PRODUTO
				poESTOQUE.FK_ESTATU		= TMPESTAUX.FK_ESTOQUE
				poESTOQUE.TG_ESTATU		= TMPESTAUX.TG_ESTOQUE
				poESTOQUE.TG_ORIATU		= TMPESTAUX.TG_ORIGEM
				* CONTROLE DE ESTOQUE POR COR E TAMANHO
				IF TYPE('TMPESTAUX.FK_COR') = 'C'
					poESTOQUE.FK_CORATU	= TMPESTAUX.FK_COR
					poESTOQUE.FK_TAMATU	= TMPESTAUX.FK_TAMANHO
				ENDIF
				* CONTROLE DE PENDÊNCIAS
				IF TYPE('TMPESTAUX.TG_PENDENTE') = 'N'
					poESTOQUE.TG_PENATU	= TMPESTAUX.TG_PENDENTE
					poESTOQUE.TG_PENTEM	= 1
				ENDIF
				poESTOQUE.QT_ESTATU		= ABS( TMPESTAUX.QT_MOVIMENTO )
				IF TMPESTAUX.TG_ES = 'E'
					poESTOQUE.QT_ESTATU	= 0 - poESTOQUE.QT_ESTATU
				ENDIF
				* ATUALIZAÇÃO DA QTD DE CONSIGNAÇÃO
				poESTOQUE.TG_CONATU		= TMPESTAUX.TG_CONSIGNA

				USE IN TMPESTAUX
				IF NOT EMPTY(lcestTABANT)
					SELE (lcestTABANT)
				ENDIF
			ENDIF

			* CONTROLE DE RESERVA DE PRODUTOS
			IF tcTABELA = 'VD_RESERVAS'
				lcestTABANT		= ALIAS()
				TEXT TO lcestCOMANDO NOSHOW PRETEXT 7
					SELECT
						FK_PRODUTO,
						QT_RESERVA,
						TG_RESERVA,
						FK_ESTOQUE,
						DT_BAIXA
					FROM
						<<TABELA>>
						<<CONDICAO>>
				ENDTEXT
				lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<TABELA>>',tcTABELA)
				lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<CONDICAO>>',lcSQLCONDI)
				=PESQUISASQL(lcestCOMANDO,'TMPESTAUX')
				SELE TMPESTAUX
				poRESERVA.TG_RESANT	= TMPESTAUX.TG_RESERVA
				poRESERVA.FK_PROANT	= TMPESTAUX.FK_PRODUTO
				poRESERVA.FK_ESTANT	= TMPESTAUX.FK_ESTOQUE
				poRESERVA.QT_RESANT	= 0 - ABS( TMPESTAUX.QT_RESERVA )
				IF NOT ISNULL(TMPESTAUX.DT_BAIXA)
					poRESERVA.QT_RESANT	= 0
				ENDIF
				USE IN TMPESTAUX
				IF NOT EMPTY(lcestTABANT)
					SELE (lcestTABANT)
				ENDIF
			ENDIF

		CASE tcACTION = 'A'
			* INCLUIR REGISTRO (INSERT)
			WQF = AFIELDS(WTABF)
			STORE '' TO lcINSERE1, lcINSERE2
			FOR WXC = 1 TO WQF
				lcCPOAUX = ALLTRIM(WTABF[WXC,1])
				IF lcCPOAUX = 'PK_ID' AND pnAUTOINC=1
					* CAMPO IDENTITY
					LOOP
				ENDIF
				IF lcCPOAUX = 'DH_ALTERACAO'
					LOOP
				ENDIF
				IF lcCPOAUX = 'ROWGUID' OR lcCPOAUX = 'MSREPL_TRAN_VERSION'
					LOOP
				ENDIF
				IF lnUPDATE=1
					IF VIRGULAR(lcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO A SER IGNORADO
						LOOP
					ENDIF
				ENDIF
				IF lnUPDATE=2
					IF NOT VIRGULAR(lcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO QUE NÃO FAZ PARTE DA RELAÇÃO
						LOOP
					ENDIF
				ENDIF
				IF EMPTY(lcINSERE1)
					lcSEPARA = ''
				ELSE
					lcSEPARA = ', '
				ENDIF

				lcCONTEUDO = XX( &lcCPOAUX )
				IF lcCPOAUX = 'DH_INCLUSAO'
					lcCONTEUDO = D2SQL(DATE(),'HOJE')
				ENDIF

				IF '_KK' $ lcCPOAUX
					* CAMPO DE CONTROLE (NUNCA É FEITO UPDATE POR ESTA ROTINA
					lcTIPO	= TYPE(lcCPOAUX)
					DO CASE
						CASE lcTIPO $ 'CM'
							lcCONTEUDO = XX('')
						CASE lcTIPO = 'N'
							lcCONTEUDO = XX(0)
					ENDCASE
				ENDIF

				lcINSERE1 = lcINSERE1 + lcSEPARA + lcCPOAUX
				lcINSERE2 = lcINSERE2 + lcSEPARA + lcCONTEUDO

				* CONTROLE DE ATUALIZAÇÃO DE ESTOQUE E CONSIGNACAO
				IF tcTABELA = 'ES_MOVIMENTOS'
					IF lcCPOAUX	== 'QT_MOVIMENTO'
						poESTOQUE.QT_ESTATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'TG_ES'
						lcestTGES			= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'FK_ESTOQUE'
						poESTOQUE.FK_ESTATU	= &lcCONTEUDO
					ENDIF
					* ATUALIZAÇÃO DE ESTOQUE
					IF lcCPOAUX	== 'FK_PRODUTO'
						poESTOQUE.FK_PROATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'TG_ESTOQUE'
						poESTOQUE.TG_ESTATU	= &lcCONTEUDO
					ENDIF
					* ATUALIZAÇÃO DE QTDE DE NOTA (E/S)
					IF lcCPOAUX	== 'TG_ORIGEM'
						poESTOQUE.TG_ORIATU	= &lcCONTEUDO
					ENDIF
					* CONTROLE DE ESTOQUE POR COR E TAMANHO
					IF lcCPOAUX	== 'FK_COR'
						poESTOQUE.FK_CORATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'FK_TAMANHO'
						poESTOQUE.FK_TAMATU	= &lcCONTEUDO
					ENDIF
					* CONTROLE DE PENDENCIA
					IF lcCPOAUX	== 'TG_PENDENTE'
						poESTOQUE.TG_PENATU	= &lcCONTEUDO
					ENDIF
					* CONSIGNAÇÃO DE PRODUTOS
					IF lcCPOAUX	== 'TG_CONSIGNA'
						poESTOQUE.TG_CONATU	= &lcCONTEUDO
					ENDIF
				ENDIF
				* CONTROLE DE RESERVA DE PRODUTOS
				IF tcTABELA	= 'VD_RESERVAS'
					IF lcCPOAUX	== 'FK_PRODUTO'
						poRESERVA.FK_PROATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'FK_ESTOQUE'
						poRESERVA.FK_ESTATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'TG_RESERVA'
						poRESERVA.TG_RESATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'QT_RESERVA'
						poRESERVA.QT_RESATU	= &lcCONTEUDO
						poRESERVA.QT_RESATU	= ABS( poRESERVA.QT_RESATU )
					ENDIF
					IF lcCPOAUX	== 'DT_BAIXA'
						IF NOT 'NULL' $ UPPER(lcCONTEUDO)
							llresBXATU	= .T.
						ENDIF
					ENDIF
				ENDIF
			ENDFOR

			IF pnAUTOINC=1 AND 'ORACLE' $ UPPER(goCONEXAO.DRIVER)
				lcINSERE1	= 'PK_ID, ' + lcINSERE1
				lcINSERE2	= tcTABELA + '_S.NEXTVAL, ' + lcINSERE2
			ENDIF

			lcATUSQL = 'INSERT INTO '+tcTABELA+' ('+lcINSERE1+') VALUES ('+lcINSERE2+')'

			* CONTROLE DE ATUALIZAÇÃO DE ESTOQUE E CONSIGNAÇÃO
			IF tcTABELA = 'ES_MOVIMENTOS'
				lcestTABANT		= ALIAS()
				TEXT TO lcestCOMANDO NOSHOW PRETEXT 7
					SELECT
						*
					FROM
						ES_MOVIMENTOS
					WHERE
						PK_ID IS NULL
				ENDTEXT
				=PESQUISASQL(lcestCOMANDO,'TMPESTAUX')
				SELE TMPESTAUX
				* CONTROLE DE PENDÊNCIAS
				IF TYPE('TMPESTAUX.TG_PENDENTE') = 'N'
					poESTOQUE.TG_PENTEM	= 1
				ENDIF

				* QTDE ESTOQUE
				poESTOQUE.QT_ESTATU		= ABS(poESTOQUE.QT_ESTATU)
				IF lcestTGES <> 'E'
					poESTOQUE.QT_ESTATU	= 0 - poESTOQUE.QT_ESTATU
				ENDIF

				* NOTA FISCAL DE SAÍDA COM TIPO 'ENTRADA'
				* NÃO PODE ATUALIZAR ESTOQUE DE FATURA
				IF poESTOQUE.TG_ORIATU = 'N' AND lcestTGES = 'E'
					poESTOQUE.TG_ORIATU	= ''
				ENDIF

				USE IN TMPESTAUX
				IF NOT EMPTY(lcestTABANT)
					SELE (lcestTABANT)
				ENDIF

			ENDIF
			* CONTROLE DE RESERVA DE PRODUTOS
			IF llresBXATU
				poRESERVA.QT_RESATU	= 0
			ENDIF

		CASE tcACTION = 'M'
			* ALTERAR REGISTRO (UPDATE)
			LOCAL lcCAMPOSUP AS STRING
			WQF = AFIELDS(WTABF)
			lcCAMPOSUP = ''
			STORE '' TO lcINSERE1, lcINSERE2
			FOR WXC = 1 TO WQF
				lcCPOAUX = ALLTRIM(WTABF[WXC,1])
				IF lcCPOAUX = 'PK_ID'
					* CAMPO IDENTITY
					LOOP
				ENDIF
				IF lcCPOAUX = 'DH_INCLUSAO'
					LOOP
				ENDIF
				IF lcCPOAUX = 'ROWGUID' OR lcCPOAUX = 'MSREPL_TRAN_VERSION'
					LOOP
				ENDIF
				IF lnUPDATE=1
					IF VIRGULAR(lcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO A SER IGNORADO
						LOOP
					ENDIF
				ENDIF
				IF lnUPDATE=2
					IF NOT VIRGULAR(lcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO QUE NÃO FAZ PARTE DA RELAÇÃO
						LOOP
					ENDIF
				ENDIF
				IF '_KK' $ lcCPOAUX
					* CAMPO DE CONTROLE (NUNCA É FEITO UPDATE POR ESTA ROTINA
					LOOP
				ENDIF
				IF EMPTY(lcCAMPOSUP)
					lcSEPARA = ''
				ELSE
					lcSEPARA = ', '
				ENDIF

				lcCONTEUDO = XX( &lcCPOAUX )
				IF lcCPOAUX = 'DH_ALTERACAO'
					lcCONTEUDO = D2SQL(DATE(),'HOJE')
				ENDIF

				lcCAMPOSUP = lcCAMPOSUP + lcSEPARA + lcCPOAUX + "="+lcCONTEUDO

				* CONTROLE DE ATUALIZAÇÃO DE ESTOQUE E CONSIGNACAO
				IF tcTABELA = 'ES_MOVIMENTOS'
					IF lcCPOAUX	== 'QT_MOVIMENTO'
						poESTOQUE.QT_ESTATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'TG_ES'
						lcestTGES			= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'FK_ESTOQUE'
						poESTOQUE.FK_ESTATU	= &lcCONTEUDO
					ENDIF
					* ATUALIZAÇÃO DE ESTOQUE
					IF lcCPOAUX	== 'FK_PRODUTO'
						poESTOQUE.FK_PROATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'TG_ESTOQUE'
						poESTOQUE.TG_ESTATU	= &lcCONTEUDO
					ENDIF
					* ATUALIZAÇÃO DE QTDE DE NOTA (E/S)
					IF lcCPOAUX	== 'TG_ORIGEM'
						poESTOQUE.TG_ORIATU	= &lcCONTEUDO
					ENDIF
					* CONTROLE DE ESTOQUE POR COR E TAMANHO
					IF lcCPOAUX	== 'FK_COR'
						poESTOQUE.FK_CORATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'FK_TAMANHO'
						poESTOQUE.FK_TAMATU	= &lcCONTEUDO
					ENDIF
					* CONTROLE DE PENDENCIA
					IF lcCPOAUX	== 'TG_PENDENTE'
						poESTOQUE.TG_PENATU	= &lcCONTEUDO
					ENDIF
					* CONSIGNAÇÃO DE PRODUTOS
					IF lcCPOAUX	== 'TG_CONSIGNA'
						poESTOQUE.TG_CONATU	= &lcCONTEUDO
					ENDIF
				ENDIF
				* CONTROLE DE RESERVA DE PRODUTOS
				IF tcTABELA	= 'VD_RESERVAS'
					IF lcCPOAUX	== 'FK_PRODUTO'
						poRESERVA.FK_PROATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'FK_ESTOQUE'
						poRESERVA.FK_ESTATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'TG_RESERVA'
						poRESERVA.TG_RESATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'QT_RESERVA'
						poRESERVA.QT_RESATU	= &lcCONTEUDO
						poRESERVA.QT_RESATU	= ABS( poRESERVA.QT_RESATU )
					ENDIF
					IF lcCPOAUX	== 'DT_BAIXA'
						IF NOT 'NULL' $ UPPER(lcCONTEUDO)
							llresBXATU	= .T.
						ENDIF
					ENDIF
				ENDIF
			ENDFOR

			lcATUSQL = 'UPDATE '+tcTABELA+' SET '+ lcCAMPOSUP + lcSQLCONDI

			* CONTROLE DE ATUALIZAÇÃO DE ESTOQUE E CONSIGNAÇÃO
			IF tcTABELA = 'ES_MOVIMENTOS'
				lcestTABANT		= ALIAS()
				TEXT TO lcestCOMANDO NOSHOW PRETEXT 7
					SELECT
						*
					FROM
						ES_MOVIMENTOS
					<<CONDICAO>>
				ENDTEXT
				lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<TABELA>>',tcTABELA)
				lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<CONDICAO>>',lcSQLCONDI)
				=PESQUISASQL(lcestCOMANDO,'TMPESTAUX')
				SELE TMPESTAUX
				* QTDE ON-LINE
				poESTOQUE.FK_PROANT		= TMPESTAUX.FK_PRODUTO
				poESTOQUE.FK_ESTANT		= TMPESTAUX.FK_ESTOQUE
				poESTOQUE.TG_ESTANT		= TMPESTAUX.TG_ESTOQUE
				poESTOQUE.TG_ORIANT		= TMPESTAUX.TG_ORIGEM
				* CONTROLE DE ESTOQUE POR COR E TAMANHO
				IF TYPE('TMPESTAUX.FK_COR') = 'C'
					poESTOQUE.FK_CORANT	= TMPESTAUX.FK_COR
					poESTOQUE.FK_TAMANT	= TMPESTAUX.FK_TAMANHO
				ENDIF
				* CONTROLE DE PENDÊNCIAS
				IF TYPE('TMPESTAUX.TG_PENDENTE') = 'N'
					poESTOQUE.TG_PENANT	= TMPESTAUX.TG_PENDENTE
					poESTOQUE.TG_PENTEM	= 1
				ENDIF
				poESTOQUE.QT_ESTANT		= ABS( TMPESTAUX.QT_MOVIMENTO )
				IF TMPESTAUX.TG_ES <> 'E'
					poESTOQUE.QT_ESTANT	= 0 - poESTOQUE.QT_ESTANT
				ENDIF
				poESTOQUE.QT_ESTATU		= ABS(poESTOQUE.QT_ESTATU)
				IF lcestTGES <> 'E'
					poESTOQUE.QT_ESTATU	= 0 - poESTOQUE.QT_ESTATU
				ENDIF
				* CONSIGNAÇÃO
				poESTOQUE.TG_CONANT		= TMPESTAUX.TG_CONSIGNA

				* NOTA FISCAL DE SAÍDA COM TIPO 'ENTRADA'
				* NÃO PODE ATUALIZAR ESTOQUE DE FATURA
				IF poESTOQUE.TG_ORIATU = 'N' AND lcestTGES = 'E'
					poESTOQUE.TG_ORIATU	= ''
				ENDIF
				IF poESTOQUE.TG_ORIANT = 'N' AND TMPESTAUX.TG_ES = 'E'
					poESTOQUE.TG_ORIANT	= ''
				ENDIF

				USE IN TMPESTAUX
				IF NOT EMPTY(lcestTABANT)
					SELE (lcestTABANT)
				ENDIF

			ENDIF

			* CONTROLE DE RESERVA DE PRODUTOS
			IF tcTABELA = 'VD_RESERVAS'
				IF llresBXATU
					poRESERVA.QT_RESATU	= 0
				ENDIF
				lcestTABANT		= ALIAS()
				TEXT TO lcestCOMANDO NOSHOW PRETEXT 7
					SELECT
						FK_PRODUTO,
						QT_RESERVA,
						FK_ESTOQUE,
						TG_RESERVA,
						DT_BAIXA
					FROM
						<<TABELA>>
						<<CONDICAO>>
				ENDTEXT
				lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<TABELA>>',tcTABELA)
				lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<CONDICAO>>',lcSQLCONDI)
				=PESQUISASQL(lcestCOMANDO,'TMPESTAUX')
				SELE TMPESTAUX
				poRESERVA.TG_RESANT	= TMPESTAUX.TG_RESERVA
				poRESERVA.FK_PROANT	= TMPESTAUX.FK_PRODUTO
				poRESERVA.FK_ESTANT	= TMPESTAUX.FK_ESTOQUE
				poRESERVA.QT_RESANT	= 0 - ABS( TMPESTAUX.QT_RESERVA )
				IF NOT ISNULL(TMPESTAUX.DT_BAIXA)
					poRESERVA.QT_RESANT	= 0
				ENDIF
				USE IN TMPESTAUX
				IF NOT EMPTY(lcestTABANT)
					SELE (lcestTABANT)
				ENDIF
			ENDIF

	ENDCASE
RETURN

FUNC D2SQL
**********
LPARAMETERS tdENTRA, tcMODO
* PARAMETRO1= DATA A SER TRANSFORMADA (OU STRING)
* PARAMETRO2= MODO (DATA/STRING)
* ONDE: DATA=MONTA A STRING COM A DATA JA CONVERTIDA, EX: CONVERT(DATETIME,20/11/2004,103)
*       STRING=MONTA UMA STRING A SER TRATADA PELO SERVIDOR SQL, EX: CONVERT(DATETIME,CAMPO,103)
*              (ENVIAR O NOME DO CAMPO PARA A CONDIÇÃO)
	IF TYPE('tcMODO') <> 'C'
		tcMODO = 'DATA'
	ENDIF
	IF tcMODO = 'STRING'
		IF TYPE('tdENTRA') <> 'C'
			RETURN('')
		ENDIF
	ELSE
		IF NOT TYPE('tdENTRA') $ 'DT'
			tdENTRA = {}
		ENDIF
	ENDIF
	LOCAL luSAI
	luSAI = 'null'
	IF !EMPTY(tdENTRA)
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS' &&&  LINHA ALTERADA  &&&
				*data entre aspas no formato aaaammdd
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= 'NOW()'
					CASE tcMODO = 'STRING'
						luSAI	= "DATE_FORMAT("+tdENTRA+",'%M/%D/%Y')"
					OTHERWISE
						luSAI	= "'"+DTOS(tdENTRA)+"'"
				ENDCASE
			CASE goCONEXAO.BANCO = 'POS'
				*data entre aspas no formato aaaammdd
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= "NOW()"
					CASE tcMODO = 'STRING'
						luSAI	= "TO_CHAR("+tdENTRA+",'MM/DD/YYYY')"
					OTHERWISE
						LOCAL lcHHMMSS AS STRING
						lcHHMMSS = TTOC(tdENTRA,2)
						IF TYPE('tdENTRA')='D'
							*data entre aspas no formato aaaammdd
							luSAI = "TO_DATE('"+DTOS(tdENTRA)+"','YYYYMMDD')"
						ELSE
							*datahora entre aspas no formato aaaammdd
							lcHHMMSS = SUBSTR(lcHHMMSS,1,2)+':'+SUBSTR(lcHHMMSS,4,2)+':'+SUBSTR(lcHHMMSS,7,2)
							luSAI = "TO_TIMESTAMP('"+DTOS(tdENTRA)+lcHHMMSS+"','YYYYMMDDHH24:MI:SS')"
						ENDIF

				ENDCASE
			CASE goCONEXAO.BANCO = 'ORA'
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= 'SYSDATE'
					CASE tcMODO = 'STRING'
						luSAI = "TO_CHAR("+tdENTRA+",'DD/MM/YYYY')"
					OTHERWISE
						LOCAL lcHHMMSS AS STRING
						lcHHMMSS = TTOC(tdENTRA,2)
						IF TYPE('tdENTRA')='D'
							*data entre aspas no formato aaaammdd
							luSAI = "TO_DATE('"+DTOS(tdENTRA)+"','YYYYMMDD')"
						ELSE
							*datahora entre aspas no formato aaaammdd
							lcHHMMSS = SUBSTR(lcHHMMSS,1,2)+SUBSTR(lcHHMMSS,4,2)+SUBSTR(lcHHMMSS,7,2)
							luSAI = "TO_DATE('"+DTOS(tdENTRA)+lcHHMMSS+"','YYYYMMDDHH24MISS')"
						ENDIF
				ENDCASE
			CASE goCONEXAO.BANCO = 'DBC'
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= "DATETIME()"
					CASE tcMODO = 'STRING'
						luSAI	= "DTOC(DATE())"
					OTHERWISE
						luSAI	= "'"+DTOS(tdENTRA)+"'"
				ENDCASE
			OTHERWISE
				*SQL SERVER
				*onde: convert(formato,conteudo,nro)
				*ex: convert(datetime,'25/08/2003',103)
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= 'GETDATE()'
					CASE tcMODO = 'STRING'
						luSAI	= "convert(varchar,"+tdENTRA+",103)"
					OTHERWISE
						* MARTELANDO A DATA APENAS ACIMA DE 1900 E MENOR QUE 2079
						LOCAL lnANO, lnMES, lnDIA, lnHORA, lnMINUTO, lnSEGUNDO AS Integer
						LOCAL ldDATA AS Date
						lnANO	= YEAR(tdENTRA)
						lnMES	= MONTH(tdENTRA)
						lnDIA	= DAY(tdENTRA)
						IF lnANO < 1900
							lnANO	= YEAR(DATE())
						ENDIF
						IF lnANO > 2079
							lnANO	= YEAR(DATE())
						ENDIF
						IF TYPE('tdENTRA') = 'T'
							lnHORA		= HOUR(tdENTRA)
							lnMINUTO	= MINUTE(tdENTRA)
							lnSEGUNDO	= SEC(tdENTRA)
						ELSE
							STORE 0 TO lnHORA, lnMINUTO, lnSEGUNDO
						ENDIF
						ldDATA	= STRZERO(lnANO,4) + ;
									STRZERO(lnMES,2) + ;
									STRZERO(lnDIA,2) + ' ' + ;
									STRZERO(lnHORA,2) + ':' +;
									STRZERO(lnMINUTO,2) + ':' +;
									STRZERO(lnSEGUNDO,2)
						luSAI	= "convert(datetime,'"+ ldDATA +"',103)"
				ENDCASE
		ENDCASE
	ENDIF
RETURN(luSAI)

PROC ENCERRARFORCADO
********************
* FINALIZA O APLICATIVO QUANDO NÃO HÁ MAIS COMO CONECTAR
	ON SHUTDOWN
	IF TYPE('_SCREEN.oSTATUSBAR')='O'
		_SCREEN.RemoveObject('oSTATUSBAR')
	ENDIF
	CLEAR WINDOWS
	CLOSE DATA
	SET PROCEDURE TO
	CLEAR EVENTS
	SET PATH TO
	CANCEL
RETURN

FUNC XX
*******
*RETORNA STRING PRONTA PARA CONCATENAR C/ COMANDO-SQL
PARAMETERS tnENTRA, tcPICTURE
	IF TYPE('tcPICTURE') <> 'C'
		tcPICTURE	= ''
	ENDIF
	LOCAL lcSAI AS String
	lcSAI = 'NULL'
	IF NOT ISNULL(tnENTRA)
		IF TYPE('tnENTRA')='N'
			IF EMPTY(tcPICTURE)
				DO CASE
					CASE tnENTRA = INT(tnENTRA)
						tcPICTURE	= REPLICATE('9',20)
					CASE tnENTRA = ROUND(tnENTRA,2)
						tcPICTURE	= REPLICATE('9',20) + '.' + REPLICATE('9',2)
					OTHERWISE
						tcPICTURE	= REPLICATE('9',20) + '.' + REPLICATE('9',8)
				ENDCASE
			ENDIF
			lcSAI = TRANSFORM(tnENTRA,tcPICTURE)
			lcSAI = STRTRAN(lcSAI,',','.')
			lcSAI = ALLTRIM(lcSAI)
		ENDIF
		IF TYPE('tnENTRA')='C'
			tnENTRA = STRTRAN(tnENTRA,"'","")
			lcSAI	= ALLTRIM(tnENTRA)
			IF EMPTY(lcSAI)
				lcSAI = " "
			ENDIF
			IF 'LIKE' $ tcPICTURE
				DO CASE
					CASE tcPICTURE = '%LIKE%'
						lcSAI = "%"+ALLTRIM(lcSAI)+"%"
					CASE tcPICTURE = 'LIKE%'
						lcSAI = ALLTRIM(lcSAI)+"%"
					CASE tcPICTURE = '%LIKE'
						lcSAI = "%"+ALLTRIM(lcSAI)
				ENDCASE
			ENDIF
			lcSAI = "'"+lcSAI+"'"
		ENDIF
		IF TYPE('tnENTRA')='D' OR TYPE('tnENTRA')='T'
			lcSAI = D2SQL(tnENTRA)
		ENDIF
		IF TYPE('tnENTRA')='L'
			IF tnENTRA
				lcSAI = '1'
			ELSE
				lcSAI = '0'
			ENDIF
		ENDIF
	ENDIF
RETURN(lcSAI)

FUNC VIRGULAR
*************
PARAMETERS tcVIRGULAR
	IF TYPE('tcVIRGULAR')='N'
		tcVIRGULAR = ALLTRIM(STR(tcVIRGULAR))
	ENDIF
	LOCAL lcVIRGULAR as String
	lcVIRGULAR = ','+tcVIRGULAR+','
RETURN(lcvirgular)

PROC CONECTAR
**************
	LOCAL lcCONTEUDO,lcFILE AS String 
	LOCAL lnALCA AS Integer 
	LOCAL llERRO AS Logical
	STORE .F. TO llERRO
	
	lcFILE = goCONEXAO.FILEWAW

	=SQLSETPROP(0,"DispLogin",3)
	
	TRY 
		lcCONTEUDO = FILETOSTR(lcFILE)
	CATCH
		llERRO = .T.
	ENDTRY
	
	IF llERRO
		DO MENS WITH 'Não foi possível ler arquivo de configuração:' + FULLPATH(lcFILE)
		RETURN(.F.)
	ENDIF
	
    lcCONTEUDO 	= WAW_DECRIPTAR(lcCONTEUDO)
	lcCONTEUDO	= STREXTRACT(lcCONTEUDO,'<DATABASE>','</DATABASE>',1,1)
	
	DO ESPERANDO WITH 'Conectando ao banco de dados...'
    TRY 
	    lnALCA = SQLSTRINGCONNECT(lcCONTEUDO)
    CATCH
    ENDTRY
	WAIT CLEAR
    IF lnALCA < 0
    	MESSAGEBOX('ERRO PARA CONECTAR AO BANCO DE DADOS',0,'ERRO')
    	RETURN(.F.)
    ENDIF
    
    GOCONEXAO.ALCA 		= lnALCA
  	GOCONEXAO.DRIVER	= STREXTRACT(UPPER(lcCONTEUDO), 'DRIVER=', ';')

	DO CASE
		CASE 'ORACLE' $ goCONEXAO.DRIVER
			goCONEXAO.BANCO	= 'ORA'
		CASE 'POSTGRE' $ goCONEXAO.DRIVER
			goCONEXAO.BANCO	= 'POS'
		CASE 'FOXPRO' $ goCONEXAO.DRIVER
			goCONEXAO.BANCO	= 'DBC'
		CASE 'MYSQL' $ goCONEXAO.DRIVER
			goCONEXAO.BANCO	= 'MYS'
		OTHERWISE
			goCONEXAO.BANCO	= 'SQL'
	ENDCASE

RETURN

PROC ROTERRO
************
PARAMETERS tnMYERRO, tcMYMESS, tcMYPROG, tnMYLINH
	=MESSAGEBOX('Ocorreu uma falha para iniciar o seu aplicativo e ele terá que ser encerrado! Anote a mensagem de erro e entre em contato com o suporte técnico do seu software. ERRO: '+;
	ALLTRIM(STR(tnMYERRO)) + '=' + tcMYMESS + ' LINHA ' + ALLTRIM(STR(tnMYLINH)) + ':' + tcMYPROG, 'ERRO',16)
	CANCEL
RETURN

DEFINE CLASS CONECTADB AS Custom 
	BANCO 	= ''
	ALCA 	= -1
	DRIVER 	= ''
	PATHWAW = ''
	FILEWAW = ''
ENDDEFINE

DEFINE CLASS APLICATIVO AS Custom
	TESTE 		= .F.
	WAWATIVO	= 0
	VOLPEPADRAO	= 0
	HOMEPATH	= ''
ENDDEFINE

PROC WAW_DECRIPTAR
******************
	LPARAMETERS tcIN
		LOCAL llERROR AS Boolean
		STORE .F. TO llERROR
		TRY 
			tcIN 	= goZIP.DECRYPT(tcIN,"CONFIG0105SÃO'")
			llERROR	= .F.
		CATCH
			llERROR	= .T.
		ENDTRY
		
		* Tratamento de erro
		IF llERROR
			tcIN	= ''
		ENDIF
	RETURN tcIN
ENDPROC

FUNC DATASERVER
***************
* PEGA DATA/HORA DO SERVIDOR
	LOCAL lcALIANT, lcCOMANDO AS String
	LOCAL lcDATAOUT AS Datetime
	STORE '' TO lcALIANT, lcCOMANDO

	lcALIANT	= ALIAS()
	lcCOMANDO	= 'SELECT SYSDATE FROM DUAL'

	DO CASE
		CASE goCONEXAO.BANCO = 'MYS' &&&  LINHA ALTERADA  &&&
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					NOW() AS SYSDATE
			ENDTEXT

		CASE goCONEXAO.BANCO = 'POS'
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					NOW() AS SYSDATE
			ENDTEXT

		CASE goCONEXAO.BANCO = 'ORA'
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					SYSDATE
				FROM
					DUAL
			ENDTEXT

		OTHERWISE
			* MSSQL
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					GETDATE() AS SYSDATE
			ENDTEXT

	ENDCASE

	=PESQUISASQL(lcCOMANDO,'TMPDATSIS')
	lcDATAOUT	= TMPDATSIS.SYSDATE
	USE IN TMPDATSIS

	IF NOT EMPTY(lCALIANT)
		SELE &lcALIANT
	ENDIF

RETURN(lcDATAOUT)