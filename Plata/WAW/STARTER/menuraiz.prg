* MENURAIZ.PRG - PRG PRINCIPAL DO STARTER DO VOLPE
**************************************************
PARAMETERS tcPARAMEXE, tcP1, tcP2, tcP3, tcP4, tcP5, tcP6, tcP7, tcP8, tcP9
	IF TYPE('tcPARAMEXE')<>'C'
		tcPARAMEXE = ''
	ENDIF
	tcPARAMEXE = 	ALLTRIM(UPPER(tcPARAMEXE))+';'
 	
	_SCREEN.Height = 1
	_SCREEN.Width = 1
	_SCREEN.Top = 100000
	_SCREEN.Visible = .F.
	
	SET RESOURCE OFF
	SET TALK OFF
	SET ESCAPE OFF
	SET EXCL OFF
	SET NOTIFY OFF
	CLOSE ALL
	SQLSETPROP(0,"DispLogin",3)
	
	* TRATAMENTO DE ERROS
	IF '\TESTES' $ CURDIR()
		ON KEY LABEL CTRL+F2 ACTIVATE WINDOW COMMAND
		SET STATUS BAR ON
	ELSE
		SET RESOURCE OFF
		ON ERROR DO ROTERRO WITH ERROR(),MESSAGE(),PROGRAM(),LINENO()
		ON SHUTDOWN QUIT
		SET STATUS BAR OFF
	ENDIF
	
	PUBLIC goAPLICATIVO,gOCONEXAO,goMY AS Object
	PUBLIC goZIP AS ZIPCLASS OF ZIPCLASS.VCX
	
	LOCAL lcFILE,lcCONTEUDO as String
	LOCAL lnQT_ARQUIVOS AS Integer
	LOCAL llERROR,llERRO AS Boolean
	LOCAL ARRAY laARQUIVOS[1]
	
	STORE .F. TO llERROR,llERRO
	STORE 0 TO lnQT_ARQUIVOS

	goCONEXAO	= CREATEOBJECT('CONECTADB')
	goAPLICATIVO= CREATEOBJECT('APLICATIVO')
	goZIP		= NEWOBJECT('ZIPCLASS','ZIPCLASS.VCX')

	* VERIFICA COMANDOS NO PARAMETRO
	IF 'CREATEWAWCONNECTION' $ UPPER(ALLTRIM(tcPARAMEXE)) 
		IF TYPE('tcP1')<>'C'
			tcP1=''
		ENDIF
		* RECEBER CONFIGURAÇÃO DE BD
		IF NOT EMPTY(tcP1)
			goAPLICATIVO.CRIARCONFIGBD	= .T.
			goAPLICATIVO.CONFIGBD 		= tcP1 
		ENDIF
	ENDIF
	
	* VERIFICA PARAMETRO PARA MODO SILENCIOSO (NÃO EXIBE MENSAGENS)
	* ATIVADO TAMBÉM QUANDO ESTAMOS EXE É CHAMADO PARA JOBS
	IF 'NOMESSAGE' $ UPPER(ALLTRIM(tcPARAMEXE)) OR 'JOB=' $ UPPER(ALLTRIM(tcPARAMEXE))
		goAPLICATIVO.MODOSILENCIO = .T.
	ENDIF
	
	* Pasta temp
	IF NOT CRIATEMPDIR()
		RETURN .F.
	ENDIF
	
	* ARQUIVO DE CONFIGURACAO (MENDONÇA)
	IF NOT FINDARQCONFIG()
		DO ENCERRAR
	ENDIF

	DO FORM SPLASH WITH tcPARAMEXE
	
	READ EVENTS
	
	DO ENCERRAR
RETURN

PROC CRIATEMPDIR
****************
* CRIA PASTA SEPARADA DE ARQ.TEMPORARIOS
	LOCAL lcPASTA AS STRING
	lcPASTA = goAPLICATIVO.PATHTEMP
	IF ADIR(laDIR,lcPASTA,'DHS')=0
		TRY
			MD (lcPASTA)
		CATCH
			DO MENS WITH 'Erro de acesso: Falha para gravar/criar em pasta de arquivos temporários.'+CHR(13)+CHR(10)+;
			'Verifique seus priviégios para gravar dados neste computador (sem acesso na pasta de temporários)'+CHR(13)+CHR(10)+;
			lcPASTA
			CLOSE ALL
			CANCEL
		ENDTRY
	ENDIF
RETURN

FUNC TEMPFILE
*************
LPARAMETERS tcEXTENSAO
	IF TYPE('tcEXTENSAO')<>'C'
		tcEXTENSAO = 'TMP'
	ENDIF
	LOCAL lcCPOOUT AS String
	lcCPOOUT = goAPLICATIVO.PATHTEMP+SYS(2015)+'.'+tcEXTENSAO
RETURN(lcCPOOUT)

PROC ROTERRO
************
PARAMETERS tnMYERRO, tcMYMESS, tcMYPROG, tnMYLINH,tcMSGPADRAO
	IF TYPE('tcMSGPADRAO') <> 'C'
		tcMSGPADRAO = ''
	ENDIF
	IF EMPTY(tcMSGPADRAO)
		tcMSGPADRAO	= 'Ocorreu uma falha para iniciar o seu aplicativo e ele terá que ser encerrado! Anote a mensagem de erro e entre em contato com o suporte técnico do seu software.'
	ENDIF
	
	LOCAL lcMENSAGEM AS String 
	TEXT TO lcMENSAGEM NOSHOW PRETEXT 2
		[[MSGPADRAO]]
		
	ERRO:		[[MYERRO]]
	MENSAGEM:	[[MYMESS]]
	LINHA:		[[MYLINE]]
	ENDTEXT
	* 	ROTINA:		[[MYPROGRAM]]
	
	lcMENSAGEM 	= STRTRAN(lcMENSAGEM,'[[MSGPADRAO]]',tcMSGPADRAO)
	lcMENSAGEM 	= STRTRAN(lcMENSAGEM,'[[MYERRO]]',ALLTRIM(STR(tnMYERRO)))
	lcMENSAGEM 	= STRTRAN(lcMENSAGEM,'[[MYMESS]]',tcMYMESS)
	lcMENSAGEM 	= STRTRAN(lcMENSAGEM,'[[MYPROGRAM]]',tcMYPROG)
	lcMENSAGEM 	= STRTRAN(lcMENSAGEM,'[[MYLINE]]',ALLTRIM(STR(tnMYLINH)))
	
	=MESSAGEBOX(lcMENSAGEM, 'Volpe - Erro',16)
	
	RETURN TO MASTER
	CANCEL
RETURN

PROC STARTAFILE
***************
LPARAMETERS tcARQUIVO AS String, tcPARAMETROS AS STRING
	IF TYPE('tcARQUIVO') <> 'C'
		tcARQUIVO = ''	
	ENDIF
	IF EMPTY(tcARQUIVO)
		RETURN
	ENDIF
	IF NOT FILE(tcARQUIVO)
		MESSAGEBOX( 'EXECUTAVEL NÃO ENCONTRADO: '+tcARQUIVO, 0, 'AVISO')
		RETURN
	ENDIF
	
	DECLARE LONG ShellExecute IN "shell32.dll" ;
		LONG HWND, STRING lpszOp, ;
		STRING lpszFile, STRING lpszParams, ;
		STRING lpszDir, LONG nShowCmd

	SHELLEXECUTE( 0, 'Open', FULLPATH(tcARQUIVO), tcPARAMETROS, 0, 1)
RETURN

PROC CONECTAR
*************
	LOCAL lcCONTEUDO,lcFILE AS String 
	LOCAL lnALCA AS Integer 
	
	lnALCA		= SQLSTRINGCONNECT(goCONEXAO.CONNECTIONSTRING)

	* Limpando string de conexão por motivo de segurança
	goCONEXAO.CONNECTIONSTRING	= ''
	
    IF lnALCA < 0
    	DO MENS WITH 'Erro ao conectar ao banco de dados.' + CHR(13)+CHR(10) + MESSAGE()
    	RETURN(.F.)
    ENDIF
    
    GOCONEXAO.ALCA = lnALCA
    
	RETURN
ENDPROC

PROC ENCERRAR
*************
LPARAMETERS tnPERGUNTAR
* PERGUNTAR SE FINALIZA OU NÃO
	IF TYPE('tnPERGUNTAR')<>'N'
		tnPERGUNTAR=0
	ENDIF

	IF tnPERGUNTAR= 1
		LOCAL lnRESP AS LOGICAL
		lnRESP = SIMOUNAO('Deseja encerrar o aplicativo?','Sair',1)
		IF NOT lnRESP
			RETURN
		ENDIF
	ENDIF
	
	ON SHUTDOWN
	IF TYPE('goCONEXAO')='O'
		* MATA CONEXÃO
		TRY 
			goCONEXAO.DESCONECTAR()
		CATCH
			CANCEL
		ENDTRY
	ENDIF
	CLEAR WINDOWS
	CLOSE DATA
	SET PROCEDURE TO
	CLEAR EVENTS
*	CLEAR PROGRAM
	IF TYPE('goAPLICATIVO')='O'
		IF goAPLICATIVO.TESTE = .T.
			SET SYSMENU TO DEFA
			IF tnPERGUNTAR<>0
				TRY 
					CLEAR ALL
				CATCH
				ENDTRY
			ENDIF
		ENDIF
	ENDIF
	SET PATH TO
	CANCEL
	
	RETURN
ENDPROC


FUNC PESQUISASQL
****************
PARAMETERS tcSINTAXE, tcARQUIVO
	IF USED(tcARQUIVO)
		USE IN &tcARQUIVO
	ENDIF
	LOCAL lnQTDDATAS, lnXI, lnOCO AS Integer
	LOCAL lcAUX, lcLETRA, lcTAG1, lcTAG2 AS String
	STORE 0 TO lnQTDDATAS, lnXI, lnOCO
	STORE '' TO lcAUX, lcLETRA, lcTAG1, lcTAG2

	lnOCO = AT(CHR(9),tcSINTAXE)
	IF lnOCO > 0
		DO MENS WITH '<TAB> no meio da sintaxe SQL'+CHR(13)+;
					SUBSTR(tcSINTAXE,MAX(1,lnOCO-15),30)
	ENDIF

	* TRATAMENTO DE CAMPOS DATETIME
	IF 'TO_CHART(' $ tcSINTAXE
		lcTAG1 = 'TO_CHART('
		lcTAG2 = ')TO_CHART'
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS'
				lcNEW1 = "DATE_FORMAT("
				lcNEW2 = ",'%D/%m/%Y %H:%I:%S')"
			CASE goCONEXAO.BANCO = 'POS'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY HH24:MI:SS')"
			CASE goCONEXAO.BANCO = 'ORA'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY HH24:MI:SS')"
			CASE goCONEXAO.BANCO = 'DBC'
				lcNEW1 = 'TTOC('
				lcNEW2 = ")"
			OTHERWISE
				lcNEW1 = 'CONVERT(VARCHAR(19),'
				lcNEW2 = ',120)'
		ENDCASE
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG1, lcNEW1 )
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG2, lcNEW2 )
	ENDIF

	* TRATAMENTO DE CAMPOS DATA
	IF 'TO_CHAR(' $ tcSINTAXE
		lcTAG1 = 'TO_CHAR('
		lcTAG2 = ')TO_CHAR'
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS'
				lcNEW1 = 'DATE_FORMAT('
				lcNEW2 = ",'%D/%m/%Y')"
			CASE goCONEXAO.BANCO = 'POS'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY')"
			CASE goCONEXAO.BANCO = 'ORA'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY')"
			CASE goCONEXAO.BANCO = 'DBC'
				lcNEW1 = 'DTOC('
				lcNEW2 = ")"
			OTHERWISE
				lcNEW1 = 'CONVERT(VARCHAR(10),'
				lcNEW2 = ',103)'
		ENDCASE
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG1, lcNEW1 )
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG2, lcNEW2 )
	ENDIF

	* CAMPOS DIA DA SEMANA
	IF 'FNOMDIA(' $ tcSINTAXE
		STORE '' TO lcNEW1, lcNEW2
		lcTAG1 = 'FNOMDIA('
		lcTAG2 = ')FNOMDIA'
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS'
				**
			CASE goCONEXAO.BANCO = 'POS'
				**
			CASE goCONEXAO.BANCO = 'ORA'
				**
			CASE goCONEXAO.BANCO = 'DBC'
				**
			OTHERWISE
				lcNEW1 = "SUBSTR('DomingoSegundaTerça  Quarta Quinta Sexta  Sábado ',(DATEPART(dw,"
				lcNEW2 = ')-1)*7+1,7)'
		ENDCASE
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG1, lcNEW1 )
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG2, lcNEW2 )
	ENDIF

	* TRATAMENTO DE CAMPOS NULOS
	IF 'ISNULL(' $ tcSINTAXE
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS' &&&  LINHA ALTERADA  &&&
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','COALESCE(')
			CASE goCONEXAO.BANCO = 'POS'
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','COALESCE(')
			CASE goCONEXAO.BANCO = 'ORA'
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','NVL(')
			CASE goCONEXAO.BANCO = 'DBC'
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','NVL(')
			OTHERWISE
				* NÃO PRECISA FAZER (PADRÃO MS-SQL SERVER)
		ENDCASE
	ENDIF

	* TRATAMENTOS ESPECIAIS DE SINTAXE
	DO CASE
		CASE goCONEXAO.BANCO = 'DBC'
			tcSINTAXE = TRATASQLFOX(tcSINTAXE)
		CASE goCONEXAO.BANCO = 'POS'
			tcSINTAXE = TRTSINPGSQL(tcSINTAXE)
			tcSINTAXE = TRTFUNPGSQL(tcSINTAXE)
		CASE goCONEXAO.BANCO = 'ORA'
			tcSINTAXE = TRATASQLORACLE(tcSINTAXE)
		CASE goCONEXAO.BANCO = 'MYS'
			tcSINTAXE = TRATAMYSQL(tcSINTAXE)
		OTHERWISE
			tcSINTAXE = TRATASQLMSSQL(tcSINTAXE)
	ENDCASE

	DO CASE
		CASE goCONEXAO.BANCO = 'DBC'
			* BANCO DE DADOS NATIVO DO FOX, NÃO UTILIZA DRIVER ODBC. TODAS AS PESQUISAS FUNCIONAM COM COMANDOS NATIVOS.
			tcSINTAXE	= STRTRAN( tcSINTAXE, CHR(13)+CHR(10), ' ' )
			tcSINTAXE	= STRTRAN( tcSINTAXE, CHR(09), '' )
	ENDCASE

	* EXECUTA COMANDO NA BASE
	gnSQLOK = SQLEXEC(goCONEXAO.ALCA,tcSINTAXE,tcARQUIVO)
        
	IF gnSQLOK<0
*!*			=AERROR(laERRO)

*!*			lcNUMERRO	= ALLTRIM(STR(laERRO(1)))
*!*			lcERRO		= laERRO(3)

*!*			lnRESP	= MESSAGEBOX('ERRO NO ACESSO À BASE DE DADOS: ' + CHR(13)+CHR(10)+;
*!*									SYS(16)+CHR(13)+CHR(10)+;
*!*									lcNUMERRO+CHR(13)+CHR(10)+;
*!*									lcERRO,'AVISO: SQL-ERRO',48+2+256)
*!*			IF lnRESP = 3
*!*				_CLIPTEXT	= tcSINTAXE
*!*				DEBUG
*!*				SUSP
*!*			ENDIF
*!*			IF lnRESP = 4
*!*				_CLIPTEXT = tcSINTAXE
*!*			ENDIF
	ELSE
		* TRATAMENTO DE ARREDONDAMENTO DAS CASAS DECIMAIS SOMENTE NO ORACLE
		** DEVIDO A BUG DO DRIVER {MICROSOFT ODBC PARA ORACLE} AO EFETUAR FUNÇÕES COMO SUM, MAX, MIN E ETC...
		LOCAL ARRAY laCAMPOS[1]
		
		LOCAL lnXI AS Integer
		STORE 0 TO lnXI
		
		LOCAL lcMACRO, lcFIELDS AS String
		STORE '' TO lcMACRO, lcFIELDS

		LOCAL llOK AS Logical
		STORE .F. TO llOK

		IF 'ORACLE' $ UPPER(goCONEXAO.DRIVER)
			=AFIELDS(laCAMPOS,tcARQUIVO)
			FOR lnXI = 1 TO ALEN(laCAMPOS,1)
				IF 'VL_' $ UPPER(laCAMPOS[lnXI,1]) AND laCAMPOS[lnXI,2] = 'N' AND laCAMPOS[lnXI,3] = 20 AND laCAMPOS[lnXI,4] = 0
					lcFIELDS = lcFIELDS + ',CAST(' + laCAMPOS[lnXI,1] + ' AS N(20,2)) AS ' + laCAMPOS[lnXI,1]
					llOK = .T.
				ELSE
					lcFIELDS = lcFIELDS + ',' + laCAMPOS[lnXI,1]
				ENDIF
			ENDFOR
			IF llOK
				lcFIELDS = SUBSTR(lcFIELDS,2)
				lcMACRO = 'SELECT ' + lcFIELDS + ' FROM ' + tcARQUIVO + ' INTO CURSOR ' + tcARQUIVO + ' READWRITE'
				&lcMACRO
			ENDIF
		ENDIF
	ENDIF
RETURN

FUNC TRATASQLFOX
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	IF ' CASE WHEN ' $ lcCPOOUT
		lcCPOOUT = STRTRAN( lcCPOOUT, ' CASE WHEN '	, ' IIF( '	)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' THEN '			, ' , '		)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' ELSE '			, ' , '		)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' END '			, ' ) '		)
	ENDIF
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LPAD(', 'PADL(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'RPAD(', 'PADR(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(')
RETURN(lcCPOOUT)

FUNC TRTSINPGSQL
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(')
	lcCPOOUT = STRTRAN( lcCPOOUT, "\'", "\.'" )
RETURN(lcCPOOUT)

FUNC TRTFUNPGSQL
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = REMOVERTOPSQL(lcCPOOUT,'LIMIT')
	lcCPOOUT = STRTRAN( lcCPOOUT, ' SPACE( ', ' LPAD(" ",')
RETURN(lcCPOOUT)

FUNC TRATASQLORACLE
*******************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT, lcP1, lcP2 AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT	= tcCPOIN
	lcCPOOUT	= STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(' )
	lcCPOOUT	= STRTRAN( lcCPOOUT, ' SPACE( ', ' LPAD(" ",' )
	* TRATANDO POR PARTES
	IF 'FROM' $ lcCPOOUT
		lcP1 = STREXTRACT(lcCPOOUT,'','FROM',1,4)
		lcP2 = STREXTRACT(lcCPOOUT,'FROM','',1,0)
		lcP2 = STRTRAN( lcP2, ' AS ', ' ')
		lcP1 = REMOVERTOPSQL(lcP1,'ROWNUM')
		lcCPOOUT = lcP1+lcP2
	ENDIF
	IF 'DATE_PART(' $ lcCPOOUT
		LOCAL lcAUX, lcCONTEUDO AS String
		LOCAL lnXI AS Integer
		FOR lnXI = 1 TO OCCURS('DATE_PART(',lcCPOOUT)
			lcCONTEUDO = STREXTRACT(lcCPOOUT,'DATE_PART(',')',lnXI)
			IF EMPTY(lcCONTEUDO)
				LOOP
			ENDIF
			DO CASE
				CASE 'DAY' $ lcCONTEUDO
					lcAUX = STREXTRACT( lcCONTEUDO, ',' , '' ) + ", 'DD'" 
					lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
				CASE 'MONTH' $ lcCONTEUDO
					lcAUX = STREXTRACT( lcCONTEUDO, ',' , '' ) + ", 'MM'"
					lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
				CASE 'YEAR' $ lcCONTEUDO
					lcAUX = STREXTRACT( lcCONTEUDO, ',' , '' ) + ", 'YYYY'"
					lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
				OTHERWISE
					LOOP
			ENDCASE										
		ENDFOR
		lcCPOOUT= STRTRAN(lcCPOOUT,'DATE_PART(','TO_CHAR(')
	ENDIF
RETURN(lcCPOOUT)

FUNC TRATAMYSQL
***************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT, lcP1, lcP2 AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT	= tcCPOIN
	lcCPOOUT 	= REMOVERTOPSQL(lcCPOOUT,'LIMIT')
RETURN(lcCPOOUT)

FUNC TRATASQLMSSQL
******************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT, lcCONTEUDO, lcSUBSTITUI, lcAUX AS String
	LOCAL lnXI, lnOCO AS Integer
	STORE '' TO lcCPOOUT, lcCONTEUDO, lcSUBSTITUI, lcAUX
	STORE 0 TO lnXI, lnOCO
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = STRTRAN( lcCPOOUT, '||' , '+' )
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTR(', 'SUBSTRING(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LENGTH(', 'LEN(')
	IF 'LPAD(' $ lcCPOOUT
		FOR lnXI = 1 TO 100
			lcCONTEUDO	= STREXTRACT(lcCPOOUT,'LPAD(',')')
			IF EMPTY(lcCONTEUDO)
				EXIT
			ENDIF
			lnOCO		= RAT( ',' , lcCONTEUDO )
			lcSUBSTITUI	= 'CAST( ' + ;
							LEFT( lcCONTEUDO,lnOCO-1 ) + ;
							' AS CHAR(' + ;
							RIGHT( lcCONTEUDO,lnOCO-2 ) + '))'
			lcCPOOUT	= STRTRAN( lcCPOOUT, 'LPAD(' + lcCONTEUDO + ')', lcSUBSTITUI )
		ENDFOR
	ENDIF
	IF 'RPAD(' $ lcCPOOUT
		FOR lnXI = 1 TO 100
			lcCONTEUDO	= STREXTRACT(lcCPOOUT,'RPAD(',')')
			IF EMPTY(lcCONTEUDO)
				EXIT
			ENDIF
			lnOCO		= RAT( ',' , lcCONTEUDO )
			lcSUBSTITUI	= 'CAST( ' + ;
							LEFT( lcCONTEUDO,lnOCO-1 ) + ;
							' AS ' + ;
							RIGHT( lcCONTEUDO,lnOCO-2 ) + ')'
			lcCPOOUT	= STRTRAN( lcCPOOUT, 'LPAD('+lcCONTEUDO+')', lcSUBSTITUI )
		ENDFOR
	ENDIF
	IF 'DATE_PART(' $ lcCPOOUT
		FOR lnXI = 1 TO 100
			lcCONTEUDO	= STREXTRACT(lcCPOOUT,'DATE_PART(',')')
			IF EMPTY(lcCONTEUDO)
				EXIT
			ENDIF
			lcAUX		= UPPER(STREXTRACT(lcCONTEUDO, "'", "'," ))
			IF NOT lcAUX $ 'DAY,MONTH,YEAR'
				LOOP
			ENDIF
			lcSUBSTITUI	= UPPER(lcAUX) + '(' + ;
							UPPER(STREXTRACT(lcCONTEUDO, "',")) + ')'
			lcCPOOUT	= STRTRAN( lcCPOOUT, 'DATE_PART('+lcCONTEUDO+')', lcSUBSTITUI )
		ENDFOR
	ENDIF
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LENGTH(', 'LEN(')
RETURN(lcCPOOUT)

FUNC REMOVERTOPSQL
******************
LPARAMETERS tcSQL, tcOUTROS
	LOCAL lcOUT AS String
	lcOUT = tcSQL
	IF ' TOP ' $ lcOUT
		LOCAL lcAUX, lcLETRA AS String
		LOCAL lnOCO AS Integer
		lcAUX	= ''
		lnOCO	= AT(' TOP ',lcOUT)
		FOR lnXI = lnOCO+5 TO LEN(lcOUT)
			lcLETRA = SUBSTR(lcOUT,lnXI,1)
			IF EMPTY(lcLETRA)
				EXIT
			ENDIF
			lcAUX = lcAUX + lcLETRA
		ENDFOR
		lcOUT	= STRTRAN(lcOUT,' TOP '+lcAUX,'')
		IF 'LIMIT' $ tcOUTROS
			lcOUT	= lcOUT + ' LIMIT '+lcAUX
		ENDIF
	ENDIF
RETURN(lcOUT)

PROC MENS
*********
LPARAMETERS tcMENSAGEM,tnERRO
* MENSAGEM AO USUARIO, SE TNERRO=1 A MENSAGEM É MAIS GRAVE.
	IF goAPLICATIVO.MODOSILENCIO = .T.
		RETURN
	ENDIF
	IF TYPE('tnERRO')<>'N'
		tnERRO = 0
	ENDIF
	tnERRO = IIF(tnERRO>0,48,64)
	=MESSAGEBOX(tcMENSAGEM,'AVISO',tnERRO)
RETURN

PROC SIMOUNAO
*************
LPARAMETERS tcPERGUNTA, tcTITULO, tnDEFAULT
	LOCAL lnBOTAO AS Number
	IF VARTYPE(tnDEFAULT) <> 'N'
		tnDEFAULT = 0
	ENDIF
	IF tnDEFAULT = 1
		tnBOTAO = 0
	ELSE
		tnBOTAO = 256
	ENDIF
	IF MESSAGEBOX( tcPERGUNTA, tcTITULO, 32+4+tnBOTAO )=6
		RETURN(.T.)
	ENDIF
RETURN(.F.)

PROC WAW_DECRIPTAR
******************
	LPARAMETERS tcIN
		LOCAL llERROR AS Boolean
		STORE .F. TO llERROR
		TRY 
			tcIN 	= goZIP.DECRYPT(tcIN,"CONFIG0105SÃO'")
			llERROR	= .F.
		CATCH
			llERROR	= .T.
		ENDTRY
		
		* Tratamento de erro
		IF llERROR
			tcIN	= ''
		ENDIF
	RETURN tcIN
ENDPROC

PROC WAW_CRIPTAR
******************
	LPARAMETERS tcIN
		LOCAL llERROR AS Boolean
		STORE .F. TO llERROR
		TRY 
			tcIN 	= goZIP.ENCRYPT(tcIN,"CONFIG0105SÃO'")
			llERROR	= .F.
		CATCH
			llERROR	= .T.
		ENDTRY
		
		* Tratamento de erro
		IF llERROR
			tcIN	= ''
		ENDIF
	RETURN tcIN
ENDPROC

PROC REMOVERARQUIVO
*******************
LPARAMETERS tcPATH
	IF VARTYPE(tcPATH) <> 'C'
		tcPATH	= ''
	ENDIF
	
	IF EMPTY(tcPATH)
		RETURN .F.
	ENDIF
	
	LOCAL llRETURN AS Boolean
	STORE .F. TO llRETURN
	
	IF FILE(tcPATH)
		TRY 
			DELETE FILE(tcPATH)
			llRETURN	= .T.
		CATCH TO loERR
			llRETURN 	= .F.
		ENDTRY
	ELSE
		llRETURN	= .T.
	ENDIF
	
	RETURN llRETURN
ENDPROC

PROC MDPATH
***********
LPARAMETERS tcPATH, tcGETENV AS String

	IF VARTYPE(tcPATH) <> 'C'
		tcPATH = ''
	ENDIF

	IF EMPTY(tcPATH)
		RETURN(.F.)
	ENDIF

	IF VARTYPE(tcGETENV) <> 'C'
		tcGETENV = ''
	ENDIF

	LOCAL lcPATH, lcORIGINALPATH AS String
	STORE '' TO lcPATH, lcORIGINALPATH

	LOCAL llERRO AS Logical
	STORE .F. TO llERRO

	lcORIGINALPATH = FULLPATH('')

	CD (tcGETENV)

	lcPATH = '\'+ADDBS(tcPATH)
	FOR lnXI = 1 TO OCCURS('\',lcPATH)-1
		lcMDPATH = ADDBS(STREXTRACT(lcPATH,'\','\',lnXI))
		* Não existe diretório então é necessário criar
		IF NOT DIRECTORY(lcMDPATH)
			TRY 
				MKDIR (lcMDPATH)
				CD (lcMDPATH)
			CATCH
				llERRO = .T.
			ENDTRY
		ELSE
		* Diretório existe basta entrar nele
			TRY 
				CD (lcMDPATH)
			CATCH
				llERRO = .T.
			ENDTRY
		ENDIF
		IF llERRO
			CD (lcORIGINALPATH)
			RETURN(.F.)
		ENDIF
	ENDFOR
	
	CD (lcORIGINALPATH)

RETURN(.T.)

* Classe padrão
DEFINE CLASS CONECTADB AS Custom 
	BANCO 				= ''
	ALCA 				= -1
	DRIVER 				= ''
	CONNECTIONSTRING	= ''
ENDDEFINE

DEFINE CLASS APLICATIVO AS Custom
	TESTE 			= .F.
	PATHLOCAL		= ''
	PATHTEMP		= GETENV("TEMP")+'\PWI\'
	NOME			= ''
	WAWATIVO		= 1
	MODOSILENCIO	= .F.
	CRIARCONFIGBD 	= .F.
	CONFIGBD		= ''
ENDDEFINE

PROC FINDARQCONFIG
	* PROCURA O ARQUIVO WAW, CASO NAO ACHAR CHAMA TELA DE CONFIGURACAO
	IF ADIR(laDIR,'*.WAW') > 0
		RETURN(.T.)
	ENDIF
	
	DO FORM 'CONFIGWAW_DIGITAR'

	IF NOT goAPLICATIVO.CRIARCONFIGBD
		READ EVENTS
	ENDIF
	
	
	IF NOT ADIR(laDIR,'*.WAW') > 0
		RETURN(.F.)	
	ENDIF
	
RETURN(.T.)

PROC LERTABLES
**************
LPARAMETERS tcNAME AS STRING
	IF TYPE('tcNAME') <> 'C'
		tcNAME	= ''
	ENDIF

	LOCAL lcCOMANDO AS String
	IF USED('TMPTABLES')
		USE IN TMPTABLES
	ENDIF
	DO CASE
		CASE goCONEXAO.BANCO = 'POS'
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT 
					TABLENAME AS DS_TABLENAME
				FROM 
					pg_tables
				WHERE
					UPPER(TABLENAME) LIKE '[[TABLENAME]]'
				ORDER BY
					DS_TABLENAME
			ENDTEXT			

		CASE goCONEXAO.BANCO = 'ORA'
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT 
					TABLE_NAME AS DS_TABLENAME
				FROM
					USER_TABLES
				WHERE
					UPPER (TABLE_NAME) LIKE '[[TABLENAME]]'
				ORDER BY
					DS_TABLENAME
			ENDTEXT						

		CASE 'SQL SERVER' $ UPPER(goCONEXAO.DRIVER)
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					UPPER(NAME) AS DS_TABLENAME
				FROM
					SYSOBJECTS
				WHERE
					TYPE = 'U'
					AND NAME LIKE '[[TABLENAME]]'
				ORDER BY
					DS_TABLENAME
			ENDTEXT

		CASE goCONEXAO.BANCO = 'MYS'
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					TABLE_NAME AS DS_TABLENAME
				FROM
					VW_TS_TABLES
				WHERE
				 	TABLE_NAME LIKE '[[TABLENAME]]'
				 ORDER BY
				 	TABLE_NAME 
			ENDTEXT

		OTHERWISE
			* NÃO TRAZ NADA, APENAS MONTA CURSOR VAZIO PARA MANTER COMPATIBILIDADE
			CREATE CURSOR TMPTABLES (DS_TABLENAME C(50))
	ENDCASE
	lcCOMANDO = STRTRAN(lcCOMANDO,'[[TABLENAME]]',UPPER(ALLTRIM(tcNAME)))
	=PESQUISASQL(lcCOMANDO,'TMPTABLES')
RETURN

FUNC SBDVAI
***********
* ENCRIPTA SENHA DE BANCO DE DADOS
PARAMETERS tcSENHA
	tcSENHA = ALLTRIM(tcSENHA)
	LOCAL lcHIDEN, lcSEMENTE, lcLETRA AS String
	lcHIDEN = ''
	LOCAL X, Y AS INTEGER
	X = INT(RAND()*25)
	Y = MOD(ASC(tcSENHA+' '),10)
	lcSEMENTE = CHR(X+65)
	lcHIDEN = STR(Y,1)+lcSEMENTE
	FOR X = LEN(tcSENHA) TO 1 STEP -1
		lcLETRA = SUBSTR(tcSENHA,X,1)
		Y = ASC(lcLETRA)+ASC(lcSEMENTE)
		lcLETRA = PADL( ALLTRIM(STR(Y)) ,3,'0')
		lcHIDEN = lcHIDEN + lcLETRA
	ENDFOR
RETURN(lcHIDEN)

PROC SEMASPAS
***************
LPARAMETERS tcSTRING

	IF TYPE('tcSTRING') <> 'C'
		tcSTRING = ''
	ENDIF
	
	IF EMPTY(tcSTRING)
		RETURN(' ')
	ENDIF
	
	tcSTRING = ALLTRIM(STRTRAN(tcSTRING,"'",''))
	
	RETURN tcSTRING
ENDPROC
