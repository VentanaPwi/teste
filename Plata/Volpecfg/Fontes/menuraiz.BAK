 MENURAIZ.PRG - Programa de configuração do Volpe
**************************************************
PARAMETERS tcPARAMEXE, tcP1, tcP2, tcP3, tcP4, tcP5, tcP6, tcP7, tcP8, tcP9
	IF TYPE('tcPARAMEXE')<>'C'
		tcPARAMEXE = ''
	ENDIF
	tcPARAMEXE = ALLTRIM(UPPER(tcPARAMEXE))+';'

	SET TALK OFF
	SET ESCAPE OFF
	SET EXCL OFF
	CLOSE ALL
	SET RESOURCE OFF
	SET STATUS BAR OFF
	SET RESOURCE OFF
	SQLSETPROP(0,"DispLogin",3)
	
	* Preparando layout do programa
	_SCREEN.MaxButton 	= .F.
	_SCREEN.AutoCenter 	= .T.
	_SCREEN.WindowState = 2
	_SCREEN.Caption 	= 'VolpeCFG'
	_SCREEN.Icon		= 'VolpeCFG.Ico'
	
	* TRATAMENTO DE ERROS
	IF _VFP.StartMode <> 4
		ON KEY LABEL CTRL+F2 ACTIVATE WINDOW COMMAND
	ELSE
		SET RESOURCE OFF
		ON ERROR DO ROTERRO WITH ERROR(),MESSAGE(),PROGRAM(),LINENO()
	ENDIF
	ON SHUTDOWN DO ENCERRAR WITH 1
	
	PUBLIC goAPLICATIVO,goCONEXAO1,goCONEXAO2 as Custom
	PUBLIC goZIP AS ZIPCLASS OF ZIPCLASS.VCX
	

	goAPLICATIVO= NEWOBJECT('APLICATIVO')
	
	* Pasta padrão	
	SET PATH TO (JUSTPATH(goAPLICATIVO.ClassLibrary)) ADDITIVE
	SET PATH TO (CURDIR()) ADDITIVE
	
	goCONEXAO1	= NEWOBJECT('CONECTADB')
	goCONEXAO2	= NEWOBJECT('CONECTADB')
	goZIP		= NEWOBJECT('ZIPCLASS','ZIPCLASS.VCX')
	
	
	LOCAL llERROR AS Boolean
	STORE .F. TO llERROR
	
	* Menu do programa
	DO MENUTOPO.MPX
	
	* Pasta temp
	IF NOT CRIATEMPDIR()
		RETURN .F.
	ENDIF
	
	*VERIFICANDO SE ESTA EM AMBIENTE DE TESTE
	IF NOT 'TESTESVF' $ ALLTRIM(UPPER(FULLPATH('')))
		lcSENHA = INPUTBOX('Digite a senha de acesso:','ACESSO RESTRITO')
		IF VARTYPE(lcSENHA) <> 'C'
			lcSENHA = ''
		ENDIF
		lcSENHA = ALLTRIM(UPPER(lcSENHA))
		IF NOT lcSENHA == 'SPYPRETO'
			DO MENS WITH 'ACESSO NEGADO.'
			DO ENCERRAR
		ENDIF		
	ENDIF
	*Verifica se tem arquivo na pasta corrente pra pré-carregar
	CREATE CURSOR TMPARQ(DS_ARQUIVO C(50))
	lnARQPWI = ADIR(laARQSPWI,FORCEPATH('*.PWI',ALLTRIM(FULLPATH(''))))
	lnARQWAW = ADIR(laARQSWAW,FORCEPATH('*.WAW',ALLTRIM(FULLPATH(''))))
	FOR LNI = 1 TO lnARQPWI
		SELE TMPARQ
		SCATTER NAME loREG BLANK
			loREG.DS_ARQUIVO = laARQSPWI[lni,1]
			IF 'SISTEMA.PWI' $ loREG.DS_ARQUIVO
				LOOP
			ENDIF
			APPEND BLANK
		GATHER NAME loREG
	ENDFOR
	FOR LNI = 1 TO lnARQWAW
		SELE TMPARQ
		SCATTER NAME loREG BLANK
			loREG.DS_ARQUIVO = laARQSWAW[lni,1]
			APPEND BLANK
		GATHER NAME loREG
	ENDFOR
	lnARQ = RECCOUNT('TMPARQ')
	
	DO CASE
		CASE lnARQ > 1
			DO FORM SYSTEM_ESCOLHERARQUIVOS TO lcPATHARQ
		CASE lnARQ =1
			lcPATHARQ= ALLTRIM(TMPARQ.DS_ARQUIVO)
		OTHERWISE
			lcPATHARQ=''
	ENDCASE
	IF FILE(lcPATHARQ)
			goCONEXAOWAW= NEWOBJECT('CONECTADB')
			lcEXTENSAO	= JUSTEXT(lcPATHARQ)
			DO CASE
				
				CASE lcEXTENSAO	= 'WAW'		&& WaaW
				
					TRY 
						lcCONTEUDOARQ 	= FILETOSTR(lcPATHARQ)
						llERROR			= .F.
					CATCH
						llERROR			= .T.
					ENDTRY
					IF llERROR
						DO MENS WITH 'Erro ao abrir arquivo de configuração.' + CHR(13)+CHR(10) + 'Path:' + lcPATHARQ
						RETURN .F.
					ENDIF
					
					* Decrypt
					lcCONTEUDOARQ	= WAW_DECRIPTAR(lcCONTEUDOARQ)
					
					* Validando o arquivo
					IF EMPTY(STREXTRACT(lcCONTEUDOARQ,'<NAME>','</NAME>'))
						DO MENS WITH 'Arquivo de configuração inválido.' + CHR(13)+CHR(10) + 'Path:' + lcPATHARQ
						RETURN .F.
					ENDIF

					* Configurando a conexão WAW
					WITH GOCONEXAOWAW
						.NOMECONEXAO		= STREXTRACT(lcCONTEUDOARQ	,'<NAME>'		,'</NAME>')
						.DRIVER				= STREXTRACT(lcCONTEUDOARQ 	,'DRIVER='		,';')
						.SERVIDOR			= STREXTRACT(lcCONTEUDOARQ 	,'SERVER='		,';')
						.BANCO				= STREXTRACT(lcCONTEUDOARQ 	,'DATABASE='	,'<')
						.USUARIO			= STREXTRACT(lcCONTEUDOARQ 	,'UID='			,';')
						.SENHA				= STREXTRACT(lcCONTEUDOARQ 	,'PWD='			,';')
						.CONNECTIONSTRING	= STREXTRACT(lcCONTEUDOARQ 	,'<DATABASE>'	,'</DATABASE>')
						.TIPOCONEXAO		= 2
						.PATHARQCONFIG		= FULLPATH(lcPATHARQ)
						.WAAWSTRINGARQ		= lcCONTEUDOARQ
					ENDWITH
					IF NOT goCONEXAOWAW.CONECTAR()
						DO MENS WITH 'Erro ao conectar banco de arquivos do WAAW.'
					ELSE
						=PESQUISASQL('SELECT TOP 1 * FROM WAW_CONEXAO ORDER BY PK_ID','TMPCONWAW',goCONEXAOWAW)
						goCONEXAOWAW.DESCONECTAR()
						SELE TMPCONWAW
						GO TOP
						IF RECCOUNT('TMPCONWAW') > 0
							*Pré-selecionando a primeira conexão da tabela WAW_CONEXAO
							WITH goCONEXAO1
								.ID						= TMPCONWAW.PK_ID
								.NOMECONEXAO			= ALLTRIM(TMPCONWAW.DS_NOME)
								.DRIVER					= ALLTRIM(TMPCONWAW.DS_DRIVER)
								.SERVIDOR				= ALLTRIM(TMPCONWAW.DS_SERVER)
								.BANCO					= ALLTRIM(TMPCONWAW.DS_DBNAME)
								.USUARIO				= ALLTRIM(TMPCONWAW.DS_USER)
								.SENHA					= ALLTRIM(SBDVEM(TMPCONWAW.DS_PWD))
								.PARAMETROSADICIONAIS	= ALLTRIM(TMPCONWAW.DS_OUTROS)
								.CONNECTIONSTRING		= STREXTRACT(lcCONTEUDOARQ 	,'<DATABASE>'	,'</DATABASE>')
								.WAAWSTRINGARQ			= lcCONTEUDOARQ
								.TIPOCONEXAO			= 2
								.PATHARQCONFIG			= FULLPATH(lcPATHARQ)
							ENDWITH	
						ENDIF	
					ENDIF
					
				
				CASE lcEXTENSAO	= 'PWI'		&& Standard
					* Tenta abrir o arqruivo
					TRY 
						USE (lcPATHARQ) ALIAS 'DBFCONFIG' IN 0
						llERROR	= .F.
					CATCH
						llERROR	= .T.
					ENDTRY
					IF llERROR
						DO MENS WITH 'Arquivo de configuração inválido.'+CHR(13)+CHR(10)+'Path: ' + lcPATHARQ
					ENDIF
					
					IF TYPE('DBFCONFIG.NOME') <> 'C'
						DO MENS WITH 'Arquivo de configuração inválido.'
						RETURN .F.
					ENDIF
					
					SELE DBFCONFIG
					GO TOP
					IF RECCOUNT('DBFCONFIG') > 0
						*Pré-selecionando a primeira conexão do arquivo de configuração
						WITH goCONEXAO1
							.ID						= 1
							.NOMECONEXAO			= ALLTRIM(DBFCONFIG.NOME)
							.DRIVER					= ALLTRIM(DBFCONFIG.DRIVER)
							.SERVIDOR				= ALLTRIM(DBFCONFIG.SERVER)
							.BANCO					= ALLTRIM(DBFCONFIG.DBNAME)
							.USUARIO				= ALLTRIM(DBFCONFIG.USER)
							.SENHA					= ALLTRIM(SBDVEM(DBFCONFIG.PWD))
							.PARAMETROSADICIONAIS	= ALLTRIM(DBFCONFIG.OUTROS)
							.CONNECTIONSTRING		= ''
							.TIPOCONEXAO			= 1
							.PATHARQCONFIG			= FULLPATH(lcPATHARQ)
						ENDWITH
					ENDIF
					IF USED('DBFCONFIG')
						USE IN 'DBFCONFIG'
					ENDIF
					
				OTHERWISE
					DO MENS WITH 'Tipo de arquivo inválido.' + CHR(13)+CHR(10) + 'Path: ' + lcPATHARQ
			ENDCASE
	ENDIF
		
	DO FORM PRINCIPAL
	READ EVENTS
	
	DO ENCERRAR
RETURN


PROC AMBIENTAR
**************
	SET TALK OFF
	SET ESCAPE OFF
	SET EXCL OFF
	SET DELE ON
	SET DATE BRITISH
	SET CURSOR ON
	SET NOTIFY OFF
	SET SAFETY OFF
	SET READBORDER ON
	SET DECIMAL TO 8
	SET REPROCESS TO 3 SECONDS
	SET POINT TO ','
	SET SEPA TO '.'
	SET EXACT OFF
	SET NEAR OFF
	SET CONFIRM ON
	SET CLOCK STATUS
	SET CENTURY ON
	SET MEMOWIDTH TO 512
	SET HOURS TO 24
	SET ENGINEBEHAVIOR 80
	SET REPORTBEHAVIOR 90
RETURN


PROC CRIATEMPDIR
****************
* CRIA PASTA SEPARADA DE ARQ.TEMPORARIOS
	LOCAL lcPASTA AS STRING
	lcPASTA = goAPLICATIVO.PATHTEMP
	IF ADIR(laDIR,lcPASTA,'DHS')=0
		TRY
			MD (lcPASTA)
		CATCH
			DO MENS WITH 'Erro de acesso: Falha para gravar/criar em pasta de arquivos temporários.'+CHR(13)+CHR(10)+;
			'Verifique seus priviégios para gravar dados neste computador (sem acesso na pasta de temporários)'+CHR(13)+CHR(10)+;
			lcPASTA
			CLOSE ALL
			CANCEL
		ENDTRY
	ENDIF
RETURN

FUNC TEMPFILE
*************
LPARAMETERS tcEXTENSAO
	IF TYPE('tcEXTENSAO')<>'C'
		tcEXTENSAO = 'TMP'
	ENDIF
	LOCAL lcCPOOUT AS String
	lcCPOOUT = goAPLICATIVO.PATHTEMP+SYS(2015)+'.'+tcEXTENSAO
RETURN(lcCPOOUT)

PROC ROTERRO
************
PARAMETERS tnMYERRO, tcMYMESS, tcMYPROG, tnMYLINH,tcMSGPADRAO
	LOCAL lcNAMEFORM AS String
	STORE '' TO lcNAMEFORM
	
	IF TYPE('tcMSGPADRAO') <> 'C'
		tcMSGPADRAO = ''
	ENDIF
	IF EMPTY(tcMSGPADRAO)
		tcMSGPADRAO	= 'Ocorreu uma falha para iniciar o seu aplicativo e ele terá que ser encerrado! Anote a mensagem de erro e entre em contato com o suporte técnico do seu software.'
	ENDIF
	
	LOCAL lcMENSAGEM AS String 
	TEXT TO lcMENSAGEM NOSHOW PRETEXT 3
		[[MSGPADRAO]]
		
		ERRO:		[[MYERRO]]
		MENSAGEM:	[[MYMESS]]
		LINHA:		[[MYLINE]]
	 	ROTINA:		[[MYPROGRAM]]
	ENDTEXT
	lcMENSAGEM 	= STRTRAN(lcMENSAGEM,'[[MSGPADRAO]]',tcMSGPADRAO)
	lcMENSAGEM 	= STRTRAN(lcMENSAGEM,'[[MYERRO]]',ALLTRIM(STR(tnMYERRO)))
	lcMENSAGEM 	= STRTRAN(lcMENSAGEM,'[[MYMESS]]',tcMYMESS)
	lcMENSAGEM 	= STRTRAN(lcMENSAGEM,'[[MYPROGRAM]]',tcMYPROG)
	lcMENSAGEM 	= STRTRAN(lcMENSAGEM,'[[MYLINE]]',ALLTRIM(STR(tnMYLINH)))
	
	IF NOT goAPLICATIVO.TESTE
		IF TYPE('_SCREEN.ActiveForm') = 'O'
			lcNAMEFORM = SYS(1271,_SCREEN.ActiveForm)
		ENDIF

		* CHAMA FORMULÁRIO DE ERRO
		DO FORM SYSTEM_ERROMENS WITH lcMENSAGEM, ALIAS(), lcNAMEFORM
	ENDIF

	WAIT CLEAR

	* FINALIZAÇÕES FORÇADAS DO APLICATIVO TODO
	IF UPPER(tcMYPROG)=='ENCERRAR'
		CANCEL
	ENDIF
	IF UPPER(tcMYPROG)=='MENURAIZ'
		CANCEL
	ENDIF
	IF TYPE('goCONEXAO1.FK_USUARIO')<>'N' 
		CANCEL
	ENDIF
	* FINALIZAR SOMENTE O MODULO COM ERRO
	IF TYPE('_SCREEN.ACTIVEFORM')='O'
		_SCREEN.ActiveForm.RELEASE()
		RETURN TO MASTER
	ENDIF
RETURN

PROC STARTAFILE
***************
LPARAMETERS tcARQUIVO AS String, tcPARAMETROS AS STRING
	IF TYPE('tcARQUIVO') <> 'C'
		tcARQUIVO = ''	
	ENDIF
	IF EMPTY(tcARQUIVO)
		RETURN
	ENDIF
	IF NOT FILE(tcARQUIVO)
		MESSAGEBOX( 'EXECUTAVEL NÃO ENCONTRADO: '+tcARQUIVO, 0, 'AVISO')
		RETURN
	ENDIF
	
	DECLARE LONG ShellExecute IN "shell32.dll" ;
		LONG HWND, STRING lpszOp, ;
		STRING lpszFile, STRING lpszParams, ;
		STRING lpszDir, LONG nShowCmd

	SHELLEXECUTE( 0, 'Open', FULLPATH(tcARQUIVO), tcPARAMETROS, 0, 1)
RETURN

PROC PROGTRAVADO
****************
LPARAMETERS tcBLOQ
	LOCAL lcTRAVADO1, lcTRAVADO2 AS String, lnALCA AS Integer
	lcTRAVADO1 = 'ACESSO BLOQUEADO TEMPORARIAMENTE!'+CHR(13)+;
				'O SISTEMA ESTÁ EM MANUTENÇÃO TÉCNICA.'+CHR(13)+CHR(13)
	lcTRAVADO2 = 'AGUARDE ATÉ QUE O ACESSO SEJA REESTABELECIDO.'
	TRY
		lcTRAVADO2 = FILETOSTR(tcBLOQ)
	CATCH
	ENDTRY
	=MESSAGEBOX(lcTRAVADO1+lcTRAVADO2,48,'VOLPE')
RETURN

PROC ENCERRAR
*************
LPARAMETERS tnPERGUNTAR
* PERGUNTAR SE FINALIZA OU NÃO
	IF TYPE('tnPERGUNTAR')<>'N'
		tnPERGUNTAR=0
	ENDIF
	IF tnPERGUNTAR= 1
		LOCAL lnRESP AS LOGICAL
		lnRESP = SIMOUNAO('Deseja encerrar o aplicativo?','Sair',1)
		IF NOT lnRESP
			RETURN
		ENDIF
	ENDIF

	ON SHUTDOWN

	IF TYPE('goCONEXAO1.ALCA')='N'
		* MATA CONEXÃO
		TRY 
			goCONEXAO1.DESCONECTAR()
			goCONEXAO1.UNLOAD()
			goCONEXAO1 = null
			RELEASE 'goCONEXAO1'
		CATCH
		ENDTRY
	ENDIF
	IF TYPE('goCONEXAO2.ALCA')='N'
		* MATA CONEXÃO
		TRY 
			goCONEXAO2.DESCONECTAR()
			goCONEXAO2.UNLOAD()
			goCONEXAO2 = NULL
			RELEASE 'goCONEXAO2'
		CATCH
		ENDTRY
	ENDIF
	IF TYPE('goZIP')='O'
		* MATA CONEXÃO
		TRY 
			RELEASE goZIP
		CATCH
		ENDTRY
	ENDIF	
	IF TYPE('goAPLICATIVO')='O'
		* DESLIGA TODOS OS FORMS
		TRY 
			goAPLICATIVO.KILLFORMS()
			goAPLICATIVO.UNLOAD
		CATCH
		ENDTRY
	ENDIF
	SET SYSMENU TO DEFA
	CLEAR WINDOWS
	CLOSE DATA
	SET PROCEDURE TO
	CLEAR EVENTS
	CLEAR PROGRAM
	IF TYPE('goAPLICATIVO')='O'
		IF goAPLICATIVO.TESTE = .T.
			SET SYSMENU TO DEFA
			SET RESOURCE ON
			CLEAR CLASSLIB VOLPECFG
			IF tnPERGUNTAR<>0
				TRY 
					CLEAR ALL
				CATCH
				ENDTRY
			ENDIF
		ENDIF
	ENDIF
	SET PATH TO
	CANCEL
	
	RETURN
ENDPROC

FUNC PESQUISASQL
****************
PARAMETERS tcSINTAXE, tcARQUIVO, toCONEXAO
	LOCAL lnQTDDATAS, lnXI, lnOCO AS Integer
	LOCAL lcAUX, lcLETRA, lcTAG1, lcTAG2 AS String
	STORE 0 TO lnQTDDATAS, lnXI, lnOCO
	STORE '' TO lcAUX, lcLETRA, lcTAG1, lcTAG2
	
	IF USED(tcARQUIVO)
		USE IN &tcARQUIVO
	ENDIF
	
	* Se não passar a conexão deve pegar a conexão padraão ( goCONEXAO1 )
	IF VARTYPE(toCONEXAO) <> 'O'
		toCONEXAO	= goCONEXAO1
	ENDIF

	lnOCO = AT(CHR(9),tcSINTAXE)
	IF lnOCO > 0
		DO MENS WITH '<TAB> no meio da sintaxe SQL'+CHR(13)+;
					SUBSTR(tcSINTAXE,MAX(1,lnOCO-15),30)
	ENDIF

	* TRATAMENTO DE CAMPOS DATETIME
	IF 'TO_CHART(' $ tcSINTAXE
		lcTAG1 = 'TO_CHART('
		lcTAG2 = ')TO_CHART'
		DO CASE
			CASE 'MYSQL' $ UPPER(toCONEXAO.DRIVER)
				lcNEW1 = "DATE_FORMAT("
				lcNEW2 = ",'%D/%m/%Y %H:%I:%S')"
			CASE 'POSTGRES' $ UPPER(toCONEXAO.DRIVER)
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY HH24:MI:SS')"
			CASE 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY HH24:MI:SS')"
			OTHERWISE
				lcNEW1 = 'CONVERT(VARCHAR(19),'
				lcNEW2 = ',120)'
		ENDCASE
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG1, lcNEW1 )
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG2, lcNEW2 )
	ENDIF

	* TRATAMENTO DE CAMPOS DATA
	IF 'TO_CHAR(' $ tcSINTAXE
		lcTAG1 = 'TO_CHAR('
		lcTAG2 = ')TO_CHAR'
		DO CASE
			CASE 'MYSQL' $ UPPER(toCONEXAO.DRIVER)
				lcNEW1 = 'DATE_FORMAT('
				lcNEW2 = ",'%D/%m/%Y')"
			CASE 'POSTGRES' $ UPPER(toCONEXAO.DRIVER)
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY')"
			CASE 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY')"
			OTHERWISE
				lcNEW1 = 'CONVERT(VARCHAR(10),'
				lcNEW2 = ',103)'
		ENDCASE
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG1, lcNEW1 )
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG2, lcNEW2 )
	ENDIF

	* CAMPOS DIA DA SEMANA
	IF 'FNOMDIA(' $ tcSINTAXE
		STORE '' TO lcNEW1, lcNEW2
		lcTAG1 = 'FNOMDIA('
		lcTAG2 = ')FNOMDIA'
		DO CASE
			CASE 'MYSQL' $ UPPER(toCONEXAO.DRIVER)
				**
			CASE 'POSTGRES' $ UPPER(toCONEXAO.DRIVER)
				**
			CASE 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
				**
			OTHERWISE
				lcNEW1 = "SUBSTR('DomingoSegundaTerça  Quarta Quinta Sexta  Sábado ',(DATEPART(dw,"
				lcNEW2 = ')-1)*7+1,7)'
		ENDCASE
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG1, lcNEW1 )
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG2, lcNEW2 )
	ENDIF

	* TRATAMENTO DE CAMPOS NULOS
	IF 'ISNULL(' $ tcSINTAXE
		DO CASE
			CASE 'MYSQL' $ UPPER(toCONEXAO.DRIVER) &&&  LINHA ALTERADA  &&&
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','COALESCE(')
			CASE 'POSTGRES' $ UPPER(toCONEXAO.DRIVER)
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','COALESCE(')
			CASE 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','NVL(')
			OTHERWISE
				* NÃO PRECISA FAZER (PADRÃO MS-SQL SERVER)
		ENDCASE
	ENDIF

	* TRATAMENTOS ESPECIAIS DE SINTAXE
	DO CASE
		CASE 'MYSQL' $ UPPER(toCONEXAO.DRIVER)
				tcSINTAXE = TRATAMYSQL(tcSINTAXE)
		CASE 'POSTGRES' $ UPPER(toCONEXAO.DRIVER)
			tcSINTAXE = TRTSINPGSQL(tcSINTAXE)
			tcSINTAXE = TRTFUNPGSQL(tcSINTAXE)
		CASE 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
			tcSINTAXE = TRATASQLORACLE(tcSINTAXE)
		OTHERWISE
			tcSINTAXE = TRATASQLMSSQL(tcSINTAXE)
	ENDCASE

	* EXECUTA COMANDO NA BASE
	gnSQLOK = SQLEXEC(toCONEXAO.ALCA,tcSINTAXE,tcARQUIVO)
        
	IF gnSQLOK<0
		=AERROR(laERRO)

		lcNUMERRO	= ALLTRIM(STR(laERRO(1)))
		lcERRO		= laERRO(3)

		lnRESP	= MESSAGEBOX('ERRO NO ACESSO À BASE DE DADOS: ' + CHR(13)+CHR(10)+;
								SYS(16)+CHR(13)+CHR(10)+;
								lcNUMERRO+CHR(13)+CHR(10)+;
								lcERRO,'AVISO: SQL-ERRO',48+2+256)
		IF lnRESP = 3
			_CLIPTEXT	= tcSINTAXE
			DEBUG
			SUSP
		ENDIF
		IF lnRESP = 4
			_CLIPTEXT = tcSINTAXE
		ENDIF
	ELSE
		* TRATAMENTO DE ARREDONDAMENTO DAS CASAS DECIMAIS SOMENTE NO ORACLE
		** DEVIDO A BUG DO DRIVER {MICROSOFT ODBC PARA ORACLE} AO EFETUAR FUNÇÕES COMO SUM, MAX, MIN E ETC...
		LOCAL ARRAY laCAMPOS[1]
		
		LOCAL lnXI AS Integer
		STORE 0 TO lnXI
		
		LOCAL lcMACRO, lcFIELDS AS String
		STORE '' TO lcMACRO, lcFIELDS

		LOCAL llOK AS Logical
		STORE .F. TO llOK

		IF 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
			=AFIELDS(laCAMPOS,tcARQUIVO)
			FOR lnXI = 1 TO ALEN(laCAMPOS,1)
				IF 'VL_' $ UPPER(laCAMPOS[lnXI,1]) AND laCAMPOS[lnXI,2] = 'N' AND laCAMPOS[lnXI,3] = 20 AND laCAMPOS[lnXI,4] = 0
					lcFIELDS = lcFIELDS + ',CAST(' + laCAMPOS[lnXI,1] + ' AS N(20,2)) AS ' + laCAMPOS[lnXI,1]
					llOK = .T.
				ELSE
					lcFIELDS = lcFIELDS + ',' + laCAMPOS[lnXI,1]
				ENDIF
			ENDFOR
			IF llOK
				lcFIELDS = SUBSTR(lcFIELDS,2)
				lcMACRO = 'SELECT ' + lcFIELDS + ' FROM ' + tcARQUIVO + ' INTO CURSOR ' + tcARQUIVO + ' READWRITE'
				&lcMACRO
			ENDIF
		ENDIF
	ENDIF
RETURN

FUNC TRATASQLFOX
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	IF ' CASE WHEN ' $ lcCPOOUT
		lcCPOOUT = STRTRAN( lcCPOOUT, ' CASE WHEN '	, ' IIF( '	)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' THEN '		, ' , '		)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' ELSE '		, ' , '		)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' END '		, ' ) '		)
	ENDIF
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LPAD(', 'PADL(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'RPAD(', 'PADR(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(')
RETURN(lcCPOOUT)

FUNC TRTSINPGSQL
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(')
	lcCPOOUT = STRTRAN( lcCPOOUT, "\'", "\.'" )
RETURN(lcCPOOUT)

FUNC TRTFUNPGSQL
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = REMOVERTOPSQL(lcCPOOUT,'LIMIT')
	lcCPOOUT = STRTRAN( lcCPOOUT, ' SPACE( ', ' LPAD(" ",')
RETURN(lcCPOOUT)

FUNC TRATASQLORACLE
*******************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT, lcP1, lcP2 AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT	= tcCPOIN
	lcCPOOUT	= STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(' )
	lcCPOOUT	= STRTRAN( lcCPOOUT, ' SPACE( ', ' LPAD(" ",' )
	* TRATANDO POR PARTES
	IF 'FROM' $ lcCPOOUT
		lcP1 = STREXTRACT(lcCPOOUT,'','FROM',1,4)
		lcP2 = STREXTRACT(lcCPOOUT,'FROM','',1,0)
		lcP2 = STRTRAN( lcP2, ' AS ', ' ')
		lcP1 = REMOVERTOPSQL(lcP1,'ROWNUM')
		lcCPOOUT = lcP1+lcP2
	ENDIF
	IF 'DATE_PART(' $ lcCPOOUT
		LOCAL lcAUX, lcCONTEUDO AS String
		LOCAL lnXI AS Integer
		FOR lnXI = 1 TO OCCURS('DATE_PART(',lcCPOOUT)
			lcCONTEUDO = STREXTRACT(lcCPOOUT,'DATE_PART(',')',lnXI)
			IF EMPTY(lcCONTEUDO)
				LOOP
			ENDIF
			DO CASE
				CASE 'DAY' $ lcCONTEUDO
					lcAUX = STREXTRACT( lcCONTEUDO, ',' , '' ) + ", 'DD'" 
					lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
				CASE 'MONTH' $ lcCONTEUDO
					lcAUX = STREXTRACT( lcCONTEUDO, ',' , '' ) + ", 'MM'"
					lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
				CASE 'YEAR' $ lcCONTEUDO
					lcAUX = STREXTRACT( lcCONTEUDO, ',' , '' ) + ", 'YYYY'"
					lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
				OTHERWISE
					LOOP
			ENDCASE										
		ENDFOR
		lcCPOOUT= STRTRAN(lcCPOOUT,'DATE_PART(','TO_CHAR(')
	ENDIF
RETURN(lcCPOOUT)


FUNC TRATAMYSQL
***************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT, lcAUX, lcP1, lcP2 AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT	= tcCPOIN
	lcCPOOUT 	= STRTRAN( lcCPOOUT, ' INTEGER' , ' DECIMAL(11,0)' )
	lcCPOOUT 	= STRTRAN( lcCPOOUT, '\' , '\\' )
	lcCPOOUT 	= REMOVERTOPSQL(lcCPOOUT,'LIMIT')
	IF ('CONCAT(' $ lcCPOOUT) AND (')CONCAT' $ lcCPOOUT)
		LOCAL lcAUX, lcCONTEUDO AS String
		LOCAL lnXI AS Integer
		FOR lnXI = 1 TO OCCURS('CONCAT(',lcCPOOUT)
			lcCONTEUDO = STREXTRACT(lcCPOOUT,'CONCAT(',')CONCAT',lnXI)
			IF EMPTY(lcCONTEUDO)
				LOOP
			ENDIF
			lcAUX 	= STRTRAN( lcCONTEUDO, '||' , ',' )
			lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
			lcCPOOUT= STRTRAN(lcCPOOUT,')CONCAT',')',1,1)
		NEXT
	ENDIF
	IF (' NUMERIC(' $ lcCPOOUT)
		lcCPOOUT	= STRTRAN(lcCPOOUT,' NUMERIC(',' DECIMAL(')
	ENDIF
	
	IF ('COALESCE(' $ lcCPOOUT)
		LOCAL lcAUX, lcCAMPO, lcCONTEUDO AS String
		LOCAL lnXI AS Integer
		FOR lnXI = 1 TO OCCURS('COALESCE(',lcCPOOUT)
			lcCONTEUDO = STREXTRACT(lcCPOOUT,'COALESCE(',')',lnXI)
			IF EMPTY(lcCONTEUDO)
				LOOP
			ENDIF

			lcCAMPO	= STREXTRACT(lcCONTEUDO,'',',',1)			
			lcAUX	= STREXTRACT(lcCONTEUDO,',','',1)
			IF ALLTRIM(lcAUX) == '0'
				lcCPOOUT	= STRTRAN(lcCPOOUT,'COALESCE(' + lcCAMPO + ',' + lcAUX + ')','COALESCE(' + lcCAMPO + ', 0.0)',1,1)
			ENDIF
		NEXT
	ENDIF
	
	IF ('COUNT(*)' $ lcCPOOUT)
		lcCPOOUT	= STRTRAN(lcCPOOUT,'COUNT(*)','COALESCE(COUNT(*),0.0)')
	ENDIF
RETURN(lcCPOOUT)


FUNC TRATASQLMSSQL
******************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT, lcCONTEUDO, lcSUBSTITUI, lcAUX AS String
	LOCAL lnXI, lnOCO AS Integer
	STORE '' TO lcCPOOUT, lcCONTEUDO, lcSUBSTITUI, lcAUX
	STORE 0 TO lnXI, lnOCO
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = STRTRAN( lcCPOOUT, '||' , '+' )
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTR(', 'SUBSTRING(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LENGTH(', 'LEN(')
	IF 'LPAD(' $ lcCPOOUT
		FOR lnXI = 1 TO 100
			lcCONTEUDO	= STREXTRACT(lcCPOOUT,'LPAD(',')')
			IF EMPTY(lcCONTEUDO)
				EXIT
			ENDIF
			lnOCO		= RAT( ',' , lcCONTEUDO )
			lcSUBSTITUI	= 'CAST( ' + ;
							LEFT( lcCONTEUDO,lnOCO-1 ) + ;
							' AS CHAR(' + ;
							RIGHT( lcCONTEUDO,lnOCO-2 ) + '))'
			lcCPOOUT	= STRTRAN( lcCPOOUT, 'LPAD(' + lcCONTEUDO + ')', lcSUBSTITUI )
		ENDFOR
	ENDIF
	IF 'RPAD(' $ lcCPOOUT
		FOR lnXI = 1 TO 100
			lcCONTEUDO	= STREXTRACT(lcCPOOUT,'RPAD(',')')
			IF EMPTY(lcCONTEUDO)
				EXIT
			ENDIF
			lnOCO		= RAT( ',' , lcCONTEUDO )
			lcSUBSTITUI	= 'CAST( ' + ;
							LEFT( lcCONTEUDO,lnOCO-1 ) + ;
							' AS ' + ;
							RIGHT( lcCONTEUDO,lnOCO-2 ) + ')'
			lcCPOOUT	= STRTRAN( lcCPOOUT, 'LPAD('+lcCONTEUDO+')', lcSUBSTITUI )
		ENDFOR
	ENDIF
	IF 'DATE_PART(' $ lcCPOOUT
		FOR lnXI = 1 TO 100
			lcCONTEUDO	= STREXTRACT(lcCPOOUT,'DATE_PART(',')')
			IF EMPTY(lcCONTEUDO)
				EXIT
			ENDIF
			lcAUX		= UPPER(STREXTRACT(lcCONTEUDO, "'", "'," ))
			IF NOT lcAUX $ 'DAY,MONTH,YEAR'
				LOOP
			ENDIF
			lcSUBSTITUI	= UPPER(lcAUX) + '(' + ;
							UPPER(STREXTRACT(lcCONTEUDO, "',")) + ')'
			lcCPOOUT	= STRTRAN( lcCPOOUT, 'DATE_PART('+lcCONTEUDO+')', lcSUBSTITUI )
		ENDFOR
	ENDIF
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LENGTH(', 'LEN(')
RETURN(lcCPOOUT)

FUNC REMOVERTOPSQL
******************
LPARAMETERS tcSQL, tcOUTROS
	LOCAL lcOUT AS String
	lcOUT = tcSQL
	IF ' TOP ' $ lcOUT
		LOCAL lcAUX, lcLETRA AS String
		LOCAL lnOCO AS Integer
		lcAUX	= ''
		lnOCO	= AT(' TOP ',lcOUT)
		FOR lnXI = lnOCO+5 TO LEN(lcOUT)
			lcLETRA = SUBSTR(lcOUT,lnXI,1)
			IF EMPTY(lcLETRA)
				EXIT
			ENDIF
			lcAUX = lcAUX + lcLETRA
		ENDFOR
		lcOUT	= STRTRAN(lcOUT,' TOP '+lcAUX,'')
		IF 'LIMIT' $ tcOUTROS
			lcOUT	= lcOUT + ' LIMIT '+lcAUX
		ENDIF
	ENDIF
RETURN(lcOUT)

PROC MENS
*********
LPARAMETERS tcMENSAGEM,tnERRO
* MENSAGEM AO USUARIO, SE TNERRO=1 A MENSAGEM É MAIS GRAVE.
	IF TYPE('tnERRO')<>'N'
		tnERRO = 0
	ENDIF
	tnERRO = IIF(tnERRO>0,48,64)
	=MESSAGEBOX(tcMENSAGEM,'AVISO',tnERRO)
RETURN

PROC SIMOUNAO
*************
LPARAMETERS tcPERGUNTA, tcTITULO, tnDEFAULT
	LOCAL lnBOTAO AS Number
	IF VARTYPE(tnDEFAULT) <> 'N'
		tnDEFAULT = 0
	ENDIF
	IF tnDEFAULT = 1
		tnBOTAO = 0
	ELSE
		tnBOTAO = 256
	ENDIF
	IF MESSAGEBOX( tcPERGUNTA, tcTITULO, 32+4+tnBOTAO )=6
		RETURN(.T.)
	ENDIF
RETURN(.F.)


PROC CONFIGFRM
**************
PARAMETERS toFORMATU

	PRIVATE poFORM AS Object
	poFORM	= toFORMATU

	WITH toFORMATU

		* PROPRIEDADES DO FORM
		.AUTOCENTER = .T.
		IF TYPE('lcTITULO')='C'
			.CAPTION = lcTITULO
		ENDIF
		.SETALL('DISABLEDFORECOLOR',RGB(0,0,0))

		* PROPRIEDADES DOS OBJETOS DENTRO DO FORM
		DO CONFIGOBJETOS WITH poFORM

	ENDWITH
RETURN

PROC CONFIGOBJETOS
******************
LPARAMETERS toOBJETO AS Object

	LOCAL loSUB, loPAGINA AS Object
	LOCAL lcBASE AS String
	STORE '' TO lcBASE

	FOR EACH loSUB IN toOBJETO.CONTROLS

		lcBASE	= ALLTRIM( UPPER( loSUB.BASECLASS ) )

		DO CASE
			CASE lcBASE	= 'PAGEFRAME'
				FOR EACH loPAGINA IN loSUB.PAGES
					DO CONFIGOBJETOS WITH loPAGINA
				ENDFOR

			CASE lcBASE = 'CONTAINER'
				IF UPPER(loSUB.CLASS) == 'IMGPREVIEW'
					IF loSUB.myAUTOMATICO
						loSUB.myCARREGAR()
					ENDIF
				ENDIF
				*DO CONFIGOBJETOS WITH loSUB

			OTHERWISE
				IF lcBASE = 'TEXTBOX'
					DO MODELARTEXT WITH loSUB, toOBJETO
				ENDIF
				IF lcBASE $ 'COMBOBOX,SPINNER'
					loSUB.FONTNAME	= 'FIXEDSYS'
					loSUB.HEIGHT	= 23
				ENDIF
				IF lcBASE $ ',CHECKBOX,COMMANDBUTTON,'
					loSUB.DISABLEDFORECOLOR = RGB(128,128,128)
				ENDIF
				IF lcBASE $ ',TEXTBOX,EDITBOX,COMBOBOX,SPINNER'
					IF '*' $ loSUB.COMMENT
						loSUB.BACKCOLOR = goAPLICATIVO.COROBRIGATORIO
					ENDIF
				ENDIF

		ENDCASE

	ENDFOR
RETURN

PROC MODELARTEXT
****************
* FORMATA CAIXA TEXTO
LPARAMETERS toTXT, toPAI AS Object

	LOCAL lcVARIAVEL, lcNOMESHAPE, lcNOMEBTN, lcPICTSEGTO, lcTIPOVAR AS String
	LOCAL lnTAMPIC AS Integer
	LOCAL llPREENC_EMP AS Logical
	LOCAL luGET
	STORE '' TO lcVARIAVEL, lcNOMESHAPE, lcNOMEBTN, lcPICTSEGTO
	STORE 0 TO lnTAMPIC
	
	* NÃO CONFIGURAR CAIXA DE TEXTO
	IF '<NOCONFIG>' $ toTXT.Comment
		RETURN
	ENDIF
	
	toTXT.FONTNAME	= 'FIXEDSYS'
	toTXT.HEIGHT	= 23
	toTXT.MARGIN	= 1
	
	*DESABILITA MSG DE F4 INATIVO
	goAPLICATIVO.VALIDARINIT=1
	
	lcVARIAVEL = toTXT.CONTROLSOURCE
	IF NOT EMPTY(toTXT.MAXLENGTH)
		toTXT.WIDTH = TAMANHOTX(toTXT.MAXLENGTH)
	ENDIF
	IF NOT EMPTY(toTXT.INPUTMASK) AND NOT '[]' $ toTXT.COMMENT
		lnTAMPIC = LEN(ALLTRIM(toTXT.INPUTMASK))
		IF lnTAMPIC >= 1
			toTXT.WIDTH = TAMANHOTX(lnTAMPIC)
		ENDIF
	ENDIF
	IF EMPTY(toTXT.FORMAT) AND EMPTY(toTXT.INPUTMASK)
		toTXT.FORMAT = '!'
	ENDIF
	IF NOT EMPTY(lcVARIAVEL)
		lcVARIAVEL	= STRTRAN(lcVARIAVEL,'THISFORM','toFORMATU')
		luGET		= EVALUATE( lcVARIAVEL )
		lcTIPOVAR	= TYPE( lcVARIAVEL )
		IF lcTIPOVAR = 'C'
			IF NOT ISNULL(luGET)
				IF EMPTY(toTXT.MAXLENGTH)
					toTXT.MAXLENGTH = LEN(luGET)
				ENDIF
				IF NOT '<>' $ toTXT.Comment
					toTXT.WIDTH = TAMANHOTX(LEN(luGET))
				ELSE
					lcNOMESHAPE	= 'lbl'+toTXT.NAME
					toPAI.ADDOBJECT(lcNOMESHAPE,'LABEL')
					lcNOMESHAPE = 'toPAI.' + lcNOMESHAPE
					&lcNOMESHAPE. .CAPTION		= ''
					&lcNOMESHAPE. .BACKCOLOR	= RGB(192,0,0)
					&lcNOMESHAPE. .TOP			= toTXT.TOP + toTXT.HEIGHT - 2
					&lcNOMESHAPE. .LEFT			= toTXT.LEFT + toTXT.WIDTH
					&lcNOMESHAPE. .HEIGHT		= 2
					&lcNOMESHAPE. .WIDTH		= 2
					&lcNOMESHAPE. .VISIBLE		= .T.
				ENDIF
			ENDIF
		ENDIF
		
		IF lcTIPOVAR='D'
			toTXT.WIDTH = TAMANHOTX(10)
		ENDIF
		IF lcTIPOVAR='T'
			toTXT.WIDTH = TAMANHOTX(20)
		ENDIF
		IF lcTIPOVAR='N'
			IF '<OP>' $ toTXT.Comment
				toTXT.InputMask	= goAPLICATIVO.OPNUMERO_PICT
			ENDIF
			IF '<QT>' $ toTXT.Comment
				toTXT.InputMask	= goAPLICATIVO.ESTOQUE_PICT
			ENDIF
			IF '<PU>' $ toTXT.Comment
				toTXT.InputMask	= goAPLICATIVO.PREUNI_PICT
			ENDIF
			IF NOT EMPTY(toTXT.InputMask) AND NOT '[]' $ toTXT.Comment
				lnTAMPIC = LEN(toTXT.InputMask)
				IF lnTAMPIC>1
					toTXT.WIDTH = TAMANHOTX(lnTAMPIC)
				ENDIF
			ENDIF
		ENDIF
	ENDIF
	IF NOT EMPTY(toTXT.TAG)
		* TEXTBOX DE F4
		lcNOMEBTN = 'F4'+ALLTRIM(toTXT.NAME)
		toPAI.NEWOBJECT(lcNOMEBTN,'LABELF4','VOLPECFG')
		lcNOMEBTN = 'toPAI.'+lcNOMEBTN
		&lcNOMEBTN. .LEFT		= toTXT.LEFT + toTXT.WIDTH
		&lcNOMEBTN. .TOP		= toTXT.TOP
		&lcNOMEBTN. .HEIGHT		= toTXT.HEIGHT
		&lcNOMEBTN. .ANCHOR		= toTXT.ANCHOR
		&lcNOMEBTN. .myTEXT		= toTXT
		IF toTXT.VISIBLE
			&lcNOMEBTN. .VISIBLE	= .T.
			IF TYPE('toFORMATU.MyACAO') = 'C'
				IF  toFORMATU.MyACAO= 'M'
					toTXT.VALID()
				ENDIF
			ENDIF
		ENDIF
		IF toTXT.TAG = 'TB_SEGMENTOS'
			lcPICTSEGTO			= goAPLICATIVO.SEGMENTO_PICT
			toTXT.FORMAT		= 'R'
			toTXT.INPUTMASK		= lcPICTSEGTO
		ENDIF
		IF toTXT.TAG = 'TB_EMPRESAS' AND EMPTY(toTXT.VALUE)
			llPREENC_EMP	= .T.
			IF ALLTRIM(UPPER(toFORMATU.CLASS)) = 'FORMDIG'
				IF toFORMATU.myACAO = 'M'
					llPREENC_EMP	= .F.
				ENDIF
			ENDIF
			IF llPREENC_EMP
				toTXT.VALUE	= goAPLICATIVO.EMPATUAL
			ENDIF
		ENDIF
	ENDIF
	*RE-HABILITA MSG DE F4 INATIVO
	goAPLICATIVO.VALIDARINIT=0

RETURN

FUNC TAMANHOTX
**************
* CALCULA O TAMANHO DE UMA CAIXA TEXTO
LPARAMETERS tnQCARAC
	LOCAL lnSIZE AS Integer
	lnSIZE = tnQCARAC * 8 + 14
RETURN(lnSIZE)

PROC WAW_CRIPTAR
****************
	LPARAMETERS tcIN
		LOCAL llERROR AS Boolean
		STORE .F. TO llERROR
		TRY 
			tcIN 	= goZIP.ENCRYPT(tcIN,"CONFIG0105SÃO'")
			llERROR	= .F.
		CATCH
			llERROR	= .T.
		ENDTRY
		
		* Tratamento de erro
		IF llERROR
			tcIN	= ''
		ENDIF
	RETURN tcIN
ENDPROC

PROC WAW_DECRIPTAR
******************
	LPARAMETERS tcIN
		LOCAL llERROR AS Boolean
		STORE .F. TO llERROR
		TRY 
			tcIN 	= goZIP.DECRYPT(tcIN,"CONFIG0105SÃO'")
			llERROR	= .F.
		CATCH
			llERROR	= .T.
		ENDTRY
		
		* Tratamento de erro
		IF llERROR
			tcIN	= ''
		ENDIF
	RETURN tcIN
ENDPROC

FUNC SBDVEM
***********
*DECRIPTA SENHA DE CONEXÃO
PARAMETERS tcHIDEN
	tcHIDEN = ALLTRIM(tcHIDEN)
	LOCAL lcSENHA, lcSEMENTE, lcLETRA AS String
	lcSENHA = ''
	lcSEMENTE = SUBSTR(tcHIDEN,2,1)
	LOCAL X, Y AS INTEGER

	FOR X = LEN(tcHIDEN) TO 3 STEP -3
		Y = VAL( SUBSTR(tcHIDEN,X-2,3) ) -ASC(lcSEMENTE)
		lcLETRA = ''
		IF Y>27 AND Y<256
			lcLETRA = CHR(Y)
		ENDIF
		lcSENHA = lcSENHA + lcLETRA
	ENDFOR
RETURN(lcSENHA)

FUNC SBDVAI
***********
* ENCRIPTA SENHA DE BANCO DE DADOS
PARAMETERS tcSENHA
	tcSENHA = ALLTRIM(tcSENHA)
	LOCAL lcHIDEN, lcSEMENTE, lcLETRA AS String
	lcHIDEN = ''
	LOCAL X, Y AS INTEGER
	X = INT(RAND()*25)
	Y = MOD(ASC(tcSENHA+' '),10)
	lcSEMENTE = CHR(X+65)
	lcHIDEN = STR(Y,1)+lcSEMENTE
	FOR X = LEN(tcSENHA) TO 1 STEP -1
		lcLETRA = SUBSTR(tcSENHA,X,1)
		Y = ASC(lcLETRA)+ASC(lcSEMENTE)
		lcLETRA = PADL( ALLTRIM(STR(Y)) ,3,'0')
		lcHIDEN = lcHIDEN + lcLETRA
	ENDFOR
RETURN(lcHIDEN)

FUNC VERIFOBRIGATORIO
*********************
* VERIFICA DIGITAÇÃO DE CAMPOS OBRIGATÓRIOS
LPARAMETERS toOBJETO AS Object
	IF TYPE('toOBJETO') <> 'O'
		RETURN
	ENDIF

	LOCAL loSUB, loPAGINA, loFRAME AS Object
	LOCAL lcBASE AS String
	LOCAL llERRO AS Logical
	STORE '' TO lcBASE
	STORE .F. TO llERRO

	FOR EACH loSUB IN toOBJETO.CONTROLS

		lcBASE	= ALLTRIM( UPPER( loSUB.BASECLASS ) )

		DO CASE
			CASE lcBASE	= 'PAGEFRAME'
				FOR EACH loPAGINA IN loSUB.PAGES
					llERRO	= VERIFOBRIGATORIO(loPAGINA)
					IF llERRO
						EXIT
					ENDIF
				ENDFOR

			CASE lcBASE = 'CONTAINER'
				llERRO	= VERIFOBRIGATORIO(loSUB)

			OTHERWISE
				IF lcBASE $ ',TEXTBOX,EDITBOX,'
					IF '*' $ loSUB.COMMENT AND loSUB.Enabled = .T.
						IF VARTYPE(loSUB.VALUE)='C'
							loSUB.VALUE = STRTRAN(loSUB.VALUE,"'","")
						ENDIF
						IF EMPTY(loSUB.VALUE)
							loFRAME = loSUB.Parent
							IF ALLTRIM(UPPER(loFRAME.BASECLASS)) == 'PAGE'
								loFRAME.SetFocus()
							ENDIF
							DO MENS WITH 'CAMPO DE PREENCHIMENTO OBRIGATÓRIO'
							loSUB.SetFocus()
							llERRO	= .T.
						ENDIF
					ENDIF
				ENDIF
				IF lcBASE $ ',COMBOBOX,'
					IF '*' $ loSUB.COMMENT AND loSUB.Enabled = .T.
						IF VARTYPE(loSUB.VALUE)='C'
							IF loSUB.Style = 0 	&& DropDownCombo
								loSUB.Value = STRTRAN(loSUB.Text,"'","")
							ELSE 				&& DropDownList
								loSUB.Value = STRTRAN(loSUB.Value,"'","")							
							ENDIF
						ENDIF
						IF EMPTY(loSUB.VALUE)
							DO MENS WITH 'CAMPO DE PREENCHIMENTO OBRIGATÓRIO'
							loSUB.SetFocus()
							llERRO	= .T.
						ENDIF
					ENDIF
				ENDIF				
				IF lcBASE $ ',LISTBOX,'
					IF '*' $ loSUB.COMMENT AND loSUB.Enabled = .T.
						IF loSUB.ListCount<=0
							loFRAME = loSUB.Parent
							loFRAME.SetFocus()
							DO MENS WITH 'CAMPO DE PREENCHIMENTO OBRIGATÓRIO'
							loSUB.SETFOCUS()
							llERRO	= .T.
						ENDIF
					ENDIF
				ENDIF
 		ENDCASE
		IF llERRO
			EXIT
		ENDIF
	ENDFOR
RETURN(llERRO)

FUNC XX
*******
*RETORNA STRING PRONTA PARA CONCATENAR C/ COMANDO-SQL
PARAMETERS tnENTRA, tcPICTURE, toCONEXAO
	IF TYPE('tcPICTURE') <> 'C'
		tcPICTURE	= ''
	ENDIF
	IF VARTYPE(toCONEXAO) <> 'O'
		toCONEXAO	= GOCONEXAO1
	ENDIF
	LOCAL lcSAI AS String
	lcSAI = 'NULL'
	IF NOT ISNULL(tnENTRA)
		IF TYPE('tnENTRA')='N'
			IF EMPTY(tcPICTURE)
				DO CASE
					CASE tnENTRA = INT(tnENTRA)
						tcPICTURE	= REPLICATE('9',20)
					CASE tnENTRA = ROUND(tnENTRA,2)
						tcPICTURE	= REPLICATE('9',20) + '.' + REPLICATE('9',2)
					OTHERWISE
						tcPICTURE	= REPLICATE('9',20) + '.' + REPLICATE('9',8)
				ENDCASE
			ENDIF
			lcSAI = TRANSFORM(tnENTRA,tcPICTURE)
			lcSAI = STRTRAN(lcSAI,',','.')
			lcSAI = ALLTRIM(lcSAI)
		ENDIF
		IF TYPE('tnENTRA')='C'
			tnENTRA = STRTRAN(tnENTRA,"'","")
			lcSAI	= ALLTRIM(tnENTRA)
			IF EMPTY(lcSAI)
				lcSAI = " "
			ENDIF
			IF 'LIKE' $ tcPICTURE
				DO CASE
					CASE tcPICTURE = '%LIKE%'
						lcSAI = "%"+ALLTRIM(lcSAI)+"%"
					CASE tcPICTURE = 'LIKE%'
						lcSAI = ALLTRIM(lcSAI)+"%"
					CASE tcPICTURE = '%LIKE'
						lcSAI = "%"+ALLTRIM(lcSAI) 
				ENDCASE
			ENDIF
			lcSAI = "'"+lcSAI+"'"
		ENDIF
		IF TYPE('tnENTRA')='D' OR TYPE('tnENTRA')='T'
			lcSAI = D2SQL(tnENTRA,.F.,toCONEXAO)
		ENDIF
		IF TYPE('tnENTRA')='L'
			IF tnENTRA
				lcSAI = '1'
			ELSE
				lcSAI = '0'
			ENDIF
		ENDIF
	ENDIF
RETURN(lcSAI)


PROC ATUSQL
***********************************************************************
* ATUSQL - ATUALIZA BASE SQL DE ACORDO COM A AÇÃO DESEJADA	- *
***********************************************************************
PARAMETERS tcACTION, tcTABELA, tcOUTROS, tcCAMPOSUPDATE, toCONEXAO
	* PARAMETRO1 - ACAO (A/M/D)
	* PARAMETRO2 - TABELA
	* PARAMETRO3 - STRING CONTENDO PALAVRAS-CHAVE
	* PARAMETRO4 - CAMPOS EXCEÇÕES (SE VAI GRAVAR OU NÃO, DEPENDE DAS PALAVRAS-CHAVE)
	* PALAVRAS-CHAVE:
	* NOAUTOINC = INDICA QUE O PK_ID NÃO É AUTONUMERAÇÃO (PRECISA GRAVA-LO)
	* NOSTOP = SE DER ERRO, NÃO PARA A APLICAÇÃO E LOGA O REGISTRO (USADO EM IMPORTAÇÕES)
	* UPDATE=NO = INDICA QUE OS CAMPOS RELACIONADOS DEVEM SER IGNORADOS
	* UPDATE=YES= INDICA QUE OS SÓ CAMPOS RELACIONADOS DEVEM SER GRAVADOS
	* ERRO=CONTINUE = INDICA QUE EM CASO DE ERRO NA GRAVACAO DEVE AVISAR, IGNORAR E PROSSEGUIR
	* ERRO=LOG = INDICA QUE NÃO VAI DAR MENSAGEM DE ERRO SQL, APENAS GERAR LOG
	IF TYPE('tcACTION') <> 'C'
		DO MENS WITH 'Nenhuma ação foi informada (ATUSQL)'
		RETURN
	ENDIF
	IF EMPTY(ALIAS())
		DO MENS WITH 'Nenhuma tabela selecionada (ATUSQL)'
		RETURN
	ENDIF
	IF NOT tcACTION $ 'AMD'
		DO MENS WITH 'Ação informada não foi reconhecida: ('+tcACTION+') ATUSQL'
		RETURN
	ENDIF
	IF TYPE('tcTABELA') <> 'C'
		tcTABELA = ALIAS()
	ENDIF
	IF TYPE('tcOUTROS') <> 'C'
		tcOUTROS = ''
	ENDIF
	IF TYPE('tcCAMPOSUPDATE') <> 'C'
		tcCAMPOSUPDATE = ''
	ENDIF
	IF VARTYPE(toCONEXAO) <> 'O'
		toCONEXAO	= goCONEXAO1
	ENDIF
	
	tcCAMPOSUPDATE = VIRGULAR(tcCAMPOSUPDATE)

	lnUPDATE = 0
	IF 'UPDATE=NO' $ tcOUTROS
		lnUPDATE = 1
		tcCAMPOSUPDATE	= STRTRAN( tcCAMPOSUPDATE, 'DH_INCLUSAO', '' )
		tcCAMPOSUPDATE	= STRTRAN( tcCAMPOSUPDATE, 'DH_ALTERACAO', '' )
		tcCAMPOSUPDATE	= STRTRAN( tcCAMPOSUPDATE, 'FK_OWNER', '' )
	ENDIF
	IF 'UPDATE=YES' $ tcOUTROS
		lnUPDATE = 2
		tcCAMPOSUPDATE	= tcCAMPOSUPDATE + ',DH_INCLUSAO,DH_ALTERACAO,FK_OWNER,'
	ENDIF

	PRIVATE ARRAY laERRO[1]
	PRIVATE lnSQLOK, lnRESP, lnIDENTITY, lnCONTEUXID, lnRESPIDENTITY AS Integer
	PRIVATE lcATUSQL, lcERRO, lcALIASUI, lcCMDIDENTITY, lcMOTIVO, pcSINTAXELIXEIRA, lcALIASFOX AS String
	LOCAL lcAUX AS String

	* OBJETO PARA ATUALIZAÇÃO DE ESTOQUE (SALDO ON-LINE)
	PRIVATE poESTOQUE AS Object
	poESTOQUE	= CREATEOBJECT('EMPTY')
	* PROPRIEDADES GERAIS
	=ADDPROPERTY(poESTOQUE,'FK_PROANT','')
	=ADDPROPERTY(poESTOQUE,'FK_PROATU','')
	=ADDPROPERTY(poESTOQUE,'FK_ESTANT','')
	=ADDPROPERTY(poESTOQUE,'FK_ESTATU','')
	=ADDPROPERTY(poESTOQUE,'TG_ESTANT',0)
	=ADDPROPERTY(poESTOQUE,'TG_ESTATU',0)
	=ADDPROPERTY(poESTOQUE,'QT_ESTANT',0)
	=ADDPROPERTY(poESTOQUE,'QT_ESTATU',0)
	* CONTROLE DE ATUALIZAÇÃO POR FOR E TAMANHO
	=ADDPROPERTY(poESTOQUE,'FK_CORANT',SPACE(3))
	=ADDPROPERTY(poESTOQUE,'FK_CORATU',SPACE(3))
	=ADDPROPERTY(poESTOQUE,'FK_TAMANT',SPACE(3))
	=ADDPROPERTY(poESTOQUE,'FK_TAMATU',SPACE(3))
	* PROPRIEDADES PARA CONTROLE DE QTD DE NOTAS FISCAIS (E/S)
	=ADDPROPERTY(poESTOQUE,'TG_ORIANT','')
	=ADDPROPERTY(poESTOQUE,'TG_ORIATU','')
	* PROPRIEDADES PARA CONTROLE DE CONSIGNAÇÃO
	=ADDPROPERTY(poESTOQUE,'TG_CONANT',0)
	=ADDPROPERTY(poESTOQUE,'TG_CONATU',0)
	* PROPRIEDADES PARA CONTROLE DE PENDÊNCIA DE PRODUTOS (VENDAS)
	=ADDPROPERTY(poESTOQUE,'TG_PENANT',0)
	=ADDPROPERTY(poESTOQUE,'TG_PENATU',0)
	=ADDPROPERTY(poESTOQUE,'TG_PENTEM',0)

	* VARIAVEIS PARA RESERVA DE PRODUTOS
	PRIVATE poRESERVA AS Object
	poRESERVA	= CREATEOBJECT('EMPTY')
	* PROPRIEDADES GERAIS
	=ADDPROPERTY(poRESERVA,'FK_PROANT','')
	=ADDPROPERTY(poRESERVA,'FK_PROATU','')
	=ADDPROPERTY(poRESERVA,'FK_ESTANT','')
	=ADDPROPERTY(poRESERVA,'FK_ESTATU','')
	=ADDPROPERTY(poRESERVA,'TG_RESANT',0)
	=ADDPROPERTY(poRESERVA,'TG_RESATU',0)
	=ADDPROPERTY(poRESERVA,'QT_RESANT',0)
	=ADDPROPERTY(poRESERVA,'QT_RESATU',0)

	* GRAVA ESPELHO DO REGISTRO PARA ARMAZENAR NA LIXEIRA DO SISTEMA
	pcSINTAXELIXEIRA	= ''

	lnSQLOK		= -1				&& CONTROLE DE OPERAÇÃO BEM SUCEDIDA
	luPK_ID		= PK_ID
	lcATUSQL	= ''
	lcALIASFOX  = ALIAS()

	pnAUTOINC = 0
	IF TYPE(ALIAS()+'.PK_ID') = 'N' AND NOT 'NOAUTOINC' $ tcOUTROS
		* POR DEFAULT OS PK NUMERICOS SÃO AUTONUMERAÇÃO
		pnAUTOINC = 1
	ENDIF

	* SE FOR FOXPRO E AUTONUMERAÇÃO, PEGA PROX.NUMERO (RECNO)
	IF pnAUTOINC=1 AND tcACTION='A'
		IF 'FOXPRO' $ UPPER(toCONEXAO.DRIVER)
			lcPROXIMO = 'SELECT RECCOUNT('+XX(tcTABELA)+') AS PROXIMO FROM DUAL'
			=PESQUISASQL(lcPROXIMO,'TMPLASTPK')
			luPK_ID		= TMPLASTPK.PROXIMO+1
			USE IN TMPLASTPK
			pnAUTOINC=0
			SELE &lcALIASFOX
			REPLACE PK_ID WITH luPK_ID
		ENDIF
	ENDIF

	* MONTA SINTAXE COMPLETA
	DO MONTASQLC WITH toCONEXAO

	* TRATAMENTOS ESPECIAIS DE SINTAXE
	DO CASE
		CASE 'POSTGRES' $ UPPER(toCONEXAO.DRIVER)
			lcATUSQL = TRTSINPGSQL(lcATUSQL)
		CASE 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
			lcATUSQL = TRATASQLORACLE(lcATUSQL)
		CASE 'MYSQL' $ UPPER(toCONEXAO.DRIVER)
			lcATUSQL = TRATAMYSQL(lcATUSQL)
		OTHERWISE
			lcATUSQL = TRATASQLMSSQL(lcATUSQL)
	ENDCASE

	lcATUSQL	= lcATUSQL

	toCONEXAO.LASTCOMMAND   = lcATUSQL
	toCONEXAO.LASTCURSOR    = ''
	* EXECUTA COMANDO NA BASE
	lnSQLOK		= SQLEXEC(toCONEXAO.ALCA,lcATUSQL)

	IF NOT goAPLICATIVO.TESTE AND lnSQLOK<0
		=AERROR(laERRO)
		* CASO SEJA ERRO DE CONEXÃO
*!*			IF VERERROCONEXAO(laERRO[4], laERRO[5])
*!*				*DO FORM SYSTEM_ERROCONEXAO
*!*				* SE OPTOU POR RECONECTAR, TENTA REPETIR A QUERY
*!*				lnSQLOK = REPETIRQUERY()
*!*			ENDIF
	ENDIF
	toCONEXAO.LASTCOMMAND   = ''
	toCONEXAO.LASTCURSOR    = ''

	IF lnSQLOK<0
		=AERROR(laERRO)
		lcNUMERRO	= ALLTRIM(STR(laERRO(1)))
		lcERRO		= laERRO(3)

		DO CASE
			CASE 'ERRO=LOG' $ tcOUTROS
				* SÓ GRAVAR LOG LOCAL E CONTINUAR
				DO LOGSQLERRO WITH tcTABELA, lcNUMERRO, lcERRO, lcATUSQL, toCONEXAO
				toCONEXAO.ERRORLOG = .T.
			CASE 'ERRO=CONTINUE' $ tcOUTROS
				* NÃO MOSTRA ERRO, APENAS CONTINUA
			CASE goAPLICATIVO.TESTE
				* TRATAMENTO DE ERRO CONTORNAVEL (AREA DE TESTES)
				lnRESP	= MESSAGEBOX('ERRO NO COMANDO À BASE DE DADOS: ' + CHR(13)+CHR(10)+;
									SYS(16)+CHR(13)+CHR(10)+;
									lcNUMERRO+CHR(13)+CHR(10)+;
									lcERRO,'AVISO: SQL-ERRO',48+2+256)
				IF lnRESP = 3
					IF goAPLICATIVO.TESTE
						DEBUG
						SUSPEND
					ELSE
						DO ROTERRO WITH 0-laERRO(1), lcERRO, SYS(16), 0
					ENDIF
				ENDIF
				IF lnRESP = 4
					_CLIPTEXT = lcATUSQL
				ENDIF
			OTHERWISE
				* TRATAMENTO DE ERRO CONVENCIONAL (AMBIENTE DE PRODUÇÃO)

				* VERIFICA SE ERRO FOI OCASIONADO DEVIDO A CONSTRAINT DE DEPÊNDENCIA, REGISTROS PAIS COM FILHOS
				IF VERERROCONSTRAINT(@laERRO)
					* CASO SEJA, NÃO É NECESSÁRIO EXIBIR MENSAGEM DE ERRO
					DO MENS WITH 'Registro não pode ser deletado! Existem dependências para registro selecionado.', 1
					RETURN(0)
				ENDIF

				* TRATAMENTO DE ERRO COMUM
				DO ROTERRO WITH 0-laERRO(1), lcERRO, SYS(16), 0
				RETURN
		ENDCASE
	ELSE
		toCONEXAO.ERRORLOG = .F.
		* SE O COMANDO DE [DELETAR] FOI BEM SUCEDIDO, GRAVA A LIXEIRA
		IF NOT EMPTY(pcSINTAXELIXEIRA) AND NOT tcTABELA $ '/TS_LIXEIRA/'
			=EXECUTASQL(pcSINTAXELIXEIRA)
		ENDIF
	ENDIF
	IF 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
		=SQLEXEC(toCONEXAO.ALCA,'COMMIT')
	ENDIF

	IF tcACTION='A' AND pnAUTOINC=1
		* SE FOI UM INSERT, PEGAR O CAMPO C/ AUTOINCREMENTO (IDENTITY)
		lcALIASUI	= ALIAS()
		lnIDENTITY	= 0
		DO PEGAULTINC WITH tcTABELA
		SELECT &lcALIASUI
		IF lnIDENTITY>0
			* ATUALIZA CAMPO AUTO-NUMERAÇÃO NA BASE LOCAL
			REPLACE PK_ID WITH lnIDENTITY
		ELSE
			lnSQLOK = -2
			* EXCLUIR REGISTRO (NAO FOI INCLUIDO NO SQL)
			DELETE
			SKIP-1
			IF BOF() AND NOT EOF()
				SKIP
			ENDIF
		ENDIF
	ENDIF

	IF lnSQLOK > 0
*!*			* ATUALIZAÇÃO DE QTD ON-LINE DO ESTOQUE
*!*			lcAUX	= ALLTRIM(UPPER(RETORNASET('ESTOQUE.ATUEST','C',1)))
*!*			IF EMPTY(lcAUX)
*!*				lcAUX	= 'ON'
*!*			ENDIF
*!*			IF  tcTABELA = 'ES_MOVIMENTOS' AND lcAUX = 'ON'
*!*				DO ATUEST
*!*			ENDIF
*!*			* ATUALIZAÇÃO DE RESERVA DE PRODUTOS
*!*			IF tcTABELA = 'VD_RESERVAS' AND lcAUX = 'ON'
*!*				DO ATURES
*!*			ENDIF
*!*			* GRAVAÇÃO DE LOG DO SISTEMA
*!*			IF '#'+tcTABELA+'#' $ goAPLICATIVO.LOGTABSIM
*!*				DO GRAVARLOGSYS
*!*			ENDIF
	ENDIF
	IF NOT EMPTY(lcALIASFOX)
		SELECT &lcALIASFOX
	ENDIF
RETURN(PK_ID)

FUNC D2SQL
**********
LPARAMETERS tdENTRA, tcMODO, toCONEXAO
* PARAMETRO1= DATA A SER TRANSFORMADA (OU STRING)
* PARAMETRO2= MODO (DATA/STRING)
* ONDE: DATA=MONTA A STRING COM A DATA JA CONVERTIDA, EX: CONVERT(DATETIME,20/11/2004,103)
*       STRING=MONTA UMA STRING A SER TRATADA PELO SERVIDOR SQL, EX: CONVERT(DATETIME,CAMPO,103)
*              (ENVIAR O NOME DO CAMPO PARA A CONDIÇÃO)
	IF TYPE('tcMODO') <> 'C'
		tcMODO = 'DATA'
	ENDIF
	IF tcMODO = 'STRING'
		IF TYPE('tdENTRA') <> 'C'
			RETURN('')
		ENDIF
	ELSE
		IF NOT TYPE('tdENTRA') $ 'DT'
			tdENTRA = {}
		ENDIF
	ENDIF
	IF TYPE('toCONEXAO') <> 'O'
		toCONEXAO	= goCONEXAO1
	ENDIF
	LOCAL luSAI
	luSAI = 'null'
	IF !EMPTY(tdENTRA)
		DO CASE
			CASE 'MYSQL' $ UPPER(toCONEXAO.DRIVER) &&&  LINHA ALTERADA  &&&
				*data entre aspas no formato aaaammdd
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= 'NOW()'
					CASE tcMODO = 'STRING'
						luSAI	= "DATE_FORMAT("+tdENTRA+",'%M/%D/%Y')"
					OTHERWISE
						luSAI	= "'"+DTOS(tdENTRA)+"'"
				ENDCASE
			CASE 'POSTGRES' $ UPPER(toCONEXAO.DRIVER)
				*data entre aspas no formato aaaammdd
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= "NOW()"
					CASE tcMODO = 'STRING'
						luSAI	= "TO_CHAR("+tdENTRA+",'MM/DD/YYYY')"
					OTHERWISE
						LOCAL lcHHMMSS AS STRING
						lcHHMMSS = TTOC(tdENTRA,2)
						IF TYPE('tdENTRA')='D'
							*data entre aspas no formato aaaammdd
							luSAI = "TO_DATE('"+DTOS(tdENTRA)+"','YYYYMMDD')"
						ELSE
							*datahora entre aspas no formato aaaammdd
							lcHHMMSS = SUBSTR(lcHHMMSS,1,2)+':'+SUBSTR(lcHHMMSS,4,2)+':'+SUBSTR(lcHHMMSS,7,2)
							luSAI = "TO_TIMESTAMP('"+DTOS(tdENTRA)+lcHHMMSS+"','YYYYMMDDHH24:MI:SS')"
						ENDIF

				ENDCASE
			CASE 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= 'SYSDATE'
					CASE tcMODO = 'STRING'
						luSAI = "TO_CHAR("+tdENTRA+",'DD/MM/YYYY')"
					OTHERWISE
						LOCAL lcHHMMSS AS STRING
						lcHHMMSS = TTOC(tdENTRA,2)
						IF TYPE('tdENTRA')='D'
							*data entre aspas no formato aaaammdd
							luSAI = "TO_DATE('"+DTOS(tdENTRA)+"','YYYYMMDD')"
						ELSE
							*datahora entre aspas no formato aaaammdd
							lcHHMMSS = SUBSTR(lcHHMMSS,1,2)+SUBSTR(lcHHMMSS,4,2)+SUBSTR(lcHHMMSS,7,2)
							luSAI = "TO_DATE('"+DTOS(tdENTRA)+lcHHMMSS+"','YYYYMMDDHH24MISS')"
						ENDIF
				ENDCASE
			OTHERWISE
				*SQL SERVER
				*onde: convert(formato,conteudo,nro)
				*ex: convert(datetime,'25/08/2003',103)
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= 'GETDATE()'
					CASE tcMODO = 'STRING'
						luSAI	= "convert(varchar,"+tdENTRA+",103)"
					OTHERWISE
						* MARTELANDO A DATA APENAS ACIMA DE 1900 E MENOR QUE 2079
						LOCAL lnANO, lnMES, lnDIA, lnHORA, lnMINUTO, lnSEGUNDO AS Integer
						LOCAL ldDATA AS Date
						lnANO	= YEAR(tdENTRA)
						lnMES	= MONTH(tdENTRA)
						lnDIA	= DAY(tdENTRA)
						IF lnANO < 1900
							lnANO	= YEAR(DATE())
						ENDIF
						IF lnANO > 2079
							lnANO	= YEAR(DATE())
						ENDIF
						IF TYPE('tdENTRA') = 'T'
							lnHORA		= HOUR(tdENTRA)
							lnMINUTO	= MINUTE(tdENTRA)
							lnSEGUNDO	= SEC(tdENTRA)
						ELSE
							STORE 0 TO lnHORA, lnMINUTO, lnSEGUNDO
						ENDIF
						ldDATA	= STRZERO(lnANO,4) + ;
									STRZERO(lnMES,2) + ;
									STRZERO(lnDIA,2) + ' ' + ;
									STRZERO(lnHORA,2) + ':' +;
									STRZERO(lnMINUTO,2) + ':' +;
									STRZERO(lnSEGUNDO,2)
						luSAI	= "convert(datetime,'"+ ldDATA +"',103)"
				ENDCASE
		ENDCASE
	ENDIF
RETURN(luSAI)

FUNC DATASERVER
***************
* PEGA DATA/HORA DO SERVIDOR
	LOCAL lcALIANT, lcCOMANDO AS String
	LOCAL lcDATAOUT AS Datetime
	STORE '' TO lcALIANT, lcCOMANDO

	lcALIANT	= ALIAS()
	lcCOMANDO	= 'SELECT SYSDATE FROM DUAL'

	DO CASE
		CASE 'MYSQL' $ UPPER(toCONEXAO.DRIVER) &&&  LINHA ALTERADA  &&&
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					NOW() AS SYSDATE
			ENDTEXT

		CASE 'POSTGRES' $ UPPER(toCONEXAO.DRIVER)
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					NOW() AS SYSDATE
			ENDTEXT

		CASE 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					SYSDATE
				FROM
					DUAL
			ENDTEXT

		OTHERWISE
			* MSSQL
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					GETDATE() AS SYSDATE
			ENDTEXT

	ENDCASE

	=PESQUISASQL(lcCOMANDO,'TMPDATSIS')
	lcDATAOUT	= TMPDATSIS.SYSDATE
	USE IN TMPDATSIS

	IF NOT EMPTY(lCALIANT)
		SELE &lcALIANT
	ENDIF

RETURN(lcDATAOUT)

PROC GRAVALOG
*************
PARAMETERS tcACAOLOG, tuPK, tcTABELALOG, tcOBS, tcROTINA,toCONEXAO
	LOCAL lcCAMPOS, lcCONTEUDO, lcCOMANDO AS STRING
	LOCAL lnRESPSQL AS Integer
	lnRESPSQL = -1
	IF TYPE('tuPK')='N'
		tuPK = ALLTRIM(STR(tuPK))
	ENDIF
	
	* Se não passar a conexão deve pegar a conexão padraão ( goCONEXAO1 )
	IF VARTYPE(toCONEXAO) <> 'O'
		toCONEXAO	= goCONEXAO1
	ENDIF
	
	*MONTA COMANDO DE INSERT NO LOG
	lcCAMPOS = "FK_USUARIO," + ;
				" DH_LOG,"+;
				" DS_ROTINA," + ;
				" TG_ACAO," + ;
				" DS_OBJETOPK," + ;
				" DS_TABELA," + ;
				" DS_OBS"
	lcCONTEUDO = XX(0)+;
				", "+D2SQL(DATE(),'HOJE')+;
				", "+XX(UPPER(tcROTINA))+;
				", "+XX(tcACAOLOG) + ;
				", "+XX(tuPK) + ;
				", "+XX(tcTABELALOG) + ;
				", "+XX(tcOBS)
	lcCOMANDO = 'INSERT INTO TS_LOGS ('+lcCAMPOS+') VALUES ('+lcCONTEUDO+')'

	lnRESPSQL = SQLEXEC(toCONEXAO.ALCA,lcCOMANDO)
	IF lnRESPSQL<0 
		*COMANDO NÃO FOI BEM SUCEDIDO (ERRO DE SINTAXE SQL)
		_CLIPTEXT = lcCOMANDO
		DO MENS WITH 'Erro para incluir registro de log.'
		RETURN
	ENDIF
RETURN

PROC MONTASQLC
LPARAMETERS toCONEXAO
*******************
* MONTA COMANDO DE ACORDO COM A ACAO EXECUTADA NA BASE LOCAL
* OBS: A ACAO É EFETUADA NO DBF (CURSOR LOCAL) E DEPOIS PRECISA QUE SEJA ATUALIZADA
* ---- A BASE SQL. ASSIM ESTE COMANDO É MONTADO PARA SER EXECUTADO E EFETUAR ESTA TAREFA
	IF VARTYPE(toCONEXAO) <> 'O'
		RETURN
	ENDIF	
	
	*CONDICAO
	LOCAL lcSQLCONDI AS String
	lcSQLCONDI = " WHERE PK_ID="+XX(luPK_ID,'',toCONEXAO)

	* MONTA NOME DA TABELA NO SQL
	IF tcTABELA = 'TMP'
		RETURN
	ENDIF

*!*		* MONTANDO O CÓDIGO DE ESTOQUE PARA A TABELA DE ES_MOVIMENTOS NA INCLUSÃO
*!*		IF tcACTION	= 'A' AND tcTABELA $ ',ES_MOVIMENTOS,VD_RESERVAS,'
*!*			IF TYPE('FK_EMPRESA')='C' AND TYPE('FK_ESTOQUE')='C'
*!*				IF EMPTY(FK_ESTOQUE) AND NOT EMPTY(FK_EMPRESA)
*!*					LOCAL lnQTDEMP AS Integer
*!*					LOCAL lcAUXEMP AS String
*!*					FOR lnQTDEMP = 1 TO MEMLINES(goAPLICATIVO.EMPXEST)
*!*						lcAUXEMP = MLINE(goAPLICATIVO.EMPXEST,lnQTDEMP)
*!*						IF FK_EMPRESA = LEFT(lcAUXEMP,3)
*!*							REPLACE FK_ESTOQUE WITH SUBS(lcAUXEMP,5)
*!*						ENDIF
*!*					ENDFOR
*!*				ENDIF
*!*			ENDIF
*!*		ENDIF

	* MONTA SINTAXE DE CADA COMANDO, DEPENDENDO DA AÇÃO
	LOCAL lnORIGEM, lcCPOORIGEM, lcCOMANDO, lcCPOAUX AS String
	STORE '' TO lnORIGEM, lcCPOORIGEM, lcCPOAUX

	* VARIAVEIS DE ATUALIZAÇÃO DE ESTOQUE
	LOCAL llresBXATU AS Logical
	LOCAL lcestCOMANDO, lcestTABANT, lcestTGES AS String
	STORE .F. TO llresBXATU
	STORE '' TO lcestCOMANDO, lcestTABANT, lcestTGES

	lcCPOAUX = ''
	DO CASE
		CASE tcACTION = 'D'
			* DELETAR REGISTRO (DELETE)
			lcATUSQL = 'DELETE FROM '+tcTABELA+lcSQLCONDI

			* GRAVANDO ESPELHO DO REGISTRO
			lcCOMANDO = 'SELECT * FROM '+tcTABELA+lcSQLCONDI
*			pcSINTAXELIXEIRA = MONTALIXEIRA( lcCOMANDO, tcTABELA, luPK_ID )

*!*				* CONTROLE DE ATUALIZAÇÃO DE ESTOQUE E CONSIGNAÇÃO
*!*				IF tcTABELA = 'ES_MOVIMENTOS'
*!*					lcestTABANT		= ALIAS()
*!*					TEXT TO lcestCOMANDO NOSHOW PRETEXT 7
*!*						SELECT
*!*							*
*!*						FROM
*!*							ES_MOVIMENTOS
*!*						<<CONDICAO>>
*!*					ENDTEXT
*!*					lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<TABELA>>',tcTABELA)
*!*					lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<CONDICAO>>',lcSQLCONDI)
*!*					=PESQUISASQL(lcestCOMANDO,'TMPESTAUX')
*!*					SELE TMPESTAUX

*!*					* ATUALIZAÇÃO DA QTD ON-LINE
*!*					poESTOQUE.FK_PROATU		= TMPESTAUX.FK_PRODUTO
*!*					poESTOQUE.FK_ESTATU		= TMPESTAUX.FK_ESTOQUE
*!*					poESTOQUE.TG_ESTATU		= TMPESTAUX.TG_ESTOQUE
*!*					poESTOQUE.TG_ORIATU		= TMPESTAUX.TG_ORIGEM
*!*					* CONTROLE DE ESTOQUE POR COR E TAMANHO
*!*					IF TYPE('TMPESTAUX.FK_COR') = 'C'
*!*						poESTOQUE.FK_CORATU	= TMPESTAUX.FK_COR
*!*						poESTOQUE.FK_TAMATU	= TMPESTAUX.FK_TAMANHO
*!*					ENDIF
*!*					* CONTROLE DE PENDÊNCIAS
*!*					IF TYPE('TMPESTAUX.TG_PENDENTE') = 'N'
*!*						poESTOQUE.TG_PENATU	= TMPESTAUX.TG_PENDENTE
*!*						poESTOQUE.TG_PENTEM	= 1
*!*					ENDIF
*!*					poESTOQUE.QT_ESTATU		= ABS( TMPESTAUX.QT_MOVIMENTO )
*!*					IF TMPESTAUX.TG_ES = 'E'
*!*						poESTOQUE.QT_ESTATU	= 0 - poESTOQUE.QT_ESTATU
*!*					ENDIF
*!*					* ATUALIZAÇÃO DA QTD DE CONSIGNAÇÃO
*!*					poESTOQUE.TG_CONATU		= TMPESTAUX.TG_CONSIGNA

*!*					USE IN TMPESTAUX
*!*					IF NOT EMPTY(lcestTABANT)
*!*						SELE (lcestTABANT)
*!*					ENDIF
*!*				ENDIF

*!*				* CONTROLE DE RESERVA DE PRODUTOS
*!*				IF tcTABELA = 'VD_RESERVAS'
*!*					lcestTABANT		= ALIAS()
*!*					TEXT TO lcestCOMANDO NOSHOW PRETEXT 7
*!*						SELECT
*!*							FK_PRODUTO,
*!*							QT_RESERVA,
*!*							TG_RESERVA,
*!*							FK_ESTOQUE,
*!*							DT_BAIXA
*!*						FROM
*!*							<<TABELA>>
*!*							<<CONDICAO>>
*!*					ENDTEXT
*!*					lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<TABELA>>',tcTABELA)
*!*					lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<CONDICAO>>',lcSQLCONDI)
*!*					=PESQUISASQL(lcestCOMANDO,'TMPESTAUX')
*!*					SELE TMPESTAUX
*!*					poRESERVA.TG_RESANT	= TMPESTAUX.TG_RESERVA
*!*					poRESERVA.FK_PROANT	= TMPESTAUX.FK_PRODUTO
*!*					poRESERVA.FK_ESTANT	= TMPESTAUX.FK_ESTOQUE
*!*					poRESERVA.QT_RESANT	= 0 - ABS( TMPESTAUX.QT_RESERVA )
*!*					IF NOT ISNULL(TMPESTAUX.DT_BAIXA)
*!*						poRESERVA.QT_RESANT	= 0
*!*					ENDIF
*!*					USE IN TMPESTAUX
*!*					IF NOT EMPTY(lcestTABANT)
*!*						SELE (lcestTABANT)
*!*					ENDIF
*!*				ENDIF

		CASE tcACTION = 'A'
			* INCLUIR REGISTRO (INSERT)
			WQF = AFIELDS(WTABF)
			STORE '' TO lcINSERE1, lcINSERE2
			FOR WXC = 1 TO WQF
				lcCPOAUX = ALLTRIM(WTABF[WXC,1])
				IF lcCPOAUX = 'PK_ID' AND pnAUTOINC=1
					* CAMPO IDENTITY
					LOOP
				ENDIF
				IF lcCPOAUX = 'DH_ALTERACAO'
					LOOP
				ENDIF
				IF lcCPOAUX = 'ROWGUID' OR lcCPOAUX = 'MSREPL_TRAN_VERSION'
					LOOP
				ENDIF
				IF lnUPDATE=1
					IF VIRGULAR(lcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO A SER IGNORADO
						LOOP
					ENDIF
				ENDIF
				IF lnUPDATE=2
					IF NOT VIRGULAR(lcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO QUE NÃO FAZ PARTE DA RELAÇÃO
						LOOP
					ENDIF
				ENDIF
				IF EMPTY(lcINSERE1)
					lcSEPARA = ''
				ELSE
					lcSEPARA = ', '
				ENDIF

				lcCONTEUDO = XX( &lcCPOAUX,'',toCONEXAO )
				IF lcCPOAUX = 'DH_INCLUSAO'
					lcCONTEUDO = D2SQL(DATE(),'HOJE',toCONEXAO)
				ENDIF

				IF lcCPOAUX = 'FK_OWNER'
					*lcCONTEUDO = XX(toCONEXAO.FK_USUARIO)
					lcCONTEUDO = XX(0,'',toCONEXAO)
				ENDIF
				IF '_KK' $ lcCPOAUX
					* CAMPO DE CONTROLE (NUNCA É FEITO UPDATE POR ESTA ROTINA
					lcTIPO	= TYPE(lcCPOAUX)
					DO CASE
						CASE lcTIPO $ 'CM'
							lcCONTEUDO = XX('','',toCONEXAO)
						CASE lcTIPO = 'N'
							lcCONTEUDO = XX(0,'',toCONEXAO)
					ENDCASE
				ENDIF

				lcINSERE1 = lcINSERE1 + lcSEPARA + lcCPOAUX
				lcINSERE2 = lcINSERE2 + lcSEPARA + lcCONTEUDO

*!*					* CONTROLE DE ATUALIZAÇÃO DE ESTOQUE E CONSIGNACAO
*!*					IF tcTABELA = 'ES_MOVIMENTOS'
*!*						IF lcCPOAUX	== 'QT_MOVIMENTO'
*!*							poESTOQUE.QT_ESTATU	= &lcCONTEUDO
*!*						ENDIF
*!*						IF lcCPOAUX	== 'TG_ES'
*!*							lcestTGES			= &lcCONTEUDO
*!*						ENDIF
*!*						IF lcCPOAUX	== 'FK_ESTOQUE'
*!*							poESTOQUE.FK_ESTATU	= &lcCONTEUDO
*!*						ENDIF
*!*						* ATUALIZAÇÃO DE ESTOQUE
*!*						IF lcCPOAUX	== 'FK_PRODUTO'
*!*							poESTOQUE.FK_PROATU	= &lcCONTEUDO
*!*						ENDIF
*!*						IF lcCPOAUX	== 'TG_ESTOQUE'
*!*							poESTOQUE.TG_ESTATU	= &lcCONTEUDO
*!*						ENDIF
*!*						* ATUALIZAÇÃO DE QTDE DE NOTA (E/S)
*!*						IF lcCPOAUX	== 'TG_ORIGEM'
*!*							poESTOQUE.TG_ORIATU	= &lcCONTEUDO
*!*						ENDIF
*!*						* CONTROLE DE ESTOQUE POR COR E TAMANHO
*!*						IF lcCPOAUX	== 'FK_COR'
*!*							poESTOQUE.FK_CORATU	= &lcCONTEUDO
*!*						ENDIF
*!*						IF lcCPOAUX	== 'FK_TAMANHO'
*!*							poESTOQUE.FK_TAMATU	= &lcCONTEUDO
*!*						ENDIF
*!*						* CONTROLE DE PENDENCIA
*!*						IF lcCPOAUX	== 'TG_PENDENTE'
*!*							poESTOQUE.TG_PENATU	= &lcCONTEUDO
*!*						ENDIF
*!*						* CONSIGNAÇÃO DE PRODUTOS
*!*						IF lcCPOAUX	== 'TG_CONSIGNA'
*!*							poESTOQUE.TG_CONATU	= &lcCONTEUDO
*!*						ENDIF
*!*					ENDIF
*!*					* CONTROLE DE RESERVA DE PRODUTOS
*!*					IF tcTABELA	= 'VD_RESERVAS'
*!*						IF lcCPOAUX	== 'FK_PRODUTO'
*!*							poRESERVA.FK_PROATU	= &lcCONTEUDO
*!*						ENDIF
*!*						IF lcCPOAUX	== 'FK_ESTOQUE'
*!*							poRESERVA.FK_ESTATU	= &lcCONTEUDO
*!*						ENDIF
*!*						IF lcCPOAUX	== 'TG_RESERVA'
*!*							poRESERVA.TG_RESATU	= &lcCONTEUDO
*!*						ENDIF
*!*						IF lcCPOAUX	== 'QT_RESERVA'
*!*							poRESERVA.QT_RESATU	= &lcCONTEUDO
*!*							poRESERVA.QT_RESATU	= ABS( poRESERVA.QT_RESATU )
*!*						ENDIF
*!*						IF lcCPOAUX	== 'DT_BAIXA'
*!*							IF NOT 'NULL' $ UPPER(lcCONTEUDO)
*!*								llresBXATU	= .T.
*!*							ENDIF
*!*						ENDIF
*!*					ENDIF
			ENDFOR

			IF pnAUTOINC=1 AND 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
				lcINSERE1	= 'PK_ID, ' + lcINSERE1
				lcINSERE2	= tcTABELA + '_S.NEXTVAL, ' + lcINSERE2
			ENDIF

			lcATUSQL = 'INSERT INTO '+tcTABELA+' ('+lcINSERE1+') VALUES ('+lcINSERE2+')'

			* CONTROLE DE ATUALIZAÇÃO DE ESTOQUE E CONSIGNAÇÃO
			IF tcTABELA = 'ES_MOVIMENTOS'
				lcestTABANT		= ALIAS()
				TEXT TO lcestCOMANDO NOSHOW PRETEXT 7
					SELECT
						*
					FROM
						ES_MOVIMENTOS
					WHERE
						PK_ID IS NULL
				ENDTEXT
				=PESQUISASQL(lcestCOMANDO,'TMPESTAUX')
				SELE TMPESTAUX
				* CONTROLE DE PENDÊNCIAS
				IF TYPE('TMPESTAUX.TG_PENDENTE') = 'N'
					poESTOQUE.TG_PENTEM	= 1
				ENDIF

				* QTDE ESTOQUE
				poESTOQUE.QT_ESTATU		= ABS(poESTOQUE.QT_ESTATU)
				IF lcestTGES <> 'E'
					poESTOQUE.QT_ESTATU	= 0 - poESTOQUE.QT_ESTATU
				ENDIF

				* NOTA FISCAL DE SAÍDA COM TIPO 'ENTRADA'
				* NÃO PODE ATUALIZAR ESTOQUE DE FATURA
				IF poESTOQUE.TG_ORIATU = 'N' AND lcestTGES = 'E'
					poESTOQUE.TG_ORIATU	= ''
				ENDIF

				USE IN TMPESTAUX
				IF NOT EMPTY(lcestTABANT)
					SELE (lcestTABANT)
				ENDIF

			ENDIF
			* CONTROLE DE RESERVA DE PRODUTOS
			IF llresBXATU
				poRESERVA.QT_RESATU	= 0
			ENDIF

		CASE tcACTION = 'M'
			* ALTERAR REGISTRO (UPDATE)
			LOCAL lcCAMPOSUP AS STRING
			WQF = AFIELDS(WTABF)
			lcCAMPOSUP = ''
			STORE '' TO lcINSERE1, lcINSERE2
			FOR WXC = 1 TO WQF 
				lcCPOAUX = ALLTRIM(WTABF[WXC,1])
				IF lcCPOAUX = 'PK_ID'
					* CAMPO IDENTITY
					LOOP
				ENDIF
				IF lcCPOAUX = 'DH_INCLUSAO'
					LOOP
				ENDIF
				IF lcCPOAUX = 'ROWGUID' OR lcCPOAUX = 'MSREPL_TRAN_VERSION'
					LOOP
				ENDIF
				IF lnUPDATE=1
					IF VIRGULAR(lcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO A SER IGNORADO
						LOOP
					ENDIF
				ENDIF
				IF lnUPDATE=2
					IF NOT VIRGULAR(lcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO QUE NÃO FAZ PARTE DA RELAÇÃO
						LOOP
					ENDIF
				ENDIF
				IF '_KK' $ lcCPOAUX
					* CAMPO DE CONTROLE (NUNCA É FEITO UPDATE POR ESTA ROTINA
					LOOP
				ENDIF
				IF EMPTY(lcCAMPOSUP)
					lcSEPARA = ''
				ELSE
					lcSEPARA = ', '
				ENDIF

				lcCONTEUDO = XX( &lcCPOAUX ,'',toCONEXAO)
				IF lcCPOAUX = 'DH_ALTERACAO'
					lcCONTEUDO = D2SQL(DATE(),'HOJE',toCONEXAO)
				ENDIF

				lcCAMPOSUP = lcCAMPOSUP + lcSEPARA + lcCPOAUX + "="+lcCONTEUDO

				* CONTROLE DE ATUALIZAÇÃO DE ESTOQUE E CONSIGNACAO
				IF tcTABELA = 'ES_MOVIMENTOS'
					IF lcCPOAUX	== 'QT_MOVIMENTO'
						poESTOQUE.QT_ESTATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'TG_ES'
						lcestTGES			= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'FK_ESTOQUE'
						poESTOQUE.FK_ESTATU	= &lcCONTEUDO
					ENDIF
					* ATUALIZAÇÃO DE ESTOQUE
					IF lcCPOAUX	== 'FK_PRODUTO'
						poESTOQUE.FK_PROATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'TG_ESTOQUE'
						poESTOQUE.TG_ESTATU	= &lcCONTEUDO
					ENDIF
					* ATUALIZAÇÃO DE QTDE DE NOTA (E/S)
					IF lcCPOAUX	== 'TG_ORIGEM'
						poESTOQUE.TG_ORIATU	= &lcCONTEUDO
					ENDIF
					* CONTROLE DE ESTOQUE POR COR E TAMANHO
					IF lcCPOAUX	== 'FK_COR'
						poESTOQUE.FK_CORATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'FK_TAMANHO'
						poESTOQUE.FK_TAMATU	= &lcCONTEUDO
					ENDIF
					* CONTROLE DE PENDENCIA
					IF lcCPOAUX	== 'TG_PENDENTE'
						poESTOQUE.TG_PENATU	= &lcCONTEUDO
					ENDIF
					* CONSIGNAÇÃO DE PRODUTOS
					IF lcCPOAUX	== 'TG_CONSIGNA'
						poESTOQUE.TG_CONATU	= &lcCONTEUDO
					ENDIF
				ENDIF
				* CONTROLE DE RESERVA DE PRODUTOS
				IF tcTABELA	= 'VD_RESERVAS'
					IF lcCPOAUX	== 'FK_PRODUTO'
						poRESERVA.FK_PROATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'FK_ESTOQUE'
						poRESERVA.FK_ESTATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'TG_RESERVA'
						poRESERVA.TG_RESATU	= &lcCONTEUDO
					ENDIF
					IF lcCPOAUX	== 'QT_RESERVA'
						poRESERVA.QT_RESATU	= &lcCONTEUDO
						poRESERVA.QT_RESATU	= ABS( poRESERVA.QT_RESATU )
					ENDIF
					IF lcCPOAUX	== 'DT_BAIXA'
						IF NOT 'NULL' $ UPPER(lcCONTEUDO)
							llresBXATU	= .T.
						ENDIF
					ENDIF
				ENDIF
			ENDFOR

			lcATUSQL = 'UPDATE '+tcTABELA+' SET '+ lcCAMPOSUP + lcSQLCONDI

			* CONTROLE DE ATUALIZAÇÃO DE ESTOQUE E CONSIGNAÇÃO
			IF tcTABELA = 'ES_MOVIMENTOS'
				lcestTABANT		= ALIAS()
				TEXT TO lcestCOMANDO NOSHOW PRETEXT 7
					SELECT
						*
					FROM
						ES_MOVIMENTOS
					<<CONDICAO>>
				ENDTEXT
				lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<TABELA>>',tcTABELA)
				lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<CONDICAO>>',lcSQLCONDI)
				=PESQUISASQL(lcestCOMANDO,'TMPESTAUX')
				SELE TMPESTAUX
				* QTDE ON-LINE
				poESTOQUE.FK_PROANT		= TMPESTAUX.FK_PRODUTO
				poESTOQUE.FK_ESTANT		= TMPESTAUX.FK_ESTOQUE
				poESTOQUE.TG_ESTANT		= TMPESTAUX.TG_ESTOQUE
				poESTOQUE.TG_ORIANT		= TMPESTAUX.TG_ORIGEM
				* CONTROLE DE ESTOQUE POR COR E TAMANHO
				IF TYPE('TMPESTAUX.FK_COR') = 'C'
					poESTOQUE.FK_CORANT	= TMPESTAUX.FK_COR
					poESTOQUE.FK_TAMANT	= TMPESTAUX.FK_TAMANHO
				ENDIF
				* CONTROLE DE PENDÊNCIAS
				IF TYPE('TMPESTAUX.TG_PENDENTE') = 'N'
					poESTOQUE.TG_PENANT	= TMPESTAUX.TG_PENDENTE
					poESTOQUE.TG_PENTEM	= 1
				ENDIF
				poESTOQUE.QT_ESTANT		= ABS( TMPESTAUX.QT_MOVIMENTO )
				IF TMPESTAUX.TG_ES <> 'E'
					poESTOQUE.QT_ESTANT	= 0 - poESTOQUE.QT_ESTANT
				ENDIF
				poESTOQUE.QT_ESTATU		= ABS(poESTOQUE.QT_ESTATU)
				IF lcestTGES <> 'E'
					poESTOQUE.QT_ESTATU	= 0 - poESTOQUE.QT_ESTATU
				ENDIF
				* CONSIGNAÇÃO
				poESTOQUE.TG_CONANT		= TMPESTAUX.TG_CONSIGNA

				* NOTA FISCAL DE SAÍDA COM TIPO 'ENTRADA'
				* NÃO PODE ATUALIZAR ESTOQUE DE FATURA
				IF poESTOQUE.TG_ORIATU = 'N' AND lcestTGES = 'E'
					poESTOQUE.TG_ORIATU	= ''
				ENDIF
				IF poESTOQUE.TG_ORIANT = 'N' AND TMPESTAUX.TG_ES = 'E'
					poESTOQUE.TG_ORIANT	= ''
				ENDIF

				USE IN TMPESTAUX
				IF NOT EMPTY(lcestTABANT)
					SELE (lcestTABANT)
				ENDIF

			ENDIF

			* CONTROLE DE RESERVA DE PRODUTOS
			IF tcTABELA = 'VD_RESERVAS'
				IF llresBXATU
					poRESERVA.QT_RESATU	= 0
				ENDIF
				lcestTABANT		= ALIAS()
				TEXT TO lcestCOMANDO NOSHOW PRETEXT 7
					SELECT
						FK_PRODUTO,
						QT_RESERVA,
						FK_ESTOQUE,
						TG_RESERVA,
						DT_BAIXA
					FROM
						<<TABELA>>
						<<CONDICAO>>
				ENDTEXT
				lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<TABELA>>',tcTABELA)
				lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<CONDICAO>>',lcSQLCONDI)
				=PESQUISASQL(lcestCOMANDO,'TMPESTAUX')
				SELE TMPESTAUX
				poRESERVA.TG_RESANT	= TMPESTAUX.TG_RESERVA
				poRESERVA.FK_PROANT	= TMPESTAUX.FK_PRODUTO
				poRESERVA.FK_ESTANT	= TMPESTAUX.FK_ESTOQUE
				poRESERVA.QT_RESANT	= 0 - ABS( TMPESTAUX.QT_RESERVA )
				IF NOT ISNULL(TMPESTAUX.DT_BAIXA)
					poRESERVA.QT_RESANT	= 0
				ENDIF
				USE IN TMPESTAUX
				IF NOT EMPTY(lcestTABANT)
					SELE (lcestTABANT)
				ENDIF
			ENDIF

	ENDCASE
RETURN


FUNC STRZERO
************
LPARAMETERS tnVALOR,tnTAM
	LOCAL lcOUT AS STRING
	lcOUT = STR(tnVALOR,tnTAM)
	lcOUT = STRTRAN(lcOUT," ","0")
RETU(lcOUT)

FUNC VIRGULAR
*************
PARAMETERS tcVIRGULAR
	IF TYPE('tcVIRGULAR')='N'
		tcVIRGULAR = ALLTRIM(STR(tcVIRGULAR))
	ENDIF
	LOCAL lcVIRGULAR as String
	lcVIRGULAR = ','+tcVIRGULAR+','
RETURN(lcvirgular)

PROC PEGAULTINC
***************
LPARAMETERS tcTABELA AS String
	IF TYPE('tcTABELA') <> 'C'
		tcTABELA	= ''
	ENDIF
	IF EMPTY(tcTABELA)
		RETURN
	ENDIF
	DO CASE
		CASE 'MYSQL' $ UPPER(toCONEXAO.DRIVER) &&&  LINHA ALTERADA  &&&
			lcCMDIDENTITY	= 'SELECT MAX(PK_ID) ULTIMAINC FROM '+tcTABELA 
		CASE 'POSTGRES' $ UPPER(toCONEXAO.DRIVER)
			lcCMDIDENTITY	= "SELECT CURRVAL('"+tcTABELA+"_S'::text) AS ULTIMAINC" &&tcSEQUENCIA
		CASE 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
			lcCMDIDENTITY	= 'SELECT '+tcTABELA+'_S.CURRVAL AS ULTIMAINC FROM DUAL'
		OTHERWISE
			*SQL SERVER
			lcCMDIDENTITY	= 'SELECT SCOPE_IDENTITY() AS ULTIMAINC'
	ENDCASE
	lnRESPIDENTITY	= SQLEXEC(toCONEXAO.ALCA,lcCMDIDENTITY,'TMPLASTPK')

	lcMOTIVO = ''
	IF lnRESPIDENTITY<0
		lcMOTIVO = 'EXEC-SQL'
	ENDIF
	IF TYPE('ULTIMAINC')<>'N'
		lcMOTIVO = 'SEM PK_ID'
	ENDIF
	IF ULTIMAINC<=0
		lcMOTIVO = 'PK_ID SEM CONTEUDO'
	ENDIF
	IF NOT EMPTY(lcMOTIVO)
		DO MENS WITH 'ERRO NA INCLUSÃO (P/RETORNAR PK_ID): '+lcMOTIVO+' ATUSQL'
	ELSE
		*RETORNA ULTIMA INSERÇÃO
		lnIDENTITY = ULTIMAINC
	ENDIF
	USE IN TMPLASTPK
RETURN



FUNC EXECUTASQL
****************
PARAMETERS tcSINTAXE,toCONEXAO
	LOCAL lnSQLOK, lnRESP AS Integer
	LOCAL lcRESP AS String
	LOCAL ARRAY laERRO[1]
	
	* Se não passar a conexão deve pegar a conexão padraão ( goCONEXAO1 )
	IF VARTYPE(toCONEXAO) <> 'O'
		toCONEXAO	= goCONEXAO1
	ENDIF
	
	IF toCONEXAO.ALCA<=0
		RETURN
	ENDIF
	
	
	* TRATAMENTOS ESPECIAIS DE SINTAXE
	DO CASE
		CASE 'POSTGRES' $ UPPER(toCONEXAO.DRIVER)
			tcSINTAXE = TRTSINPGSQL(tcSINTAXE)
			tcSINTAXE = TRTFUNPGSQL(tcSINTAXE)
		CASE 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
			tcSINTAXE = TRATASQLORACLE(tcSINTAXE)
		OTHERWISE
			tcSINTAXE = TRATASQLMSSQL(tcSINTAXE)
	ENDCASE

	toCONEXAO.LASTCOMMAND   = tcSINTAXE
	toCONEXAO.LASTCURSOR    = ''
	* EXECUTA COMANDO NA BASE
	lnSQLOK = SQLEXEC(toCONEXAO.ALCA,tcSINTAXE)
	
	IF NOT goAPLICATIVO.TESTE AND lnSQLOK<0
		=AERROR(laERRO)
*!*			* CASO SEJA ERRO DE CONEXÃO
*!*			IF VERERROCONEXAO(laERRO[4], laERRO[5])
*!*				* DO FORM SYSTEM_ERROCONEXAO
*!*				* SE OPTOU POR RECONECTAR, TENTA REPETIR A QUERY
*!*				lnSQLOK = REPETIRQUERY()
*!*			ENDIF
	ENDIF
	toCONEXAO.LASTCOMMAND   = ''
	toCONEXAO.LASTCURSOR    = ''

	IF lnSQLOK<0
		=AERROR(laERRO)
		lcNUMERRO	= ALLTRIM(STR(laERRO(1)))
		lcERRO		= laERRO(3)

		IF NOT goAPLICATIVO.TESTE
			DO ROTERRO WITH 0-laERRO(1), lcERRO, SYS(16), 0
		ELSE
			lnRESP	= MESSAGEBOX('ERRO NO ACESSO À BASE DE DADOS: ' + CHR(13)+CHR(10)+;
									SYS(16)+CHR(13)+CHR(10)+;
									lcNUMERRO+CHR(13)+CHR(10)+;
									lcERRO,'AVISO: SQL-ERRO',48+2+256)
			IF lnRESP = 3
				_CLIPTEXT	= tcSINTAXE
				DEBUG
				SUSP
			ENDIF
			IF lnRESP = 4
				_CLIPTEXT = tcSINTAXE
			ENDIF
		ENDIF
	ENDIF
RETURN(lnSQLOK)

PROC ESPERANDO
**************
LPARAMETER tcMESS AS String
	WAIT WINDOW tcMESS NOWAIT NOCLEAR
	
*!*		IF TYPE('_screen.osTATUSBAR')='O'
*!*			_screen.osTATUSBAR.paNELMESSAGE.ctlcaption=tcMESS
*!*			_screen.osTATUSBAR.proGRESSBAR.ctlmarquee=.t.
*!*			_screen.osTATUSBAR.proGRESSBAR.ctlvisible=.t.
*!*		ENDIF
RETURN

PROC POEIMG
***********
LPARAMETERS par1,par2,par3,par4,par5
	RETURN .T.
ENDPROC

PROC VDIREITOS
**************
LPARAMETERS par1,par2,par3,par4,par5
	RETURN .T.
ENDPROC

PROC VERERROCONSTRAINT
***********************
* VERIFICA SE ERRO FOI OCASIONADO DEVIDO A CONSTRAINT DE DEPÊNDENCIA, REGISTROS PAIS COM FILHOS
* RETORNA .T. SE É UM ERRO DE CONSTRAINT
LPARAMETERS taERRO

	LOCAL llRETORNO AS Logical
	STORE .F. TO llRETORNO

	LOCAL lvITEM1, lvITEM2, lvITEM3, lvITEM4, lvITEM5 AS Variant
	STORE '' TO lvITEM1, lvITEM2, lvITEM3, lvITEM4, lvITEM5 
	
	lvITEM1 = EVALUATE('taERRO[1]')
	lvITEM2 = EVALUATE('taERRO[2]')
	lvITEM3 = EVALUATE('taERRO[3]')
	lvITEM4 = EVALUATE('taERRO[4]')
	lvITEM5 = EVALUATE('taERRO[5]')
	
	DO CASE

		CASE 'POSTGRES' $ UPPER(toCONEXAO.DRIVER)
			IF lvITEM4 == 'HY000' AND 'UPDATE' $ UPPER(lvITEM2) AND 'DELETE' $ UPPER(lvITEM2) AND 'VIOLATES FOREIGN KEY CONSTRAINT' $ UPPER(lvITEM2)
				llRETORNO = .T.
			ENDIF

		CASE 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
			IF lvITEM1 = 1526 AND lvITEM5 = 2292
				llRETORNO = .T.
			ENDIF
		
		CASE 'SQL SERVER' $ UPPER(UPPER(toCONEXAO.DRIVER))
			IF lvITEM1 = 1526 AND lvITEM4 == '23000' AND lvITEM5 = 547
				llRETORNO = .T.
			ENDIF
	ENDCASE
RETURN(llRETORNO)

PROC DELETAR
************
LPARAMETERS tcTABELA, tcALIAS, toCONEXAO
	IF TYPE('tcTABELA') <> 'C'
		DO MENS WITH 'Exclusão negada-(Tabela não informada)'
		RETURN(.F.)
	ENDIF
	IF EMPTY(tcTABELA)
		DO MENS WITH 'Exclusão negada-(Tabela não informada)'
		RETURN(.F.)
	ENDIF
	IF TYPE('tcALIAS') <> 'C'
		DO MENS WITH 'Exclusão negada-(Tabela não informada)'
		RETURN(.F.)
	ENDIF
	IF EMPTY(tcALIAS)
		DO MENS WITH 'Exclusão negada-(Tabela não informada)'
		RETURN(.F.)
	ENDIF
	SELE (tcALIAS)
	IF NOT TYPE('PK_ID') $ 'CN'
		DO MENS WITH 'Exclusão negada-(Pk ausente)'
		RETURN(.F.)
	ENDIF
	IF EMPTY(PK_ID)
		DO MENS WITH 'Exclusão negada-(Pk sem informação)'
		RETURN(.F.)
	ENDIF
	
	LOCAL lcCOMANDO, lcTABSQL, lcLETRA, lcLIXEIRA AS String
	LOCAL lnDELETOU, lnXI AS Integer
	LOCAL luPK
	STORE '' TO lcCOMANDO, lcTABSQL, lcLETRA

	FOR lnXI = 1 TO LEN(tcTABELA)
		lcLETRA = SUBSTR(tcTABELA,lnXI,1)
		IF EMPTY(lcLETRA)
			EXIT
		ENDIF
		lcTABSQL = lcTABSQL + lcLETRA
	ENDFOR

	luPK	= PK_ID
	* LIXEIRA
	lcCOMANDO = "SELECT * FROM " + ALLTRIM(lcTABSQL) + ;
				" WHERE PK_ID="+XX(PK_ID,'',toCONEXAO)
	=PESQUISASQL(lcCOMANDO,'TMPSISDELETAR',toCONEXAO)

	lnDELETOU = ATUSQL( 'D', lcTABSQL,'','',toCONEXAO )
	SELE TMPSISDELETAR
	IF TYPE('lnDELETOU') = TYPE('PK_ID')
		IF NOT EMPTY( lnDELETOU )
			* GRAVANDO LOG DA OPERAÇÃO
			* NO CASO DE FUNÇÕES QUE ESTÃO NO MENURAIZ A STACK DE PROCESSOS NÃO AS ARMAZENA
			LOCAL ARRAY laPROGRAMAS[1]
			LOCAL lnQTDPROGRAMAS, lnXI AS Integer
			LOCAL lcNOMEROTINA, lcLETRA AS String
			STORE '' TO lcNOMEROTINA, lcLETRA
			lnQTDPROGRAMAS = ASTACKINFO(laPROGRAMAS)
			FOR lnXI = 1 TO LEN(laPROGRAMAS[lnQTDPROGRAMAS-1,3])
				lcLETRA = SUBSTR(laPROGRAMAS[lnQTDPROGRAMAS-1,3],lnXI,1)
				IF lcLETRA = '.'
					EXIT
				ENDIF
				lcNOMEROTINA = lcNOMEROTINA + lcLETRA
			ENDFOR
			*DO GRAVALOG WITH 'D', PK_ID, lcTABSQL, '', lcNOMEROTINA
			DELETE

			* APAGANDO TEXTO ANEXO, SE TIVER
			IF TYPE('luPK') = 'C'
				luPK	= XX(luPK,'',toCONEXAO)
			ELSE
				luPK	= XX(STR(luPK),20,toCONEXAO)
			ENDIF
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				DELETE FROM TS_TEXTOS
				WHERE
					FK_ORIGEM = <<PK_ID>>
					AND DS_TABELA = <<TABELA>>
			ENDTEXT
			lcCOMANDO = STRTRAN(lcCOMANDO,'<<TABELA>>',XX(lcTABSQL,'',toCONEXAO))
			lcCOMANDO = STRTRAN(lcCOMANDO,'<<PK_ID>>',luPK)
			=EXECUTASQL(lcCOMANDO)

			* DELETANDO IMAGEM, SE TIVER
			LOCAL lcIMAGEMBD, lcSQL, lcARQUIVO, lcPK_ID AS String
			LOCAL llERRO AS Logical
			STORE .F. TO llERRO
			
			*lcIMAGEMBD = ALLTRIM(RETORNASET('IMAGEM.BD','C',1))

			IF VARTYPE(lcIMAGEMBD) <> 'C'
				lcIMAGEMBD = 'OFF'
			ENDIF

			IF VARTYPE(PK_ID) = 'N'
				lcPK_ID = ALLTRIM(STR(PK_ID))
			ELSE
				lcPK_ID = ALLTRIM(PK_ID)
			ENDIF
			
			IF lcIMAGEMBD == 'ON'
			* IMAGEM GRAVADA DENTRO DO BANCO DE DADOS
				TEXT TO lcSQL NOSHOW PRETEXT 7
					SELECT
						PK_ID,
						DS_TABELA,
						FK_ORIGEM
					FROM
						TS_IMAGENS
					WHERE
						FK_ORIGEM = '[[FK_ORIGEM]]'
					AND
						DS_TABELA = '[[DS_TABELA]]'
				ENDTEXT
				lcSQL = STRTRAN(lcSQL,'[[FK_ORIGEM]]',lcPK_ID)
				lcSQL = STRTRAN(lcSQL,'[[DS_TABELA]]',lcTABSQL)
				PESQUISASQL(lcSQL,'TMPIMG')
				
				SELE TMPIMG
				GO TOP
				
				IF RECCOUNT() > 0
					SCAN WHILE NOT EOF()
						DO ATUSQL WITH 'D', 'TS_IMAGENS','','',toCONEXAO
					ENDSCAN
				ENDIF
			ELSE
			* IMAGEM DENTRO DA PASTA DOCVIEW
*!*					LOCAL ARRAY laDIR[1]
*!*					LOCAL lnXI AS Integer
						
*!*					=ADIR(laDIR, goAPLICATIVO.PATHDOCVIEW + 'GDI_' + ALLTRIM(lcTABSQL) + '_' + lcPK_ID + '_*')
*!*					FOR	lnXI = 1 TO ALEN(laDIR,1)
*!*						IF EMPTY(laDIR[lnXI,1])
*!*							LOOP
*!*						ENDIF
*!*						lcARQUIVO = goAPLICATIVO.PATHDOCVIEW + laDIR[lnXI,1]
*!*						IF FILE(lcARQUIVO)
*!*							TRY 
*!*								DELETE FILE(lcARQUIVO)
*!*							CATCH
*!*								llERRO = .T.
*!*							ENDTRY
*!*							
*!*							IF llERRO
*!*								DO MENS WITH 'Imagem do registro: ' + lcPK_ID + ' não pode ser deletada.'
*!*							ENDIF
*!*						ENDIF
*!*					ENDFOR
			ENDIF
		ENDIF
	ELSE
		DO MENS  WITH 'Problemas ao deletar registro!'
		RETURN(.F.)
	ENDIF
RETURN(.T.)


FUNC NOMESGRAFICOS
******************
* - RELAÇÃO DE NOME E NÚMEROS DOS POSSÍVEIS GRÁFICOS DO COMPONENTE OWC10
	LOCAL lcNOMES AS String
	STORE '' TO lcNOMES

	TEXT TO lcNOMES NOSHOW PRETEXT 7
		00 - COLUNAS AGRUPADAS
		01 - COLUNAS EMPILHADAS
		02 - COLUNAS 100% EMPILHADAS
		46 - COLUNAS 3D
		47 - COLUNAS 3D AGRUPADAS
		48 - COLUNAS 3D EMPILHADAS
		49 - COLUNAS 3D 100% EMPILHADAS
		03 - BARRAS AGRUPADAS
		04 - BARRAS EMPILHADAS
		05 - BARRAS 100% EMPILHADAS
		50 - BARRAS 3D
		51 - BARRAS 3D AGRUPADAS
		52 - BARRAS 3D EMPILHADAS
		53 - BARRAS 3D 100% EMPILHADAS
		06 - LINHAS
		07 - LINHAS COM MARCADORES
		08 - LINHAS EMPILHADAS
		09 - LINHAS EMPILHADAS COM MARCADORES
		10 - LINHAS 100% EMPILHADAS
		11 - LINHAS 100% EMPILHADS COM MARCADORES
		12 - LINHAS SUAVES
		13 - LINHAS SUAVES COM MARCADORES
		14 - LINHAS SUAVES EMPILHADAS
		15 - LINHAS SUAVES EMPILHADAS COM MARCADORES
		16 - LINHAS SUAVES 100% EMPILHADAS
		17 - LINHAS SUAVES 100% EMPILHADAS COM MARCADORES
		54 - LINHAS 3D
		55 - LINHAS 3D SOBREPOSTAS
		56 - LINHAS 3D EMPILHADAS
		57 - LINHAS 3D 100% EMPILHADAS
		18 - PIZZA
		19 - PIZZA DESTACADA
		20 - PIZZA EMPILHADA
		58 - PIZZA 3D
		59 - PIZZA 3D DESTACADA
		32 - ROSCA
		33 - ROSCA DESTACADA
		29 - ÁREA
		30 - ÁREA EMPILHADA
		31 - ÁREA 100% EMPILHADA
		60 - ÁREA 3D
		61 - ÁREA 3D EMPILHADA
		62 - ÁREA 3D 100% EMPILHADA
		34 - RADAR SEM MARCADORES
		35 - RADAR
		36 - RADAR PREENCHIDO
		37 - RADAR COM LINHAS SUAVES E SEM MARCADORES
		38 - RADAR COM LINHAS SUAVES E MARCADORES
	ENDTEXT
RETURN(lcNOMES)

* Classe padrão
DEFINE CLASS CONECTADB AS Custom
********************************
	PROC INIT
	*********
		WITH THIS AS Custom 
			.AddProperty('ID','')
			.AddProperty('NOMECONEXAO','')
			.AddProperty('DRIVER','')
			.AddProperty('SERVIDOR','')
			.AddProperty('BANCO','')
			.AddProperty('USUARIO','')
			.AddProperty('SENHA','')
			.AddProperty('PARAMETROSADICIONAIS','')
			.AddProperty('CONNECTIONSTRING','')
			.AddProperty('ALCA',-1)
			.AddProperty('PATHARQCONFIG','')
			.AddProperty('WAAWSTRINGARQ','')
			.AddProperty('TIPOCONEXAO',0)		&& 1=STANDARD   2=WAAW
			.AddProperty('LASTCOMMAND','')
			.AddProperty('LASTCURSOR','')
			.AddProperty('PATHERRORLOG','')
			.AddProperty('ERRORLOG',.F.)
		ENDWITH
	ENDPROC
	
	PROC UNLOAD
	***********
		DODEFAULT()
	ENDPROC 
	
	PROC CONECTAR
	*************
		LOCAL lcCONTEUDO,lcFILE AS String 
		LOCAL lnALCA AS Integer 
		
		* Preparando a string de conexão
		*THIS.LERARQCONFIGURACAO()
		THIS.CONNECTIONSTRING	= THIS.PREPARARCONNECTIONSTRING()
		
		DO ESPERANDO WITH 'Abrindo conexão com o Banco de Dados ( ' + ALLTRIM(THIS.NOMECONEXAO) + ' )'
		
		lnALCA	= SQLSTRINGCONNECT(THIS.CONNECTIONSTRING)
		
		DO FIMESPERANDO
		
	    IF lnALCA < 0
	    	*DO ROTERRO WITH ERROR(),MESSAGE(),PROGRAM(),LINENO(),'Erro ao conectar ao banco de dados.'
	    	RETURN(.F.)
	    ENDIF
	    
	    THIS.ALCA = lnALCA
	    
		RETURN .T.
	ENDPROC
	
	PROC LERARQCONFIGURACAO
	***********************
	LPARAMETERS tcPATHFILE,tnID
	* tcPATHFILE	= C:\VOLPEPWI.WAW
	* tnID			= 3		&& Número da conexão
		IF VARTYPE(tcPATHFILE) <> 'C'
			tcPATHFILE	= ''
		ENDIF
		IF EMPTY(tcPATHFILE)
			tcPATHFILE	= THIS.PATHARQCONFIG
		ENDIF
		IF EMPTY(tcPATHFILE)
			RETURN .F.
		ENDIF
		
		IF VARTYPE(tnID) <> 'N'
			tnID	= 0
		ENDIF
		IF EMPTY(tnID)
			tnID		= THIS.ID
		ENDIF
		
		LOCAL lcCONTEUDOARQ,lcCONTEUDOARQ AS String
		LOCAL llERROR AS Boolean
		
		STORE '' TO lcCONTEUDOARQ,lcCONTEUDOARQ
		STORE .F. TO llERROR
		
		* Verificando arquivo
		IF NOT FILE(tcPATHFILE)
			DO MENS WITH 'Não foi possível localizar o arquivo de configuração.' + CHR(13)+CHR(10) + 'Path: ' + lcARQUIVO
			RETURN .F.
		ENDIF
		
		DO CASE
			CASE THIS.TIPOCONEXAO = 1		&& STANDARD
				* Se o arquivo existir tenta abrir o arquivo e atualizar a string de conexão
				IF FILE(tcPATHFILE)
					TRY 
						USE (tcPATHFILE) SHARED ALIAS 'LERCONFIG'
					CATCH
					ENDTRY
				ENDIF
				
				IF USED('LERCONFIG')
					SELE LERCONFIG
					IF RECCOUNT('LERCONFIG') <= THIS.ID
						GO THIS.ID
						
						* Configurando
						THIS.NOMECONEXAO			= ALLTRIM(LERCONFIG.NOME)
						THIS.DRIVER					= ALLTRIM(LERCONFIG.DRIVER)
						THIS.SERVIDOR				= ALLTRIM(LERCONFIG.SERVER)
						THIS.BANCO					= ALLTRIM(LERCONFIG.DBNAME)
						THIS.USUARIO				= ALLTRIM(LERCONFIG.USER)
						THIS.SENHA					= ALLTRIM(SBDVEM(LERCONFIG.PWD))
						THIS.PARAMETROSADICIONAIS	= ALLTRIM(LERCONFIG.OUTROS)
					ENDIF
					
					USE IN 'LERCONFIG'
				ENDIF
			CASE THIS.TIPOCONEXAO = 2		&& WAAW
				* Carregando informações do arquivo
				TRY 
					lcCONTEUDOARQ 	= FILETOSTR(tcPATHFILE)
					llERROR			= .F.
				CATCH
					llERROR			= .T.
				ENDTRY
				IF llERROR
					DO MENS WITH 'Erro ao abrir arquivo de configuração.' + CHR(13)+CHR(10) + 'Path:' + tcPATHFILE
					RETURN .F.
				ENDIF

				* Descrypt
				lcCONTEUDOARQ	= WAW_DECRIPTAR(lcCONTEUDOARQ)

				* Configurando a conexão principal
				THIS.NOMECONEXAO		= STREXTRACT(lcCONTEUDOARQ	,'<NAME>'		,'</NAME>')
				THIS.DRIVER				= STREXTRACT(lcCONTEUDOARQ 	,'DRIVER='		,';')
				THIS.SERVIDOR			= STREXTRACT(lcCONTEUDOARQ 	,'SERVER='		,';')
				THIS.BANCO				= EVL(STREXTRACT(lcCONTEUDOARQ,'DATABASE=','<'),STREXTRACT(lcCONTEUDOARQ,'DATABASE=',';'))
				THIS.USUARIO			= STREXTRACT(lcCONTEUDOARQ 	,'UID='			,';')
				THIS.SENHA				= STREXTRACT(lcCONTEUDOARQ 	,'PWD='			,';')
				THIS.CONNECTIONSTRING	= STREXTRACT(lcCONTEUDOARQ 	,'<DATABASE>'	,'</DATABASE>')
				THIS.TIPOCONEXAO		= 2
				THIS.PATHARQCONFIG		= tcPATHFILE
				THIS.WAAWSTRINGARQ		= lcCONTEUDOARQ
		ENDCASE
	
	ENDPROC
	
	PROC PREPARARCONNECTIONSTRING
	*****************************
		LOCAL lcOUT AS String
		STORE '' TO lcOUT
		
		IF NOT EMPTY(THIS.DRIVER)
			lcOUT	= lcOUT + 'DRIVER=' + ALLTRIM(THIS.DRIVER)
		ENDIF
		IF NOT EMPTY(THIS.SERVIDOR)
			lcOUT	= lcOUT + ';SERVER=' + ALLTRIM(THIS.SERVIDOR)
		ENDIF
		IF NOT EMPTY(THIS.USUARIO)
			lcOUT	= lcOUT + ';UID=' + ALLTRIM(THIS.USUARIO)
		ENDIF
		IF NOT EMPTY(THIS.SENHA)
			lcOUT	= lcOUT + ';PWD=' + ALLTRIM(THIS.SENHA)
		ENDIF
		IF NOT EMPTY(THIS.BANCO)
			lcOUT	= lcOUT + ';DATABASE=' + ALLTRIM(THIS.BANCO)
		ENDIF
		IF NOT EMPTY(THIS.PARAMETROSADICIONAIS)
			lcOUT	= lcOUT + ';' + ALLTRIM(THIS.PARAMETROSADICIONAIS)
		ENDIF
		
		RETURN lcOUT
	ENDPROC
	
	PROC DESCONECTAR
	****************
		* FECHA CONEXAO COM BANCO DE DADOS
		IF THIS.ALCA > 0
			=SQLDISCONNECT(THIS.ALCA)
			
			THIS.ALCA		= 0
		ENDIF
	ENDPROC
ENDDEFINE

DEFINE CLASS APLICATIVO AS Custom
*********************************
	TESTE 			= _VFP.StartMode <> 4
	PATHLOCAL		= FULLPATH('')
	PATHTEMP		= GETENV("TEMP")+'\PWI\'
	NOME			= ''
	SEPARADOR		= '|'
	COR1			= 15987699
	COR2			= 16777181
	CORBASEOFICIAL	= 16758484
	COREDIT			= 15465210
	COROBRIGATORIO	= 14811135
	VALIDARINIT		= .F.
	VERSAO			= '1.00.001'
	PARAMETROEXE	= ''
	WAWATIVO 		= 1
	
	PROC KILLFORMS
	**************
		* MATAR OS FORMS ABERTOS
		LPARAMETERS tnNOKILL
		* NÃO MATAR: 0=SEM EXCEÇÃO, 1=TOOLBAR
		IF TYPE('tnNOKILL')<>'N'
			tnNOKILL = 0
		ENDIF

		LOCAL lnXI,lnQF AS Integer
		LOCAL lcFORMNAME AS String
		lnQF = _SCREEN.FORMCOUNT
		FOR lnXI = lnQF TO 1 STEP -1
			lcFORMNAME = UPPER(_SCREEN.FORMS(lnXI).NAME)
			TRY
				_SCREEN.FORMS(lnXI).RELEASE()
			CATCH
			ENDTRY
		ENDFOR
	ENDPROC
ENDDEFINE

PROC LERTABLES
**************
LPARAMETERS tcNAME,toCONEXAO AS STRING
	IF TYPE('tcNAME') <> 'C'
		tcNAME	= ''
	ENDIF
	IF VARTYPE(toCONEXAO) <> 'O'
		toCONEXAO = goCONEXAO1
	ENDIF
	
	LOCAL lcCOMANDO AS String
	IF USED('TMPTABLES')
		USE IN TMPTABLES
	ENDIF
	IF EMPTY(toCONEXAO.DRIVER)
		toCONEXAO.DRIVER = 'SQL SERVER'
	ENDIF
	DO CASE
		CASE 'MYSQL' $ UPPER(toCONEXAO.DRIVER)
				TEXT TO lcCOMANDO NOSHOW PRETEXT 7
					SELECT
						TABLE_NAME AS DS_TABLENAME
					FROM
						VW_TS_TABLES
				ENDTEXT
		CASE 'POSTGRES' $ UPPER(toCONEXAO.DRIVER)
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT 
					TABLENAME AS DS_TABLENAME
				FROM 
					pg_tables
				WHERE
					UPPER(TABLENAME) LIKE '[[TABLENAME]]'
				ORDER BY
					DS_TABLENAME
			ENDTEXT			

		CASE 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT 
					TABLE_NAME AS DS_TABLENAME
				FROM
					USER_TABLES
				WHERE
					UPPER (TABLE_NAME) LIKE '[[TABLENAME]]'
				ORDER BY
					DS_TABLENAME
			ENDTEXT						

		CASE 'SQL SERVER' $ UPPER(toCONEXAO.DRIVER)
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					UPPER(NAME) AS DS_TABLENAME
				FROM
					SYSOBJECTS
				WHERE
					TYPE = 'U'
					AND NAME LIKE '[[TABLENAME]]'
				ORDER BY
					DS_TABLENAME
			ENDTEXT

		OTHERWISE
			* NÃO TRAZ NADA, APENAS MONTA CURSOR VAZIO PARA MANTER COMPATIBILIDADE
			CREATE CURSOR TMPTABLES (DS_TABLENAME C(50))
	ENDCASE
	lcCOMANDO = STRTRAN(lcCOMANDO,'[[TABLENAME]]',UPPER(ALLTRIM(tcNAME)))
	=PESQUISASQL(lcCOMANDO,'TMPTABLES',toCONEXAO)
RETURN

PROC LOGSQLERRO
***************
LPARAMETERS tcTAB, tcERRN, tcERRC, tcSINTAXE, toCONEXAO
	LOCAL lcLINERRO, lcFILEERRO, lcENTER AS STRING
	lcENTER = CHR(13)+CHR(10)
	IF EMPTY(toCONEXAO.PATHERRORLOG)
		lcFILEERRO = TEMPFILE()
	ELSE
		lcFILEERRO = toCONEXAO.PATHERRORLOG
	ENDIF
	TRY 
		lcLINERRO = '<HORA>'+TTOC(DATETIME())+SYS(0)+'<\HORA>'+lcENTER
		=STRTOFILE(lcLINERRO,lcFILEERRO,1)
		lcLINERRO = '<TABELA>'+UPPER(tcTAB)+'<\TABELA>'+lcENTER
		=STRTOFILE(lcLINERRO,lcFILEERRO,1)
		lcLINERRO = '<ERRO>'+ALLTRIM(tcERRN)+'='+ALLTRIM(tcERRC)+'<\ERRO>'+lcENTER
		=STRTOFILE(lcLINERRO,lcFILEERRO,1)
		lcLINERRO = '<SINTAXE>'+lcENTER
		=STRTOFILE(lcLINERRO,lcFILEERRO,1)
		lcLINERRO = tcSINTAXE+lcENTER
		=STRTOFILE(lcLINERRO,lcFILEERRO,1)
		lcLINERRO = '<\SINTAXE>'+lcENTER+lcENTER+lcENTER
		=STRTOFILE(lcLINERRO,lcFILEERRO,1)
		toCONEXAO.PATHERRORLOG = ALLTRIM(lcFILEERRO)
	CATCH
	ENDTRY
RETURN

PROC FIMESPERANDO
*****************
	WAIT CLEAR
RETURN


PROC LERCOLUMNS
**************
LPARAMETERS tcDS_TIPO, tcDS_NOME, toCONEXAO AS STRING
	IF TYPE('tcDS_TIPO') <> 'C'
		tcDS_TIPO	= ''
	ENDIF
	IF EMPTY(tcDS_TIPO)
		RETURN
	ENDIF
	IF TYPE('tcDS_NOME') <> 'C'
		tcDS_NOME	= ''
	ENDIF
	IF TYPE('toCONEXAO') <> 'O'
		toCONEXAO 	= goCONEXAO1
	ENDIF
	IF EMPTY(tcDS_NOME)
		RETURN
	ENDIF

	LOCAL lcCOMANDO, lcAUXTAB, lcAUXCOL, lcCONDICAO AS String
	STORE '' TO lcCOMANDO, lcAUXTAB, lcAUXCOL, lcCONDICAO

	tcDS_NOME = UPPER(tcDS_NOME)
	
	IF USED('TMPCOLUMNS')
		USE IN TMPCOLUMNS
	ENDIF
	DO CASE
		CASE 'POSTGRES' $ UPPER(toCONEXAO.BANCO)
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT 
					UPPER(TABLE_NAME) AS DS_TABELA,
					UPPER(COLUMN_NAME) AS DS_CAMPO,
					DATA_TYPE AS DS_TIPO,
					COALESCE(CASE WHEN DATA_TYPE = 'numeric' THEN NUMERIC_PRECISION ELSE CHARACTER_MAXIMUM_LENGTH END,0) AS VL_TAMANHO,
					COALESCE(NUMERIC_SCALE,0) AS VL_PRECISAO
				FROM
					INFORMATION_SCHEMA.COLUMNS
				WHERE
					[[CONDICAO]]
					AND TABLE_SCHEMA = 'public'
			ENDTEXT
			lcAUXTAB	= 'UPPER(TABLE_NAME)'
			lcAUXCOL	= 'UPPER(COLUMN_NAME)'

		CASE 'ORACLE' $ UPPER(toCONEXAO.DRIVER)
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					TABELA.TABLE_NAME AS DS_TABELA,
					COLUNA.COLUMN_NAME AS DS_CAMPO,
					COLUNA.DATA_TYPE AS DS_TIPO,
					COALESCE(CASE WHEN COLUNA.DATA_TYPE = 'NUMBER' THEN COLUNA.DATA_PRECISION ELSE COLUNA.DATA_LENGTH END,0) AS VL_TAMANHO,
					COALESCE(COLUNA.DATA_SCALE,0) AS VL_PRECISAO
				FROM
					USER_TABLES TABELA
					LEFT JOIN ALL_TAB_COLUMNS COLUNA ON COLUNA.TABLE_NAME=TABELA.TABLE_NAME
				WHERE
					[[CONDICAO]]
			ENDTEXT		
			lcAUXTAB	= 'TABELA.TABLE_NAME'
			lcAUXCOL	= 'COLUNA.COLUMN_NAME'

		CASE 'SQL SERVER' $ UPPER(toCONEXAO.DRIVER) OR 'SQL NATIVE CLIENT' $ UPPER(toCONEXAO.DRIVER)
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					TABELA.NAME AS DS_TABELA,
					COLUNA.NAME AS DS_CAMPO,
					TIPO.NAME AS DS_TIPO,
					COALESCE(CASE WHEN TIPO.NAME = 'numeric' THEN COLUNA.XPREC ELSE COLUNA.LENGTH END,0) AS VL_TAMANHO,
					COALESCE(COLUNA.XSCALE,0) AS VL_PRECISAO
				FROM
					SYSOBJECTS TABELA
					LEFT JOIN SYSCOLUMNS COLUNA ON COLUNA.ID=TABELA.ID
					LEFT JOIN SYSTYPES TIPO ON TIPO.XTYPE=COLUNA.XTYPE
				WHERE
					[[CONDICAO]]
					AND TABELA.XTYPE='u'
					AND TABELA.NAME<>'dtproperties'
					AND TIPO.NAME<>'sysname'
			ENDTEXT
			lcAUXTAB	= 'TABELA.NAME'
			lcAUXCOL	= 'COLUNA.NAME'

		CASE 'MYSQL' $ UPPER(toCONEXAO.DRIVER)
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					TABLE_NAME AS DS_TABELA,
					COLUMN_NAME AS DS_CAMPO,
					DATA_TYPE AS DS_TIPO,
					COALESCE(CASE WHEN DATA_TYPE IN ('double', 'decimal') THEN NUMERIC_PRECISION ELSE CHARACTER_MAXIMUM_LENGTH END,0) AS VL_TAMANHO,
					COALESCE(NUMERIC_SCALE,0) AS VL_PRECISAO
				FROM
					VW_TS_COLUMNS
				WHERE
					[[CONDICAO]]
			ENDTEXT
			lcAUXTAB	= 'TABLE_NAME'
			lcAUXCOL	= 'COLUMN_NAME'

		OTHERWISE
			* NÃO TRAZ NADA, APENAS MONTA CURSOR VAZIO PARA MANTER COMPATIBILIDADE
			CREATE CURSOR TMPTABLES (DS_TABELA C(50), DS_COLUNA C(50), DS_TIPO C(50), VL_TAMANHO N(14,0), VL_PRECISAO N(14,0))

	ENDCASE
	lcCONDICAO	= ' LIKE ' + XX( tcDS_NOME )
	IF tcDS_TIPO = 'TAB'
		lcCONDICAO	= lcAUXTAB + lcCONDICAO
	ELSE
		lcCONDICAO	= lcAUXCOL + lcCONDICAO
	ENDIF
	lcCOMANDO = STRTRAN( lcCOMANDO, '[[CONDICAO]]', lcCONDICAO )
	=PESQUISASQL(lcCOMANDO,'TMPCOLUMNS')
RETURN