* MENURAIZ.PRG - MENU (PROGRAMA PRINCIPAL DO SISTEMA) ********************
**************************************************************************
PARAMETERS tcPARAMEXE1, tcPARAMEXE2, tcPARAMEXE3, tcPARAMEXE4, tcPARAMEXE5

IF TYPE('tcPARAMEXE1')<>'C'
	PRIVATE tcPARAMEXE1 AS STRING
	tcPARAMEXE1	= ''
ENDIF 
IF TYPE('tcPARAMEXE2') <> 'C'
	PRIVATE tcPARAMEXE2 AS STRING
	tcPARAMEXE2	= ''
ENDIF 
tcPARAMEXE1 = ALLTRIM(UPPER(tcPARAMEXE1))+';'

RELEASE ALL EXCEPT tcPARAMEXE*

_SCREEN.WindowState	= 2		&& TELA CHEIA
_SCREEN.MaxButton	= .T.
_SCREEN.Visible		= .T.
_SCREEN.Icon		= 'LOGO.ICO' 

* CONFIGURAÇÃO PADRÃO DO SISTEMA
DO AMBIENTAR

* WAIT CLEAR SÓ PARA RETIRAR QUALQUER WAIT ANTERIOR NO AMBIENTE DE TESTES (ERROS, TESTES E ETC)
WAIT CLEAR

* ALIMENTA SEMENTE DO RAND PARA TORNAR RESULTADO MAIS ALEATÓRIO 
=RAND(SECONDS()*1000)

IF EMPTY(STRTRAN(tcPARAMEXE1,';',''))
	tcPARAMEXE1	= ''
ENDIF
IF EMPTY(STRTRAN(tcPARAMEXE2,';',''))
	tcPARAMEXE2	= ''
ENDIF

CLEAR PROGRAM
CLEAR RESOURCES
CLOSE ALL
IF 'DISPLOGIN=ON' $ UPPER(tcPARAMEXE1)
	=SQLSETPROP(0,"DispLogin",2)
ELSE
	=SQLSETPROP(0,"DispLogin",3)
ENDIF
TRY 
	_SCREEN.AddObject('imgSPLASH','IMAGE')
	_SCREEN.imgSPLASH.Picture	= 'IMAGES\SPLASH.GIF'
	_SCREEN.imgSPLASH.Top		= ( _SCREEN.Height / 2 ) - ( _SCREEN.imgSPLASH.Height / 2 )
	_SCREEN.imgSPLASH.Left		= ( _SCREEN.Width / 2 ) - ( _SCREEN.imgSPLASH.Width / 2 )
	_SCREEN.imgSPLASH.Visible	= .T.
CATCH
FINALLY
ENDTRY

* OBJETO APLICATIVO
PUBLIC goAPLICATIVO, goESPERANDO, goPERSONAL, goFORMEMPFU AS Object
goPERSONAL			= CREATEOBJECT('EMPTY')
goAPLICATIVO		= CREATEOBJECT('APLICATIVO')
goAPLICATIVO.Name	= 'FRMAPLICATIVO'
goAPLICATIVO.Init()

* VERIFICA SE SISTEMA NUNCA SERÁ DERRUBADO
IF 'DOWN=OFF' $ goAPLICATIVO.PARAMETROEXE
	goAPLICATIVO.TRAVASIS = -1	&& NUNCA DERRUBAR
ENDIF

* CONFERE SE É UMA PASTA DO VOLPE
IF goAPLICATIVO.WAWATIVO=0
	IF NOT FILE(goAPLICATIVO.ARQCONFIG)
		DO MENS WITH 'Arquivo de configuração não encontrado! ' + goAPLICATIVO.ARQCONFIG
		CANCEL
	ENDIF
ENDIF

* PATH PARA OS ARQUIVOS DE SISTEMA
SET PATH TO
IF goAPLICATIVO.TESTE
	IF FILE('P:\SYSTEM\SYSTEM_LOGIN.SCX')
		SET PATH TO 'P:\SYSTEM\'
		IF FILE('..\TESTES.ICO')
			_SCREEN.Icon = '..\TESTES.ICO'
		ENDIF
	ELSE
		SET PATH TO '\TESTESVF\PLATA\SYSTEM\'
		IF FILE('\TESTESVF\PLATA\TESTES.ICO')
			_SCREEN.Icon = '\TESTESVF\PLATA\TESTES.ICO'
		ENDIF
	ENDIF
	SET PATH TO 'IMAGES\' ADDITIVE
	_SCREEN.MAXBUTTON	= .T.
ENDIF

* NÃO PERMITE QUE O VOLPE SEJA FECHADO ENQUANTO ESTIVER FAZENDO A CARGA DO SISTEMA			
_SCREEN.Closable = .F.	

SET CLASSLIB TO PWICLASS
SET CLASSLIB TO RESCLASS ADDITIVE
SET CLASSLIB TO EDITOR_HTML ADDITIVE
SET CLASSLIB TO FFC\_REPORTLISTENER ADDITIVE
SET CLASSLIB TO FFC\_WS3CLIENT ADDITIVE

IF goAPLICATIVO.TESTE
	IF FILE('P:\SYSTEM\SYSTEM_LOGIN.SCX')
		SET PROCEDURE TO 'XFRX.FXP' ADDITIVE
		* FXP responsavel pela interoperabilidade
		SET PROCEDURE TO 'WWDOTNETBRIDGE.FXP' ADDITIVE
	ELSE
		SET PROCEDURE TO '\TESTESVF\PLATA\SYSTEM\XFRX.FXP' ADDITIVE
		* FXP responsavel pela interoperabilidade
		SET PROCEDURE TO '\TESTESVF\PLATA\SYSTEM\WWDOTNETBRIDGE.FXP' ADDITIVE
	ENDIF
ELSE
	SET PROCEDURE TO XFRX.FXP ADDITIV
	* FXP responsavel pela interoperabilidade
	SET PROCEDURE TO WWDOTNETBRIDGE.FXP ADDITIVE
ENDIF

* INTEROPERABILIDADE
* CARREGAR OBJETO GLOBAL DA CLASSE UTILITARIOS
* PRECISA SER CARREGADA APÓS O SET PATH e SET PROCEDURE
PUBLIC goUTILITARIOS AS 'Utilitarios'
goUTILITARIOS = CREATEOBJECT('Utilitarios')

* ADICIONANDO OBJETO QUE GERENCIA SYSTRAY DO VOLPE
goAPLICATIVO.ADDOBJECT( 'mySYSTRAY', 'MEUSYSTRAY' )

* ADICIONANDO OBJETO QUE GERENCIA SYSTRAY DO VOLPE
goAPLICATIVO.CRIARMYZIPCLASS()

* REMOVE CTRL+0 QUE DIGITA .NULL. NOS CAMPOS
ON KEY LABEL CTRL+0 KEYBOARD '0'

* TRATAMENTO DE ERROS
IF goAPLICATIVO.TESTE
	ON KEY LABEL CTRL+F2 ACTIVATE WINDOW COMMAND
	SET STATUS BAR ON
ELSE
	SET SYSMENU TO
	SET RESOURCE OFF
	ON ERROR DO ROTERRO WITH ERROR(),MESSAGE(),PROGRAM(),LINENO()
	ON SHUTDOWN DO ENCERRAR

	* AJUSTE DE SCREEN
	SET STATUS BAR OFF
	_SCREEN.HEIGHT		= SYSMETRIC(2)-SYSMETRIC(9)-53
	_SCREEN.BorderStyle	= 1
	_SCREEN.WindowState	= 2		&& tela cheia
ENDIF

* TRAVA DO SISTEMA (PARA MANUTENÇÃO)
IF FILE(goAPLICATIVO.TRAVAARQ) AND goAPLICATIVO.TRAVASIS >= 0
	DO PROGTRAVADO
	* TEM 1 SEGUNDO PARA "FURAR O BLOQUEIO" COM CTRL+F1
	LOCAL lnKEY AS INTEGER
	lnKEY = INKEY(1)
	IF lnKEY<>94
		CLEAR ALL
		RETURN
	ENDIF
	RELEASE lnKEY
	goAPLICATIVO.TRAVASIS = -1	&& NUNCA DERRUBAR
ENDIF

DO CARGASISTEMA

* ARRUMANDO PASTA SEPARADA PARA ARQUIVOS TEMPORÁRIOS
DO CRIATEMPDIR
DO KILLTEMPFILE

* FAZ SETUP DO AMBIENTE
LOCAL lcFUNCOES, lcXFRX, lcTEMPFUNCOES, lcTEMPXFRX AS String

lcFUNCOES = 'OBJETOS\SYS_FUNCOES.FXP'

* SE É AMBIENTE DE TESTES PODE OLHAR PASTA STOB
IF goAPLICATIVO.TESTE
	* VERIFICA SE EXISTE SYS_FUNCOES PERSONAL
	IF NOT FILE(lcFUNCOES)
		lcFUNCOES = goAPLICATIVO.PATHVOLPEPADRAO + lcFUNCOES
	ENDIF
ENDIF

IF NOT FILE(lcFUNCOES)
	DO MENS WITH 'Arquivo de funções básicas não encontrado: '+lcFUNCOES
	RETURN
ENDIF

lcTEMPFUNCOES	= TEMPFILE('FXP')

* COPIANDO ARQUIVO SYS_FUNCOES.FXP PARA UTILIZAR TEMPORÁRIO
TRY
	COPY FILE (lcFUNCOES) TO (lcTEMPFUNCOES)
CATCH
	* EM CASO DE ERRO AO TENTAR COPIAR CONTINUA UTILIZANDO ARQUIVO ORIGINAL
	lcTEMPFUNCOES = lcFUNCOES
ENDTRY

SET PROCEDURE TO (lcTEMPFUNCOES) ADDITIVE

* OBJETO CONEXÃO
PUBLIC goCONEXAO AS Object
goCONEXAO = CREATEOBJECT('CONECTADB')
goCONEXAO.CONECTAR()
IF goCONEXAO.FK_USUARIO<=0
	DO ENCERRAR
ENDIF

* CARREGANDO VERSÃO DO WAW PARA CONTROLE DE ATUALIZAÇÃO
goAPLICATIVO.CARREGARWAWVERSION()

goAPLICATIVO.mySYSTRAY.TipText = 'Volpe: '+goCONEXAO.USERNAME
* CARREGANDO FERIADOS
DO CARGAFERIADOS
* CARREGANDO UTC ATUAL POR ESTADO
DO MONTARUTCPORUF
* CARREGANDO TABELAS DO SISTEMA
DO CARGASYSTEMTABLES
* CARREGANDO STRING DE TABELAS QUE TEM MICRO LOG
goAPLICATIVO.CARGATABLOG()
goAPLICATIVO.CARGACOLUMNS()
* CARREGANDO MÓDULOS DO SISTEMA
goAPLICATIVO.CARGAMODULOS()

* CARREGANDO VALIDADE DO SISTEMA
goAPLICATIVO.CARGAVALIDADE()

* CHAMA ROTINA DE ATIVAÇÃO ONLINE
DO LAC_ATIVACAOVOLPE

*goCONEXAO.MONTADIREITOS()

IF goAPLICATIVO.VALIDADE < 0
	DO ENCERRAR
ENDIF

* AVISO DE SOFTWARE NÃO REGISTRADO
IF goAPLICATIVO.REGISTRADO <= 0
	=CHAMAFORM('SYSTEM_NAOREGISTRADO','MODAL')
ENDIF

* UTILIZAR LOGO POR EMPRESA (DEFAULT .F.)
* ONDE:
* ON 	- LOGOTIPO PODE SER CONFIGURADO POR EMPRESA E IMPACTA NOS RELATÓRIOS (IMPRIMIR)
* OFF 	- UTILIZADA O ARQUIVO LOGO.BMP PARA TODOS OS REPORTS
LOCAL lcLOGOMULTI AS String 
lcLOGOMULTI = UPPER(ALLTRIM(RETORNASET('LOGO.MULTIEMPRESA','C',0)))
IF NOT EMPTY(lcLOGOMULTI)
	IF lcLOGOMULTI='ON'
		goAPLICATIVO.LOGOMULTIEMPRESA=.T.
	ENDIF
ENDIF
RELEASE lcLOGOMULTI

LOCAL lcSAR AS String 
lcSAR = UPPER(ALLTRIM(RETORNASET('SISTEMA.SAR','C',0)))
IF NOT EMPTY(lcSAR)
	IF lcSAR ='OFF'
		goAPLICATIVO.PERMITESAR=.F.
	ENDIF
ENDIF

DO LERTABLES WITH 'TS_SAR'
SELE TMPTABLES
GO TOP
IF RECCOUNT() = 0
	goAPLICATIVO.PERMITESAR=.F.
ENDIF

RELEASE lcLOGOMULTI

* CARREGANDO COMPLEMENTOS DOS CAMPOS SIGILOSO NA PROPRIEDA COM OS CAMPOS DEFAULT
LOCAL lcCAMPOSLGPD AS String  
lcCAMPOSLGPD = ALLTRIM(RETORNASET('LGPD.DADOSSIGILOSOS', 'C', 0))
IF NOT EMPTY(lcCAMPOSLGPD)
	goAPLICATIVO.CAMPOSLGPD = goAPLICATIVO.CAMPOSLGPD + ',' + lcCAMPOSLGPD
ENDIF 

* FORMA DE EXCLUSÃO DA GRADE
goAPLICATIVO.GRADEEXCLUIR = RETORNASET('SISTEMA.GRADEEXCLUIR','N',0)

* IMAGEM DE DESKTOP
goAPLICATIVO.IMGDESKTOP	= RETORNASET('SISTEMA.IMGDESKTOP','N',0)

* PARAMETROS DE RESOLUÇÃO
LOCAL lnALT,lnLAR AS Integer
lnALT = RETORNASET('SCREEN.ALTURA','N',0)
lnLAR = RETORNASET('SCREEN.LARGURA','N',0)
IF lnALT>0
	goAPLICATIVO.MINALTURA=lnALT
ENDIF
IF lnLAR>0
	goAPLICATIVO.MINLARGURA=lnLAR
ENDIF
RELEASE lnALT,lnLAR

* VERIFICAR PASTA PADRÃO DO SISTEMA
LOCAL lcPATHUSERS AS String

lcPATHUSERS = RETORNASET('SISTEMA.PATHUSERS','C',0)
IF NOT EMPTY(lcPATHUSERS) AND DIRECTORY(lcPATHUSERS)
	goAPLICATIVO.PATHUSERS	 = lcPATHUSERS
	goAPLICATIVO.PATHDOCVIEW = ADDBS(lcPATHUSERS)+'DOCVIEW\'
ENDIF

* VERIFCA EXISTENCIA DE PASTAS DO SISTEMA, CASO NÂO EXISTAM TENTA CRIAR
LOCAL		lcPASTA, lcPASTAVERIF AS STRING
STORE '' TO lcPASTA, lcPASTAVERIF

IF NOT DIRECTORY(goAPLICATIVO.PATHUSERS)
	lcPASTA = goAPLICATIVO.PATHUSERS
	IF ADIR(laDIR,lcPASTA,'DHS')=0
		lcPASTA = '\'+lcPASTA+'\'
		TRY
			FOR lnXI = 1 TO OCCURS('\',lcPASTA)-1
				lcPASTAVERIF = ADDBS(lcPASTAVERIF + STREXTRACT(lcPASTA,'\','\',lnXI))
				IF NOT DIRECTORY(lcPASTAVERIF,1)
					MD (lcPASTAVERIF)
				ENDIF
			ENDFOR
		CATCH
		ENDTRY
	ENDIF
ENDIF

IF NOT DIRECTORY(goAPLICATIVO.PATHDOCVIEW)
	lcPASTA = goAPLICATIVO.PATHDOCVIEW
	IF ADIR(laDIR,lcPASTA,'DHS')=0
		lcPASTA = '\'+lcPASTA+'\'
		TRY
			FOR lnXI = 1 TO OCCURS('\',lcPASTA)-1
				lcPASTAVERIF = ADDBS(lcPASTAVERIF + STREXTRACT(lcPASTA,'\','\',lnXI))
				IF NOT DIRECTORY(lcPASTAVERIF,1)
					MD (lcPASTAVERIF)
				ENDIF
			ENDFOR
		CATCH
		ENDTRY
	ENDIF
ENDIF

* ZW PARA VER NECESSIDADE DE VERIFICAR ARQUIVO TRAVADO.SIT NA PASTA
IF RETORNASET('SISTEMA.NAOTRAVAR','N',1) = 1
	goAPLICATIVO.TRAVASIS = -1	&& NUNCA DERRUBAR
ENDIF

goAPLICATIVO.EMPRESA		= ALLTRIM(RETORNASET('SISTEMA.EMPRESA','C',1))
goAPLICATIVO.SISTEMA		= ALLTRIM(RETORNASET('SISTEMA.TITULO','C',1))

* FONTE ALTERNATIVA NAS TEXTBOX/COMBOBOX
IF RETORNASET('SISTEMA.FONTALTERNATIVA','N',1) = 1
	goAPLICATIVO.FONTALTERNATIVA = 1
ENDIF

* CARREGANDO TÍTULO DA EMPRESA
*' - ' + goAPLICATIVO.SISTEMA
*goAPLICATIVO.NOMEPROGRAMA + ' ' + 
_SCREEN.Caption 			= goAPLICATIVO.NOMEPROGRAMA + ' - ' + goAPLICATIVO.SISTEMA

* CARREGANDO PADRÃO TOP DE SELECT PARA O SISTEMA
LOCAL lnTOPSELECT AS Integer
lnTOPSELECT = RETORNASET('SISTEMA.TOPSELECT','N',1)
IF EMPTY(lnTOPSELECT)
	lnTOPSELECT = 500
ENDIF
goAPLICATIVO.TOPSELECT = lnTOPSELECT

* VERIFICA SE EXISTE CONTROLE DE ALIAS DO REPORT
IF UPPER(RETORNASET('SISTEMA.ALIASREPORT','C',1)) == 'ON'
	* VERIFICA EXISTÊNCIA DA TABELA
	DO LERTABLES WITH 'TS_IMPRESSOES'
	SELE TMPTABLES
	GO TOP
	IF RECCOUNT() > 0
		* VERIFICA EXISTÊNCIA DO CAMPO DE ALIAS DO REPORT
		=PESQUISASQL('SELECT * FROM TS_IMPRESSOES WHERE 1=2','TMPSYSIMP')
		SELE TMPSYSIMP
		IF VARTYPE('TMPSYSIMP.DS_ALIASREPORT') = 'C'
			lcALIASREPO 					= RETORNASET('SISTEMA.ALIASREPORTGRUPO','C',1)
			goAPLICATIVO.ALIASREPORT 		= 1
			* DEPENDENDO DE QUAL FOR O TAMANHO DO CAMPO DE GRUPO É FEITO DE UM JEITO OU DE OUTRO
			IF goCONEXAO.TAMANHOGRUPO = 1
				goAPLICATIVO.ALIASREPORTGRUPO	= lcALIASREPO+'S' && GRUPO SUPERVISOR SEMPRE TEM ACESSO
			ELSE
				goAPLICATIVO.ALIASREPORTGRUPO	= IIF(EMPTY(lcALIASREPO),'SSS',lcALIASREPO+',SSS') && GRUPO SUPERVISOR SEMPRE TEM ACESSO
			ENDIF
		ENDIF
	ENDIF
	IF USED('TMPTABLES')
		USE IN TMPTABLES
	ENDIF
	IF USED('TMPSYSIMP')
		USE IN TMPSYSIMP
	ENDIF
ENDIF

* VERIFICA ZW COM A COLLATE DO SISTEMA
lcCOLLATE 	= RETORNASET('SISTEMA.COLLATE','C',0)
lcCOLLATE	= ALLTRIM(UPPER(lcCOLLATE))
IF NOT EMPTY(lcCOLLATE)
	* SÓ FAZ O DO CASE PARA PROTEGER NOMES DE COLLATE INVÁLIDOS
	DO CASE
		CASE lcCOLLATE == 'MACHINE'
			GOAPLICATIVO.COLLATE = 'MACHINE'
			
		CASE lcCOLLATE == 'GENERAL'
			GOAPLICATIVO.COLLATE = 'GENERAL'
			
		OTHERWISE
			GOAPLICATIVO.COLLATE = 'MACHINE'
	ENDCASE
ELSE
	* ZW Ñ EXISTE - SETA O PADRÃO
	GOAPLICATIVO.COLLATE = 'MACHINE'
ENDIF

* EXIBIR ALERTA DE HELP NAS TELAS
GOAPLICATIVO.ALERTAHELP = RETORNASET('SISTEMA.ALERTAHELP','C',1)
IF GOAPLICATIVO.ALERTAHELP <> 'ON'
	GOAPLICATIVO.ALERTAHELP = 'OFF'
ENDIF

LOCAL lcCOMANDO, lcLETRA, lcGRUPO, lcPRODGRADE AS String
LOCAL llCONTIDO, llALARME AS Logical
STORE .F. TO llALARME

* INICIANDO TIMER DO SISTEMA
IF TYPE('goAPLICATIVO.tmrTIMER') = 'O'
	* TIMER FICA DESABILITADO POR DEFAULT EM MODO DE DESENVOLVIMENTO
	IF _VFP.StartMode = 0 
		goAPLICATIVO.tmrTIMER.ENABLED = .F.
	ELSE
		goAPLICATIVO.tmrTIMER.ENABLED = .T.
	ENDIF
ENDIF

* INICIALIZANDO ALARMES DO SISTEMA
IF RETORNASET('SISTEMA.ALARME','C',1) == 'ON'
	llALARME = .T.
	=CARREGARALARME()
ENDIF

* SETANDO PROPRIEDADE INICIAL
lcPRODGRADE = RETORNASET('PRODUTO.GRADE','C',1)
DO CASE
	CASE lcPRODGRADE == 'ON'
		goAPLICATIVO.PRODUTOGRADE = 1
	CASE lcPRODGRADE == 'SKU'
		goAPLICATIVO.PRODUTOGRADE = 2
ENDCASE

* VERIFICANDO SE SISTEMA POSSUI OPÇÃO DE DELETAR
IF RETORNASET('SISTEMA.NODELETE','C',1) == 'ON'
	goAPLICATIVO.NODELETE = .T.
ENDIF

IF RETORNASET('SISTEMA.TITULOCOLUNADESKTOP','C',1) == 'ON'
	goAPLICATIVO.TITULOCOLUNA = 1
ENDIF

* CARREGA ZW PARA DEFINIR LOWERCASE NAS TEXTBOX
IF RETORNASET('SISTEMA.LOWERCASE','C',1) == 'ON'
	GOAPLICATIVO.LOWERCASE = 1
ENDIF

* ADICIONANDO STATUSBAR NA SCREEN
IF TYPE("_Screen.oStatusBar")='O'
	_SCREEN.RemoveObject('oStatusBar')
ENDIF
_SCREEN.NEWobject("oStatusBar","ctl32_statusbar",'resclass.vcx', null, 5)
WITH _SCREEN.ostatusbar
	
	* ITEM1 - Informações da conexão
	.Panel1.ctlCaption 		= goCONEXAO.NOMECONEXAO
	.Panel1.ctlIcon 		= 'CTL32\dbserver.ico'
	.Panel1.ctlToolTipText 	= 'Clique duas vezes para ver informações da conexão.'

	* ITEM2 - Informações do usuário
	.Panel2.ctlCaption 		= goCONEXAO.USERNAME
	.Panel2.ctlIcon 		= 'CTL32\user.ico'
	.Panel2.ctlToolTipText 	= 'Clique duas vezes para ver informações do usuário.'
	
	* ITEM3 - Seleção de empresas
	=EMP2STATUSBAR()
	.Panel3.ctlIcon 		= 'CTL32\emp.ico'
	.Panel3.ctlToolTipText  = 'Clique duas vezes configurar filtro de empresas.'

	* ITEM4 - Alarmes do sistema
	IF llALARME
		.Panel4.ctlCaption 		= 'ALARMES'
		.Panel4.ctlIcon 		= 'CTL32\alarme.ico'
		.Panel4.ctlToolTipText  = 'Clique duas vezes para ver informações do alarme do sistema.'
	ENDIF

	* ITEM5 - WAW
	IF goAPLICATIVO.WAWATIVO=1
		.Panel5.ctlCaption 		= 'WAW'
		.Panel5.ctlToolTipText  = 'VOLPE - WAW'
	ENDIF
		
ENDWITH
=BINDEVENT(_SCREEN.oSTATUSBAR,'CTLDblClick',goAPLICATIVO,'STATUSBAR_DblClick')

* PROCEDIMENTOS PARTICULARES DE CADA SISTEMA
* FICA SEMPRE NO SYS_FUNCOES.PRG
LOCAL lcAUTOEXEC AS String
lcAUTOEXEC = '=AUTOEXEC()'
&lcAUTOEXEC

* PROCEDIMENTO DE DE ERRO TRATADO
goAPLICATIVO.ERROTRATADO = 'OFF'
LOCAL lcERROTRATADO AS String 
lcERROTRATADO = UPPER(ALLTRIM(RETORNASET('SISTEMA.ERROTRATADO','C',0)))
IF lcERROTRATADO == 'ON'
	goAPLICATIVO.ERROTRATADO = 'ON'	
ENDIF

* CRIA FORMULARIO E OBJETOS (ÁREA DE TRABALHO)
DO MONTADESKTOP
IF goAPLICATIVO.VALIDADE > 0
	goDESKTOP.SHOW()
ENDIF

* BUSCA ID DA SESSÃO ATUAL (SOMENTE SQL SERVER)
LOCAL lcSPID AS Integer
STORE '' TO lcSPID
IF goCONEXAO.BANCO = 'SQL'
	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		SELECT @@SPID AS NR_CONEXAO
	ENDTEXT
	=PESQUISASQL(lcCOMANDO,'TMPSPID')
	
	lcSPID = '(SPID=' + XX(TMPSPID.NR_CONEXAO) + ')'
ENDIF

* GRAVA LOG DE CONEXÃO (LOGIN) + LOG DE TRAFEGO
DO GRAVALOG WITH 'L', goCONEXAO.FK_USUARIO, 'TS_USUARIOS', 'LOGIN->'+GETENV("USERNAME")+'\'+GETENV("COMPUTERNAME")+lcSPID, ''
goCONEXAO.GRAVATRAFEGO_INI()

* DEFINE TECLAS QUENTES DO SISTEMA
ON KEY LABEL F1  DO SYSHELP
ON KEY LABEL F4  DO SYSROTF4
ON KEY LABEL F12 DO EXECUTARF12
ON KEY LABEL CTRL+F8 DO SYSROTF8
ON KEY LABEL CTRL+D DO COPIARDADO
ON KEY LABEL CTRL+F7 DO FORM SYSTEM_LOGPERFORMANCE
ON KEY LABEL F9 DO QUICKMAIL_CALL

* SOMENTE CARREGA CALCULADORA NO F8 SE FOR TESTE
IF NOT GOAPLICATIVO.TESTE
	ON KEY LABEL F9 ACTIVATE WINDOW CALCULATOR
ENDIF

* APOS TER FEITO TODA A CARGA DO SISTEMA - LIBERA O BOTÃO DE FECHAR			
_SCREEN.Closable = .T.

READ EVENTS
CLEAR ALL
RETURN

PROC ARETRA
***********
	** DEIXA O AMBIENTE CONFIGURADO PARA TRABALHO
	* FECHA TODOS OS FORMULÁRIOS
	goAPLICATIVO.KILLFORMS(1)

	* FECHA DESKTOP
	RELEASE goDESKTOP

	* VOLTA MENU PADRÃO
	SET SYSMENU TO DEFA

	* VOLTA ATALHO F8 AO NORMAL
	ON KEY LABEL F8

	* MATA/DESATIVA ALARMES DO SISTEMA
	IF USED('TMPSYSALARMES')
		USE IN TMPSYSALARMES
	ENDIF

	* CANCELA ROTINA ATUAL
	CANCEL
RETURN

DEFINE CLASS MEUOLETRAY AS OLETRAY OF PWICLASS.VCX
ENDDEFINE

DEFINE CLASS MEUSYSTRAY AS SYSTRAY OF PWICLASS.VCX
**************************************************
	PROC INIT
		THIS.PARENT.PERMITESYSTRAY = THIS.AddIconToIconList('ICONES\SYSTRAY.ICO')
		THIS.TipText = 'Volpe'
		
		* RODANDO VOLPE EM MODO JOB
		IF NOT EMPTY(goAPLICATIVO.JOB_NAME)
			* CONFIGURANDO MENU DE CONTEXTO
			goAPLICATIVO.mySYSTRAY.MENUTEXT = '1;ENCERRAR;2;EXIBIR SUMÁRIO'
		ENDIF
	ENDPROC
	
	*EVENTO DE DOUBLE-CLICK NO SYSTRAY
	PROC IconDblClickEvent
	**********************
		* RODANDO VOLPE EM MODO NORMAL
		IF EMPTY(goAPLICATIVO.JOB_NAME)
			goAPLICATIVO.mySYSTRAY.iconfile = 'ICONES\SYSTRAY.ICO'
			IF goAPLICATIVO.BLOQSYSTRAY
				LOCAL loDESBLOQ AS Object
				DO FORM SYSTEM_DESBLOQUEAR NAME loDESBLOQ
				loDESBLOQ.ACTIVATE
			ELSE
				goAPLICATIVO.MINSYSTRAY = .F.
				_SCREEN.Show()
				THIS.RemoveIconFromSystray()
			ENDIF
		ENDIF
	ENDPROC

	*EVENTO DE CLICK NO SYSTRAY
	PROC IconClickEvent
		IF NOT EMPTY(goAPLICATIVO.JOB_NAME)
			IF NOT ISBLANK(THIS.MenuText)
				THIS.ShowMenu()
			ENDIF
		ENDIF
	ENDPROC

	*EVENTO DE MIDDLE-CLICK NO SYSTRAY
	PROC IconMiddleClickEvent
	ENDPROC

	*EVENTO DE RIGHT-CLICK NO SYSTRAY
	PROC IconRightClickEvent
		IF NOT ISBLANK(THIS.MenuText)
			THIS.ShowMenu()
		ENDIF
	ENDPROC

	*EVENTO DE CLICK NO BALÃO DE AVISO
	PROC BalloonClickEvent
	ENDPROC

	*EVENTO DE FECHAR NO BALÃO DE AVISO
	PROC BalloonHideEvent
	ENDPROC

	*EVENTO DE BALÃO FECHADO POR TIMEOUT
	PROC BAlloontimeoutevent
	ENDPROC

	*EVENTO DISPARADO QUANDO UM BALÃO É ABERTO
	PROC BalloonShowEvent
	ENDPROC
	
	*EVENTO DISPARADO QUANDO O MENU DE CONTEXTO É SELECIONADO
	PROC ProcessMenuEvent
	LPARAMETERS nMenuItemID
		* OPÇÕES DO MENU DE CONTEXTO
		DO CASE
			CASE nMenuItemID = 1 && ENCERRAR
				IF SIMOUNAO('ENCERRAR VOLPE MODO JOB?','ENCERRAR VOLPE',0)
					DO ENCERRAR
				ENDIF
			
			CASE nMenuItemID = 2 && EXIBIR SUMÁRIO
				LOCAL lcSUMARIO, lcFILE, lcERROS AS String
				STORE '' TO lcSUMARIO, lcFILE, lcERROS

				lcFILE		= goAPLICATIVO.PATHTEMP + 'SUMARIO.TXT'
				lcERROS		= IIF(EMPTY(goAPLICATIVO.JOB_ERROS),'(NENHUM)',goAPLICATIVO.JOB_ERROS)
				TEXT TO lcSUMARIO NOSHOW PRETEXT 3
					VOLPE EM MODO SLAVE
					 
					TAREFA: <<JOB>>
					 
					ULTIMA EXECUÇÃO : <<ULT>>
					PRÓXIMA EXECUÇÃO: <<PRO>>
					 
					ERROS DE EXECUÇÃO
					 
					<<ERR>>
				ENDTEXT
				lcSUMARIO	= STRTRAN(lcSUMARIO,'<<JOB>>',goAPLICATIVO.JOB_NAME)
				lcSUMARIO	= STRTRAN(lcSUMARIO,'<<ULT>>',TTOC(goAPLICATIVO.JOB_ULTEXEC,2))
				lcSUMARIO	= STRTRAN(lcSUMARIO,'<<PRO>>',TTOC(goAPLICATIVO.JOB_PROEXEC,2))
				lcSUMARIO	= STRTRAN(lcSUMARIO,'<<ERR>>',lcERROS)

				=STRTOFILE(lcSUMARIO,lcFILE,0)

				DO STARTAFILE WITH lcFILE
		ENDCASE
	ENDPROC
ENDDEFINE

DEFINE CLASS MEUDESKTOP AS Form
*******************************
	CAPTION			= 'Desktop'
	ANCHOR			= 15
	SHOWTIPS		= .T.
	ALWAYSONBOTTOM	= .T.
	WIDTH			= _SCREEN.WIDTH - 5
	HEIGHT			= _SCREEN.HEIGHT - 35
	TOP				= 0
	LEFT			= 1
	BORDERSTYLE		= 3

	SHOWINTASKBAR	= .T.
	MAXBUTTON		= .T.
	CLOSABLE		= .F.
	Icon			= 'LOGO.ICO'
	
	ADD OBJECT PAGINAS AS MYPAGES
	PROC LOAD
		DO AMBIENTAR
	ENDPROC
	
	PROC ACTIVATE
		* PROTEÇÃO PARA REEXIBIR BARRA DE ROLAGEM APÓS ABRIR QUALQUER TOOLBAR NA PARTE SUPERIOR
		* SOMENTE EM AMBIENTE DE TESTE E LAYOUT CLASSICO
		IF GOAPLICATIVO.TESTE AND GOAPLICATIVO.FLAT = 0
			THIS.WindowState = 0
			THIS.WindowState = 2
		ENDIF
	ENDPROC
	
	PROC INIT
		
		*#FLAT - CASO VOLPE FLAT ESTEJA ATIVO PAGEFRAME NÃO SERÁ TEMADO 
		IF goAPLICATIVO.FLAT = 1 
			THIS.PAGINAS.Themes = .F.
			
		ENDIF  
		THIS.PAGINAS.ANCHOR	= 0
		THIS.PAGINAS.HEIGHT	= THIS.Height
		THIS.PAGINAS.ANCHOR = 1+2+4+8
					  
	ENDPROC
	
	PROC UNLOAD
		RELEASE goDESKTOP
	ENDPROC

ENDDEFINE

DEFINE CLASS MYPAGES AS PAGEFRAME
	
	* PAGEFRAME UM POUCO ACIMA PARA EVITAR LINHA BRANCA 
	Top	 	= -3
	Left	= -3
	
	WIDTH	= _SCREEN.WIDTH
	HEIGHT	= _SCREEN.HEIGHT - 90
	VISIBLE	= .T.
		
	PROC MOUSEWHEEL
	LPARAMETERS nDirection, nShift, nXCoord, nYCoord
		* #FLAT - MOVER PAGINAÇÃO NO MOUSEWHEEL
		IF goAPLICATIVO.FLAT = 1 
			IF nDirection < 0 && AVANÇA 
				THIS.PAGES(THIS.ACTIVEPAGE).cmdAVANCAR.Click()
			ELSE && VOLTA
				THIS.PAGES(THIS.ACTIVEPAGE).cmdVOLTAR.Click()
			ENDIF 
		ENDIF 
	ENDPROC 	
	PROC KEYPRESS
		LPARAMETERS nKeyCode, nShiftAltCtrl
		LOCAL lcCHAMADA AS STRING
		lcCHAMADA = ''
		IF NKEYCODE=32		&& BARRA DE ESPAÇO
			I = 0
			DEFINE POPUP CONTEXTOA SHORTCUT RELATIVE FROM THIS.TOP+3,THIS.LEFT+100
			FOR EACH OBJETOA IN THIS.PAGES(THIS.ACTIVEPAGE).scntBRANCO.SCROLLAREA.CONTROLS
				IF UPPER(OBJETOA.CLASS)<>'MEUATALHO'
					LOOP
				ENDIF
				I = I + 1
				DEFINE BAR I OF CONTEXTOA PROMPT OBJETOA.lblDS_ROTINA.CAPTION
				lcCHAMADA = 'goDESKTOP.PAGINAS.'+THIS.PAGES(THIS.ACTIVEPAGE).NAME+'.scntBRANCO.SCROLLAREA.'+OBJETOA.NAME + '.CLICK'
				ON SELECTION BAR I OF CONTEXTOA &lcCHAMADA
			ENDFOR
		
			IF I=0
				* SE NÃO TINHA OPÇÕES, MOSTRA MENU DE CONTEXTO VAZIO
				DEFINE BAR 1 OF CONTEXTOA PROMPT '\Sem opçôes'
				ON SELECTION BAR 1 OF CONTEXTOA DO MENS WITH 'Sem opções'
			ENDIF
			ACTIVATE POPUP CONTEXTOA
		ENDIF
		
		*#FLAT AVANÇAR E VOLTAR DAS PAGES
		IF GOAPLICATIVO.FLAT = 1
			IF NKEYCODE = 2 AND nShiftAltCtrl = 2 && CRTL + SETA >>
				THIS.PAGES(THIS.ACTIVEPAGE).cmdAVANCAR.Click()
			ENDIF
			IF NKEYCODE = 26 AND nShiftAltCtrl = 2 && CRTL + SETA <<
				THIS.PAGES(THIS.ACTIVEPAGE).cmdVOLTAR.Click()
			ENDIF
		ENDIF
		
	PROC POSICIONARSELECAO
	**********************
		LPARAMETERS toATALHO AS Container, tnACAO AS Integer
		* POSICIONA INDICADOR DE SELEÇÃO NO ITEM INFORMADO.
		* tnACAO : 1 = EXIBIR 0 = OCULTAR
		LOCAL loPAGE AS Page
		
		* DESCOBRE QUAL A GUIA DO OBJETO
		loPAGE = toATALHO.Parent.PARENT.PARENT
		
		DO CASE
			CASE tnACAO = 0 && OCULTAR OBJETO
				loPAGE.scntBRANCO.scrollarea.shpSEL.Visible	= .F.
			
			CASE tnACAO = 1 && EXIBIR SELEÇÃO
				loPAGE.scntBRANCO.scrollarea.shpSEL.LEFT	= toATALHO.Left
				loPAGE.scntBRANCO.scrollarea.shpSEL.TOP		= toATALHO.TOP
				loPAGE.scntBRANCO.scrollarea.shpSEL.WIDTH	= toATALHO.WIDTH
				loPAGE.scntBRANCO.scrollarea.shpSEL.HEIGHT	= toATALHO.HEIGHT
			
				loPAGE.scntBRANCO.scrollarea.shpSEL.Visible	= .T.
			
			OTHERWISE
		ENDCASE

	ENDPROC

	PROC CARREGAICONES
		LOCAL loPAGINA, loPG AS Page
		LOCAL loICONE AS Image
		LOCAL lcRETORNO AS String
		
		* NECESSARIO DESATIVAR TODAS AS PAGES PARA QUE O SCROLL NÃO FIQUE TRAVADO (SÓ QUANDO MUDA DE ABA ANTES DE TERMINAR DE CARREGAR)
		FOR EACH loPG IN THIS.PAGES
			loPG.Deactivate()
		ENDFOR

		* NÃO SE PODE FECHAR O VOLPE ATE O TERMINO DE CARREGAR OS ICONES			
		_SCREEN.Closable = .F.
		loPAGINA = THIS.PAGES(THIS.ACTIVEPAGE)
		
		=MONTAPAGEDESKTOP(loPAGINA)
		IF NOT loPAGINA.CARREGADO
			loPAGINA.CARREGADO=.T.
			FOR EACH loICONE IN loPAGINA.scntBRANCO.SCROLLAREA.CONTROLS
				DOEVENTS
				IF UPPER(loICONE.BASECLASS) = 'CONTAINER'
					FOR EACH loIMG IN loICONE.CONTROLS
						IF UPPER(loIMG.NAME) = 'IMGICONE'
							* COMPARA ÍCONES SOB DEMANDA PARA O VOLPEWAW
							IF goAPLICATIVO.WAWATIVO = 1			

								lcRETORNO = WAW_COMPARAR( ALLTRIM(JUSTFNAME(loIMG.Tag)), .T. )
								
								IF goAPLICATIVO.IMGDESKTOP = 1
									IF EMPTY(lcRETORNO)
										loIMG.TAG				= WAW_COMPARAR( ALLTRIM(JUSTFNAME('\ICONES\BLANK.PNG')), .T. )
										loIMG.Parent.myPICTURE	= loIMG.TAG
									ENDIF
								ENDIF
							ENDIF

							THIS.SHOWICONE(loIMG)
						ENDIF
					ENDFOR
				ENDIF
			ENDFOR

		ENDIF

		* SÓ É POSSIVEL FECHAR O VOLPE APÓS OS ICONES TEREM SIDOS CARREGADOS		
		_SCREEN.Closable = .T.
	ENDPROC


	FUNC SHOWICONE &&(ESTA ROTINA FICAVA NO goDESKTOP. EU PASSEI PARA O PAGEFRAME PARA FICAR SOBRE DEMANDA)
		LPARAMETERS loICONE AS Object

		IF goAPLICATIVO.DEFAULTICO = 0
			loICONE.PICTURE		= loICONE.TAG
		ELSE
			loICONE.PICTUREVAL	= goAPLICATIVO.DEFAULTICOPVAL
		ENDIF
		
		loICONE.VISIBLE		= .T.
	ENDFUNC
	
ENDDEFINE

DEFINE CLASS CONECTADB AS Custom
	* CONTROLES DA CONEXÃO
	ALCA			= 0
	DRIVER			= ''
	BANCO			= ''
	NOMECONEXAO		= ''
	STRINGCONECTION	= ''
	SERVIDORBD		= ''
	PORTABD			= 0
	* USUARIO QUE SE CONECTOU
	USERNAME		= ''
	FK_USUARIO		= 0
	SUPERUSUARIO	= 0
	DS_EMAIL		= ''
	* USUARIO DO PERFIL (NAVEGAR COMO)
	USERNAMEPERFIL		= ''
	FK_USUARIOPERFIL	= 0
	* CONTROLES DO USUÁRIO
	DIREITOS				= ''
	DIREITOS_IMPRESSAO		= ''
	DIREITOS_EXPORTACAO		= ''
	DIREITOS_LGPDIMPRESSAO	= ''
	GRUPO				= ''
	ASSUNTOS			= '' &&ASSUNTOS RECEBIDOS POR USUÁRIO
	SENHA				= ''
	ULTCONECTA			= 0
	DEFINICOES			= ''
	OPENTRANSACTION		= 0
	TAMANHOGRUPO		= 1 &&POR DEFAULT TAMANHO DE GRUPO É CHAR(1)
    * ULTIMO COMANDO EXECUTADO (PARA RECONEXÃO)
    LASTCOMMAND			= ''
    LASTCURSOR			= ''
	* ERRO SQL (PARA ENVIO NO REPORT)
    LASTERRORSQL		= ''
    * MEDIDORES DE TRAFEGO 
    ID_SESSAO			= 0
    QT_TRAFEGOVAI		= 0
    QT_TRAFEGOVEM		= 0
    QT_QUERYS			= 0
    QT_TEMPO			= 0
	USERSALVARMAIL		= 0
	
	PROC INIT
		* CONTROLES DA CONEXÃO
		THIS.ALCA				= 0
		THIS.DRIVER				= ''
		THIS.BANCO				= ''
		THIS.NOMECONEXAO		= ''
		THIS.STRINGCONECTION	= ''
		* USUARIO QUE SE CONECTOU
		THIS.USERNAME		= ''
		THIS.FK_USUARIO		= 0
		THIS.SUPERUSUARIO	= 0
		THIS.DS_EMAIL		= ''
		* USUARIO DO PERFIL (NAVEGAR COMO)
		THIS.USERNAMEPERFIL		= ''
		THIS.FK_USUARIOPERFIL	= 0
		* CONTROLES DO USUÁRIO
		THIS.DIREITOS				= ''
		THIS.DIREITOS_IMPRESSAO		= ''
		THIS.DIREITOS_LGPDIMPRESSAO	= ''
		THIS.GRUPO				= ''
		THIS.SENHA				= ''
		THIS.ULTCONECTA			= 0
		THIS.DEFINICOES			= ''
	ENDPROC

	PROC BEGINTRANSACTION
		IF THIS.ALCA=0
			RETURN(.F.)
		ENDIF
		LOCAL lcCOMANDO AS String
		STORE ' ' TO lcCOMANDO
		
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			BEGIN TRANSACTION 
		ENDTEXT
		
		IF THIS.OPENTRANSACTION=1
			&& DO MENS WITH 'JÁ EXISTE UMA TRANSAÇÃO EM ABERTO.'
			RETURN (.F.)
		ENDIF

		=EXECUTASQL(lcCOMANDO)
		THIS.OPENTRANSACTION=1
	RETURN
	
	PROC ENDTRANSACTION
		LPARAMETERS tnOPC
		IF TYPE('tnOPC')<>'N'
			tnOPC=0
		ENDIF
		IF THIS.ALCA=0
			RETURN(.F.)
		ENDIF

		LOCAL lcCOMANDO AS String
		STORE ' ' TO lcCOMANDO
		
		IF tnOPC<0
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				ROLLBACK 
			ENDTEXT
		ELSE
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				COMMIT 
			ENDTEXT		
		ENDIF
		
		IF THIS.OPENTRANSACTION=0
			&& DO MENS WITH 'NÃO EXISTE UMA TRANSAÇÃO EM ABERTO.'
			RETURN (.F.)
		ENDIF

		THIS.OPENTRANSACTION=0
		=EXECUTASQL(lcCOMANDO)
	RETURN
	
	PROC APLICARPERFIL
		* CARREGAR PERFIL DO USUARIO
		goAPLICATIVO.PERFILDEFAULT()

		* CARREGANDO UMA A UMA
		IF NOT EMPTY(STREXTRACT(goCONEXAO.DEFINICOES,"<COR1>","<\COR1>"))
			goAPLICATIVO.COR1			= VAL(STREXTRACT(goCONEXAO.DEFINICOES,"<COR1>","<\COR1>"))
		ENDIF
		IF NOT EMPTY(STREXTRACT(goCONEXAO.DEFINICOES,"<COR2>","<\COR2>"))
			goAPLICATIVO.COR2			= VAL(STREXTRACT(goCONEXAO.DEFINICOES,"<COR2>","<\COR2>"))
		ENDIF
		IF NOT EMPTY(STREXTRACT(goCONEXAO.DEFINICOES,"<COREDIT>","<\COREDIT>"))
			goAPLICATIVO.COREDIT		= VAL(STREXTRACT(goCONEXAO.DEFINICOES,"<COREDIT>","<\COREDIT>"))
		ENDIF
		IF NOT EMPTY(STREXTRACT(goCONEXAO.DEFINICOES,"<COROBRIGATORIO>","<\COROBRIGATORIO>"))
			goAPLICATIVO.COROBRIGATORIO	= VAL(STREXTRACT(goCONEXAO.DEFINICOES,"<COROBRIGATORIO>","<\COROBRIGATORIO>"))
		ENDIF
		IF NOT EMPTY(STREXTRACT(goCONEXAO.DEFINICOES,"<GRIDLINES>","<\GRIDLINES>"))
			goAPLICATIVO.GRIDLINES		= VAL(STREXTRACT(goCONEXAO.DEFINICOES,"<GRIDLINES>","<\GRIDLINES>"))
		ENDIF
		IF NOT EMPTY(STREXTRACT(goCONEXAO.DEFINICOES,"<FONTNAME>","<\FONTNAME>"))
			goAPLICATIVO.FONTNAME		= ALLTRIM(STREXTRACT(goCONEXAO.DEFINICOES,"<FONTNAME>","<\FONTNAME>"))
		ENDIF
		IF NOT EMPTY(STREXTRACT(goCONEXAO.DEFINICOES,"<FONTSIZE>","<\FONTSIZE>"))
			goAPLICATIVO.FONTSIZE		= VAL(ALLTRIM(STREXTRACT(goCONEXAO.DEFINICOES,"<FONTSIZE>","<\FONTSIZE>")))
		ENDIF
		IF NOT EMPTY(STREXTRACT(goCONEXAO.DEFINICOES,'<DISPOSITIVOIMPRESSAO>','<\DISPOSITIVOIMPRESSAO>'))
			goAPLICATIVO.DISPOSITIVOIMPRESSAO	= VAL(ALLTRIM(STREXTRACT(goCONEXAO.DEFINICOES,'<DISPOSITIVOIMPRESSAO>','<\DISPOSITIVOIMPRESSAO>')))
		ENDIF
		IF NOT EMPTY(STREXTRACT(goCONEXAO.DEFINICOES,'<ESTATUAL>','<\ESTATUAL>'))
			goAPLICATIVO.ESTATUAL		= ALLTRIM(STREXTRACT(goCONEXAO.DEFINICOES,"<ESTATUAL>","<\ESTATUAL>"))
		ENDIF
		IF NOT EMPTY(STREXTRACT(goCONEXAO.DEFINICOES,'<PADRAOENVIOEMAIL>','<\PADRAOENVIOEMAIL>'))
			goAPLICATIVO.PADRAOENVIOEMAIL = ALLTRIM(STREXTRACT(goCONEXAO.DEFINICOES,"<PADRAOENVIOEMAIL>","<\PADRAOENVIOEMAIL>"))
		ENDIF
	ENDPROC
	
	PROC REEXIBIRDESKTOP
	********************
		PARAMETERS tnTROCASTYLE
		IF TYPE('tnTROCASTYLE') <> 'N'
			tnTROCASTYLE = 0
		ENDIF
		
		IF tnTROCASTYLE <> 0
			IF GOAPLICATIVO.FLAT = 0
				GOAPLICATIVO.FLAT = 1
			ELSE
				GOAPLICATIVO.FLAT = 0
			ENDIF
		ENDIF
		
		goCONEXAO.SHOWDESKTOP()
		goAPLICATIVO.CARGAZWS()
	ENDPROC

	PROC SHOWDESKTOP
		* NÃO MONTA DESKTOP CASO AINDA ESTEJA MONTANDO O DESKTOP ANTIGO
		IF goAPLICATIVO.DESKTOP_STILLRUN
			RETURN
		ENDIF
		
		* MARCANDO FLAG PARA INDICAR QUE DESKTOP ESTÁ SENDO MONTADO
		goAPLICATIVO.DESKTOP_STILLRUN = .T.
		
		* NÃO DEIXA FECHAR O VOLPE ENQUANTO O DESKTOP ESTA SENDO MONTADO			
		IF _SCREEN.Closable = .T.			
			_SCREEN.Closable = .F.
		ENDIF
		
		DO ESPERANDO WITH 'Montando desktop...'
		* MINIMIZANDO TODAS AS JANELAS
		LOCAL lnXI, lnQF AS Integer
		LOCAL lcFORMNAME AS String
		lnQF = _SCREEN.FORMCOUNT
		FOR lnXI = lnQF TO 1 STEP -1
			lcFORMNAME = UPPER(_SCREEN.FORMS(lnXI).NAME)
			IF lcFORMNAME='FRMDESKTOP' OR lcFORMNAME='FRMAPLICATIVO'
				* NÃO PRECISA MINIMIZAR
			ELSE
				IF TYPE('_SCREEN.FORMS(lnXI).WINDOWSTATE') <> 'U'
					_SCREEN.FORMS(lnXI).WINDOWSTATE = 1
				ENDIF
			ENDIF
		ENDFOR
		* VOLTANDO FOCO
		IF THIS.ALCA > 0
			RELEASE goDESKTOP
			DO MONTADESKTOP
			goDESKTOP.SHOW()
			
			*#FLAT - SETA WINDOWSTATE MAXIMIZADO
			IF GOAPLICATIVO.FLAT = 1
				goDESKTOP.WINDOWSTATE = 2
			ELSE
				IF goDESKTOP.WINDOWSTATE > 0
					goDESKTOP.VISIBLE		= .F.
					goDESKTOP.WINDOWSTATE	= 0
					goDESKTOP.VISIBLE		= .T.
				ENDIF
			ENDIF
		ENDIF
		
		* VOLTA FLAG DE EXECUÇÃO
		goAPLICATIVO.DESKTOP_STILLRUN = .F.
		
		WAIT CLEAR
		
		* APOS TER MONTADO O DESKTOP A OPÇÃO DE FECHAR O VOLPE VOLTA A SER ABILITADA			
		_SCREEN.Closable = .T.
	ENDPROC

	PROC HIDEDESKTOP
	ENDPROC

	PROC CONECTAR
		* ABRINDO ARQUIVO DE CONFIGURAÇÃO DAS CONEXÕES
		IF THIS.ALCA > 0
			THIS.DESCONECTAR()
		ENDIF
				
		IF goAPLICATIVO.WAWATIVO = 0
			* MODO PADRÃO DE FUNCIONAMENTO
			IF NOT FILE(goAPLICATIVO.ARQCONFIG)
				DO MENS WITH 'Erro para efetuar conexão - Arquivo de configuração não foi encontrado:'+goAPLICATIVO.ARQCONFIG
				RETURN
			ENDIF
			IF USED('CONFIG')
				USE IN CONFIG
			ENDIF
			TRY
				USE (goAPLICATIVO.ARQCONFIG) IN 0 ALIAS CONFIG
				SELE CONFIG
			CATCH
				DO MENS WITH 'Erro para abrir arquivo de configuração: '+goAPLICATIVO.ARQCONFIG
				CLOSE DATABASES
			ENDTRY
		ELSE
			* MODO DE FUNCIONAMENTO WAW (ARQUIVOS DENTRO DO BANCO DE DADOS)
			* STRING DE CONEXÃO É PASSADA POR PARAMETRO PELO STARTER (DADOS EM BASE64)

			LOCAL lnALCAWAW, lnSQLOK AS Integer
			LOCAL lcCOMANDO AS String

			lcCOMANDO	= STRCONV(goAPLICATIVO.PARAMETROEXE2,14)
			IF EMPTY(lcCOMANDO)
				DO MENS WITH 'Erro para acessar base de dados: (Configuração incompleta)'
				RETURN(.F.)
			ENDIF
			DO ESPERANDO WITH 'Conectando ao servidor de dados...'
			lnALCAWAW	= SQLSTRINGCONNECT(lcCOMANDO)
			WAIT CLEAR
			IF lnALCAWAW<0
				DO MENS WITH 'Erro para acessar base de dados (INICIALIZAÇÃO WAW)'
				RETURN(.F.)
			ENDIF
			* CONVERTENDO FORMATO DA TABELA DE CONFIGURAÇÕES DO BANCO DE DADOS PARA O FORMATO DO CONFIG.PWI ANTIGO
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					DS_NOME AS NOME,
					DS_DRIVER AS DRIVER,
					DS_SERVER AS SERVER,
					DS_USER AS "USER",
					DS_PWD AS PWD,
					DS_DBNAME AS DBNAME,
					DS_OUTROS AS OUTROS,
					IN_BASEREMOTA AS OFICIAL
				FROM
					WAW_CONEXAO
				ORDER BY
					DS_NOME
			ENDTEXT
			lnSQLOK	= SQLEXEC( lnALCAWAW, lcCOMANDO, 'CONFIG' )
			IF lnSQLOK<0
				DO MENS WITH 'Erro para acessar base de dados (INICIALIZAÇÃO WAW)'
				RETURN(.F.)
			ENDIF
			=SQLDISCONNECT(lnALCAWAW)
		ENDIF

		* EFETUANDO LOGIN DO USUÁRIO
		IF USED('CONFIG')
			* POSICIONANDO NA CONEXÃO (PASSADA COMO PARAMETRO DO EXE)
			LOCAL lnCONEXAO AS INTEGER
			lnCONEXAO = VAL( STREXTRACT(goAPLICATIVO.PARAMETROEXE,'CONNECTION=',';') )
			SELE CONFIG
			IF lnCONEXAO>=1 AND lnCONEXAO<=RECCOUNT()
				SELE CONFIG
				GO lnCONEXAO
				IF DELETED()
					GO TOP
				ENDIF
			ENDIF
			IF EMPTY(goAPLICATIVO.JOB_NAME)
				IF NOT EOF('CONFIG') AND RECCOUNT('CONFIG')=1 AND EMPTY(CONFIG.SERVER)
					* PRIMEIRA VEZ, AJUDAR A CRIAR CONEXAO
					DO FORM SYSTEM_SQLCONFIGURAR WITH SET('DATASESSION')
				ENDIF
				DO FORM SYSTEM_LOGIN
			ELSE
				* QUANDO O VOLPE É CHAMADO EM MODO SLAVE, NÃO TEM TELA DE LOGIN
				=CONECTASQL()
			ENDIF
		ENDIF
		IF THIS.ALCA>0 AND NOT EMPTY(THIS.NOMECONEXAO)
			* LIMPA STRINGS DE ALTO RISCO DE SEGURANÇA
			THIS.STRINGCONECTION	= ''
			THIS.SENHA				= ''
			* CONFIGURA EMPRESA DEFAULT DO USUÁRIO
			goAPLICATIVO.EMPRESADEFINIR('PADRAO')
			* VERIFICANDO SE É BASE OFICIAL
			IF TYPE('CONFIG.OFICIAL') = 'N'
				goAPLICATIVO.BASEOFICIAL = CONFIG.OFICIAL
			ENDIF
						
			* CARREGAR PADRÕES
			THIS.CARREGARPADROES()

			* CARREGANDO EMPRESAS E ESTOQUES
			goAPLICATIVO.CAREMPXEST()

			*goAPLICATIVO.FLAT = RETORNASET('SISTEMA.FLAT','N',0)
			
			* #FLATTEMP 
*!*				IF NOT FILE('C:\TEMP\FLAT.TXT')
*!*					*IF NOT ',' + ALLTRIM(UPPER(GOCONEXAO.USERNAME)) + ',' $ ',EWERTON,GALVAO,ROGERIO,BETO,ERNANDO,PAULO.CHAVES,EMERSON,PWI,' 
*!*					goAPLICATIVO.FLAT = 0
*!*					*ENDIF 
*!*				ENDIF 
			
			* #FLAT - CARREGA TABELA DE CORES 
			IF goAPLICATIVO.FLAT = 1
				TEXT TO lcCOMANDO NOSHOW PRETEXT 7
					SELECT 
						* 
					FROM 
						TS_FLATCORES
				ENDTEXT
				=PESQUISASQL(lcCOMANDO,'TMPCORES')
				
				SELE TMPCORES 
				GO TOP 
				SCAN WHILE NOT EOF()
					goAPLICATIVO.FLATCORES = goAPLICATIVO.FLATCORES + ',' + ALLTRIM(TRANSFORM(TMPCORES.NR_COR)) 
				ENDSCAN
				IF NOT EMPTY(goAPLICATIVO.FLATCORES)
					goAPLICATIVO.FLATCORES = goAPLICATIVO.FLATCORES + ","
				ENDIF
			ENDIF	 
		ENDIF
		THIS.APLICARPERFIL()
		IF USED('CONFIG')
			USE IN CONFIG
		ENDIF
	ENDPROC

	PROC MONTADIREITOS
		LOCAL lcCOMANDO AS String
		***********************************************************************************
		* DIREITOS DE ROTINA
		***********************************************************************************
		THIS.DIREITOS	= ''
		* MÓDULOS DO SISTEMA
		IF goAPLICATIVO.TITULOCOLUNA=1
			* COM TITULO NAS COLUNAS
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					MODU.*,
					COALESCE(COL.DS_COLUNA,' ') AS DS_GINOME,
					CAST(0 AS INTEGER) AS TG_GUIAHOME
				FROM
					TS_MODULOS MODU
					LEFT JOIN TS_MODULOSCOLUNAS COL ON MODU.NR_GUIA=COL.NR_GUIA AND MODU.DS_GI=COL.DS_GI
					[[JOIN]]
				WHERE
					MODU.TG_INATIVO=0
				ORDER BY
					[[ORDEM]]
					MODU.NR_GUIA,
					MODU.NR_TIPO,
					MODU.DS_GI,
					MODU.NR_POSICAO,
					MODU.PK_ID
			ENDTEXT
		ELSE
			* SEM TITULO NAS COLUNAS
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					MODU.*,
					' ' AS DS_GINOME,
					CAST(0 AS INTEGER) AS TG_GUIAHOME
				FROM
					TS_MODULOS MODU
				[[JOIN]]
				WHERE
					MODU.TG_INATIVO=0
				ORDER BY
					[[ORDEM]]
					MODU.NR_GUIA,
					MODU.NR_TIPO,
					MODU.DS_GI,
					MODU.NR_POSICAO,
					MODU.PK_ID
			ENDTEXT
		ENDIF

		* TRATAMENTO PARA ORDENAÇÃO DE GUIAS
		LOCAL lnEXISTE AS Integer
		STORE 0 TO lnEXISTE
		
		* VERIFICA SE TABELA ESPECIAL PARA ORDENAÇÃO DE MÓDULOS EXISTE
		lnEXISTE = SQLCOLUMNS(GOCONEXAO.ALCA,'TS_MODULOSORDEM','FOXPRO','TMPMODORDEM')
		IF lnEXISTE = 1 AND USED('TMPMODORDEM') AND RECCOUNT('TMPMODORDEM') > 0
			* SE EXISTIR, UTILIZA CAMPO DE ORDEM PARAMETRIZADO
			lcCOMANDO	= STRTRAN( lcCOMANDO, '[[JOIN]]', 'LEFT JOIN TS_MODULOSORDEM ORD ON ORD.NR_GUIA = MODU.NR_GUIA' )
			lcCOMANDO	= STRTRAN( lcCOMANDO, '[[ORDEM]]', 'COALESCE(ORD.NR_ORDEM,MODU.NR_GUIA),' )
		ELSE
			* SE NÃO, CONTINUA CARREGANDO E ORDENANDO DO MODO ANTIGO
			lcCOMANDO	= STRTRAN( lcCOMANDO, '[[JOIN]]', '')
			lcCOMANDO	= STRTRAN( lcCOMANDO, '[[ORDEM]]', '' )
		ENDIF
		
		IF USED('TMPMODORDEM')
			USE IN TMPMODORDEM
		ENDIF
		
		=PESQUISASQL(lcCOMANDO,'TMPSYS')
	
		* MONTA STRING DE DIREITOS
		SELE TMPSYS
		GO TOP
		SCAN WHILE NOT EOF()
			IF ISNULL(TMPSYS.DS_ROTINA)
				LOOP
			ENDIF
			* ARMAZENA FORMS QUE SÃO DO VOLPE PADRÃO
			IF goAPLICATIVO.VOLPEPADRAO = 1
				IF TYPE('TMPSYS.TG_PERSONAL') = 'N' AND TMPSYS.TG_PERSONAL = 1
					goAPLICATIVO.FORMSPERSONAL = goAPLICATIVO.FORMSPERSONAL+'#'+ALLTRIM(UPPER(TMPSYS.DS_ROTINA))
				ENDIF
			ENDIF

			* FUNÇÃO QUE VERIFICA SE GRUPO ESTÁ NA STRING OU NÃO
			IF VERIFGRUPOS(THIS.GRUPO,TMPSYS.DS_DIREITOS)
				THIS.DIREITOS = THIS.DIREITOS+'#'+ALLTRIM(UPPER(TMPSYS.DS_ROTINA))
			ENDIF
					
		ENDSCAN
		goAPLICATIVO.FORMSPERSONAL = goAPLICATIVO.FORMSPERSONAL + '#'
		THIS.DIREITOS = THIS.DIREITOS + '#'

		***********************************************************************************
		* DIREITOS DE EXPORTAÇÃO DE DADOS
		***********************************************************************************
		THIS.DIREITOS_EXPORTACAO	= ''
		IF TYPE('TMPSYS.DS_DIREITOEXPORTACAO') $ 'MC'			
			* MONTA STRING DE DIREITOS
			SELE TMPSYS
			GO TOP
			SCAN WHILE NOT EOF()
				IF ISNULL(TMPSYS.DS_ROTINA)
					LOOP
				ENDIF
				* FUNÇÃO QUE VERIFICA SE GRUPO ESTÁ NA STRING OU NÃO
				IF VERIFGRUPOS(THIS.GRUPO,TMPSYS.DS_DIREITOEXPORTACAO)
					THIS.DIREITOS_EXPORTACAO	= THIS.DIREITOS_EXPORTACAO + '#'+ ALLTRIM(TMPSYS.DS_ROTINA)
				ENDIF
				
			ENDSCAN
			THIS.DIREITOS_EXPORTACAO	= THIS.DIREITOS_EXPORTACAO + '#'
		ENDIF
		
		***********************************************************************************
		* DIREITOS DE IMPRESSÃO DE DADOS LGPD
		***********************************************************************************
		THIS.DIREITOS_LGPDIMPRESSAO = ''
		IF goAPLICATIVO.LGPD > 0
			SELE TMPSYS
			GO TOP
			SCAN WHILE NOT EOF()
				IF TMPSYS.TG_LGPDSENSIVEL = 0
					LOOP
				ENDIF 
				
				THIS.DIREITOS_LGPDIMPRESSAO = THIS.DIREITOS_LGPDIMPRESSAO + '#' + ALLTRIM(TMPSYS.DS_ROTINA)	
			ENDSCAN
			THIS.DIREITOS_LGPDIMPRESSAO = THIS.DIREITOS_LGPDIMPRESSAO + '#'
		ENDIF 
	ENDPROC

	PROC CARREGARPADROES
		goAPLICATIVO.ESTATUAL	= RETORNASET('ESTOQUE.PADRAO','C',0)
		LOCAL lcCOMANDO as String
		* LE ESTOQUE PADRÃO
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT
				*
			FROM
				TS_USUARIOS
			WHERE
				PK_ID=<<FK_USUARIO>>
		ENDTEXT
		lcCOMANDO = STRTRAN(lcCOMANDO,'<<FK_USUARIO>>',XX(THIS.FK_USUARIO))
		=PESQUISASQL(lcCOMANDO,'TMPUSUEMP')
		* MANTENDO COMPATIBILIDADE COM VERSÕES ANTERIORES
		IF TYPE('TMPUSUEMP.FK_ESTPADRAO') = 'C'
			goAPLICATIVO.ESTATUAL	= TMPUSUEMP.FK_ESTPADRAO
		ENDIF
		USE IN TMPUSUEMP
	ENDPROC

	PROC DESCONECTAR
		* RETIRA O DESKTOP
		IF TYPE('goDESKTOP')='O'
			goDESKTOP.RELEASE
		ENDIF
		* FECHA CONEXAO COM BANCO DE DADOS
		IF THIS.ALCA > 0
			DO USUCONECTADO WITH 0
			* GRAVA LOG DE LOGOUT DO SISTEMA + LOG DE TRAFEGO
			DO GRAVALOG WITH 'L', goCONEXAO.FK_USUARIO, 'TS_USUARIOS', 'LOGOUT->'+GETENV("USERNAME")+'\'+GETENV("COMPUTERNAME"), ''
			goCONEXAO.GRAVATRAFEGO_FIM()
			=SQLDISCONNECT(THIS.ALCA)
			THIS.INIT
		ENDIF
	ENDPROC
	
	PROC GRAVATRAFEGO_INI
	* GRAVA LOG DE INICIO DO TRAFEGO

		* VERIFICA SE EXISTE TABELA DE TRAFEGO
		DO LERTABLES WITH 'TS_TRAFEGO'
		IF ALLTRIM(UPPER(TMPTABLES.DS_TABLENAME)) <> 'TS_TRAFEGO'
			RETURN(.F.)
		ENDIF
		
		* GRAVA USUARIO E HORA DE INICIO DO LOG
		LOCAL lcCOMANDO AS String
		lcCOMANDO = 'SELECT * FROM TS_TRAFEGO WHERE 1=2'
		=PESQUISASQL(lcCOMANDO,'TMPTRAFEGO')
		
		SELE TMPTRAFEGO
		SCATTER NAME loREG 
		APPEND BLANK
		loREG.FK_USUARIO 	= goCONEXAO.FK_USUARIO
		loREG.DH_INICIO		= DATETIME()
		loREG.CD_SISTEMA	= 'ERP'
		loREG.DS_MAQUINA	= GETENV("COMPUTERNAME")
		loREG.DS_LOGINREDE	= GETENV("USERNAME")
		GATHER NAME loREG
		
		SELE TMPTRAFEGO
		goCONEXAO.ID_SESSAO = ATUSQL('A','TS_TRAFEGO')
		
		SELE TMPTRAFEGO
		USE IN TMPTRAFEGO
	
	ENDPROC
	
	PROC GRAVATRAFEGO_FIM
	* GRAVA LOG DE FIM DO TRAFEGO (LOGOUT)
		
		IF EMPTY(goCONEXAO.ID_SESSAO)
			RETURN(.F.)
		ENDIF
		
		LOCAL lcCOMANDO AS String
		lcCOMANDO = 'SELECT * FROM TS_TRAFEGO WHERE PK_ID = ' + XX(goCONEXAO.ID_SESSAO)
		=PESQUISASQL(lcCOMANDO,'TMPTRAFEGO')
		
		SELE TMPTRAFEGO
		SCATTER NAME loREG 
		loREG.DH_TERMINO		= DATETIME()
		loREG.QT_TRAFEGOVAI		= goCONEXAO.QT_TRAFEGOVAI
		loREG.QT_TRAFEGOVEM		= goCONEXAO.QT_TRAFEGOVEM
		loREG.QT_QUERYS			= goCONEXAO.QT_QUERYS
		loREG.QT_TEMPO			= goCONEXAO.QT_TEMPO
		GATHER NAME loREG
		
		SELE TMPTRAFEGO
		DO ATUSQL WITH 'M','TS_TRAFEGO','UPDATE=YES','DH_TERMINO,QT_TRAFEGOVAI,QT_TRAFEGOVEM,QT_QUERYS,QT_TEMPO'
		
		SELE TMPTRAFEGO
		USE IN TMPTRAFEGO
		
	ENDPROC
	
ENDDEFINE

DEFINE CLASS APLICATIVO AS Form
*********************************
	* PROPRIEDADES DO FORM 
	CAPTION			= 'NO-KILL'
	DATASESSION 	= 2
	COLLATE			= 'MACHINE' && MACHINE = DEFAULT
	* PARAMETROS PARA MINIMIZAR NA SYSTRAY
	PERMITESYSTRAY	= .F.
	BLOQSYSTRAY		= .F.
	MINSYSTRAY		= .F.
	* PARAMETROS PARA SERVIÇO DE ATENDIMENTO REMOTO
	PERMITESAR		= .T.
	* PARAMETROS BÁSICOS
	PARAMETROEXE	= tcPARAMEXE1
	PARAMETROEXE2	= tcPARAMEXE2
	* VERSÃO
	VERSAO			= '4.001.004'
	NOMEPROGRAMA	= 'Volpe'
	EMPRESA			= ''
	SISTEMA			= ''
	NSERIE			= ''
	NTLOGIN			= 0			&& LOGIN SEM SENHA
	HELPF1			= 0
	* ARQUIVOS E PASTAS
	ARQCONFIG		= 'CONFIG.PWI'
*!*		ARQSISTEMA		= 'SISTEMA.PWI'
	TRAVAARQ		= 'TRAVADO.SIT'
	PATHTEMP		= GETENV("TEMP")+'\PWI\'
	PATHDOC			= GETENV("TEMP")
	PATHUSERS		= '..\USERS\'
	PATHDOCVIEW		= '..\USERS\DOCVIEW\'
	PATHVOLPEPADRAO	= 'STOB\'
	PATHVOLPETEMP	= 'TEMP\'
	HOMEPATH		= ALLTRIM(SYS(5))+ALLTRIM(SYS(2003))
	* CONFIGURACOES DE FUNCIONAMENTO
	BASEOFICIAL			= 0
	TESTE				= .F.
	DEBUGSQL			= 0
	ULTPSQL				= ''
	NODELETE			= .F.						&& INDICA SE TRAVA DE DELETE ESTÁ ATIVDA OU NÃO
	TRAVASIS			= 0
	ZWS					= ''
	F4INCLUIR			= ''
	F4TITULO			= ''
	F4SQLALIAS			= ''
	TOPSELECT			= 500
	SEPARADOR			= '|'
	FERIADOS			= ''								&& STRING COM FERIADOS (VER ROTINA "CARGAFERIADOS")
	SYSTEMTABLES		= ''								&& STRING COM AS TABELAS UTILIZADAS NO SISTEMA (VER ROTINA "CARGASYSTEMTABLES")
	LASTREFESH			= DATETIME()
	OPNUMERO_PICT		= '99999999/99'						&& PICTURE DE ORDEM DE PRODUÇÃO
	CLAFIS_PICT			= '!!!'								&& PICTURE DE CLASSIFICAÇÃO FISCAL (NCM)
	ESTOQUE_PICT		= '99,999,999.999'					&& PICTURE DE QTD. ESTOQUE
	PREUNI_PICT			= '999,999,999.9999'				&& PICTURE DE VL. UNITARIO
	SEGMENTO_PICT		= 'X.XX.XXX'						&& PICTURE DE SEGMENTO
	CONTABIL_PICT		= 'X.XX.XXX'						&& PICTURE DO MÓDULO CONTÁBIL
	ESTATUAL			= SPACE(3)							&& ESTOQUE EM TRABALHO NO MOMENTO
	EMPATUAL			= SPACE(3)							&& EMPRESA EM TRABALHO NO MOMENTO
	EMPFILTRO			= "FK_EMPRESA<>'ZZZZ'"				&& FILTRO DE EMPRESAS DO USUÁRIO ATUAL
	EMPFILTROEXTRA		= " OR [TABELA].FK_EMPRESA = ''"	&& FILTRO DE EMPRESAS EXTRA (IMPACTA EM TODOS OS FILTROS DE EMPRESA)
	EMPFILTROSF12		= "FK_EMPRESA<>'ZZZZ'"				&& FILTRO DE EMPRESAS DO USUÁRIO CONFIGURADO SEM F12
	EMPFILTROCF12		= "FK_EMPRESA<>'ZZZZ'"				&& FILTRO DE EMPRESAS DO USUÁRIO CONFIGURADO COM F12
	EMPFKSIM			= ''								&& TABELAS QUE TEM FILTRO POR EMPRESA
	LOGTABSIM			= ''								&& TABELAS QUE TEM LOGSYS
	EMPXEST				= ''								&& EMPRESAS E CÓDIGOS DE ESTOQUE
	VALIDARINIT 		= 0									&& QUANDO >0, NÃO EXIBE MENSAGEM DE ERRO NA FUNC. VALIDAR
	MENSFECHADO			= ' '								&& MENSAGEM UTILIZADA PARA INDICAR FECHAMENTO
	REGTROCA			= 0									&& REGISTRO DE TROCA DE DADOS (SCATTER/GATHER)
	QT_QTDECIMAIS		= 0									&& QTD DE CASAS DECIMAIS PARA PICTURE DE QUANTIDADE
	QT_PUDECIMAIS 		= 0									&& QTD DE CASAS DECIMAIS PARA PREÇO UNITÁRIO
	TRANSPORTARDADOS	= -1								&& OPÇÃO PARA EXPORTAR DADOS PELA TELA DE PROPRIEDADES
	AUTENTICALOGIN		= 'OFF'								&& OPÇÃO PARA AUTENTICAR LOGIN DO USUARIO COM SENHA + GRUPOS
	ERROTRATADO			= 'OFF'								&& OPÇÃO PARA TRATAMENTO DE ERRO PELO PROGRAMADOR, NO SYS_FUNCOES PELA FUNCAO VERROTRATADO
	* PERFIL DO USUARIO (CUIDADO: ROTINA PARA SETAR VALOR DEFAULT EM SEPARADO)
	COR1					= 0
	COR2					= 0
	COREDIT					= 0
	COROBRIGATORIO			= RGB(255,255,150)
	CORBASEOFICIAL			= RGB(212,182,255) && ROXO
	CORBASEHOMOLOGACAO		= RGB(159,159,255) && AZUL CLARO
	CORBASETREINAMENTO		= RGB(255,188,121) && LARANJA
	FONTALTERNATIVA 		= 0 && FONTE ALTERNATIVA PARA TEXTBOX EM MODO CLÁSSIO = Consolas, 10, Bold
	FONTNAME				= 'Arial'
	FONTSIZE				= 9
	GRIDLINES				= 0
	DISPOSITIVOIMPRESSAO	= 1
	PADRAOENVIOEMAIL		= ''
	* CONFIGURAÇÃO DE LOGOTIPOS
	LOGOTIPO		= 'IMAGES\LOGO.BMP'
	LOGOREPORT		= 'IMAGES\LOGO.BMP'
	LOGOMULTIEMPRESA= .F.
	EMPLOGO			= ''	
	* CONFIGURAÇÕES DE RESOLUÇÃO
	MINALTURA		= 601
	MINLARGURA		= 801
	* IMPRESSAO
	DEVICE			= 1
	LINHA			= ''
	CHRCOMPRIMIR1	= CHR(15)
	CHRCOMPRIMIR0	= CHR(18)
	ARQIMPRESSAO	= ''
	ALCAIMPRESSAO	= -1
	PRNCR			= CHR(13)					&& Carriage Return	(0D)
	PRNLF			= CHR(13)+CHR(10)			&& Carriage Return+Line feed (0D0A)
	PRNFF			= CHR(12)					&& Form Feed		(0C)
	* SLAVE
	JOB_NAME		= ''
	JOB_PROEXEC		= DTOT({})
	JOB_ULTEXEC		= DTOT({})
	JOB_STILLRUN	= .F.
	JOB_FECHARFIM	= 0
	JOB_ERROS		= ''
	JOB_PRIEXEC		= DTOT({})
	JOB_DURAMAX		= 1440		&& PADRÃO 24HS - 1440MIN 
	* REGISTRO DO SISTEMA (COMPRA, ALUGUEL, FREEWARE, DEMO, ETC.. )
	VALIDADE		= -1
	* PARÂMETROS DE ALARMES DO SISTEMA
	QTDMENSALARMES	= 0
	* WINDOWS APPLICATION ANYWHERE (WAW)
	WAWATIVO		= 0
	WAWVERSION		= 0
	WAWTESTE		= 0
	WAWCALLEDFORM	= ''
	* EXECUÇÃO DE ROTINAS
	DESKTOP_STILLRUN= .F.
	F4_STILLRUN		= .F.
	AUTOCONTEXTO	= ''
	* INDICADOR DE VOLPE PADRÃO
	VOLPEPADRAO		= 0
	FORMSPERSONAL	= ''
	VERSAOPADRAO	= ''
	* GRADE DE PRODUTOS (COR/TAMANHO)
	PRODUTOGRADE	= 0
	* DESKTOP - TITULO NAS COLUNAS E FLUXO
	FLUXOMODULO		= 0
	TITULOCOLUNA	= 0
	* LICENCA DO PRODUTO VOLPE
	CD_KEY			= ''
	REGISTRADO		= 0
	DATAEXPIRA		= {//}
	* MODULOS DO SISTEMA PELA TAB. DE FECHAMENTOS
	MODULOSATIVOS	= ''
	* ICONE DEFAULT
	DEFAULTICOPVAL	= ''
	DEFAULTICO		= 0
	* ALIAS DO REPORT
	ALIASREPORT		= 0
	ALIASREPORTGRUPO= ''
	IMGDESKTOP		= 0
	* REPORT DE ERRO (-1 - NÃO ENVIA REPORT DE ERRO / 0 - REPORT PADRÃO POR CDO / 1 - REPORT VIA MAPI)
	REPORTERRO		= 0
	* INDICA SE USUARIO POSSUI FAVORITOS CADASTRADOS (1 = POSSUI, 0 = NÃO POSSUI)
	FAVORITOS		= 0
	MEUSFAVORITOS	= ''
	* PROPRIEDADE PARA DEFINIR SE AS TEXTBOX SERÃO LOWERCASE
	LOWERCASE		= 0
	* PARAMETRO PARA HABILITAR TIMEZONE DIFERENCIADO
	TIMEZONE		= ''
	FLAT			= 0
	FLATFONT1		= 'Segoe UI Light' && TÍTULOS  
	FLATFONT2		= 'Segoe UI'	   && CONTEÚDO 
	FLATFONTDADOS	= 'Consolas'	   && DADOS
	FLATCORES 		= ''
	FLATCORDEFAULT	= 6179124		   && AZUL PETRÓLEO
	LOGPERF			= 0					&& LIGA\DESLIGA LOG DE PERFORMANCE
	LOGPERFTXT		= ''				&& TXT PARA LOGAR PERFORMANCE DE OPERAÇÕES EM BANCO (ATUSQL, EXECUTASQL, PESQUISASQL)
	* PROPRIEDADE PARA GUARDAR UTC ATUAL POR ESTADO
	UTC				= ''
	* AUTO ENCERRAMENTO DO SISTEMA
	AUTOCLOSE		= ''
	DH_ABERTURA		= ''
	ALERTAHELP		= 'OFF' 
	LGPD			= 0														&& FLAG P/ INDICAR SE O LGPD ESTA HABILITADO OU NÃO NO SISTEMA
	CAMPOSLGPD		= 'DS_NOME,DS_FONE,DS_EMAIL,NR_CNPJ,DS_RG,DS_ENDERECO,DS_CEP,DS_BAIRRO,DS_BAICOB,DS_CEPCOB,DS_CEPFAT,DS_ENDFAT,DS_BAIFAT,DS_ENDENT,DS_BAIENT,DS_CEPENT,NR_CPF'	&& CAMPOS SIGILOSOS DEFAULT  
	REPORTALIAS		= ''
	GRADEEXCLUIR	= 0
	
	ADD OBJECT tmrTIMER AS TIMER WITH ;
		INTERVAL = 60000, ;
		ENABLED = .F.
		
	PROC LOAD
	*********
		DO AMBIENTAR
	ENDPROC

	PROC INIT
	*********
		* MATA PARAMETROS INICIAIS
		RELEASE tcPARAMEXE1, tcPARAMEXE2

		* DEFINE COMO AREA DE TESTES
*		IF '\TESTES' $ CURDIR()
		IF _VFP.StartMode = 0
			THIS.TESTE = .T.
		ENDIF

		* SETANDO PERFIL DEFAULT
		THIS.PERFILDEFAULT()

		* VERIFICANDO SE FOI CHAMADO EM MODO SLAVE (ESCRAVO)
		THIS.VERIFICARSLAVE()

		* DEFININDO PASTAS LOCAIS
		* (0X5=MEUSDOCUMENTOS)
		LOCAL loSHELL, loFOLDER AS Object
		loShell			= CREATEOBJ('Shell.Application')
		loFolder		= loShell.NameSpace(0x5)
		IF TYPE('loFolder.Self.Path') = 'C'
			THIS.PATHDOC	= loFolder.Self.Path
		ENDIF
		RELEASE loSHELL
		RELEASE loFOLDER
		* USERS
		THIS.PATHUSERS		= FULLPATH('..\USERS\')
		IF THIS.TESTE
			THIS.PATHUSERS	= FULLPATH('USERS\')
		ENDIF
		THIS.PATHDOCVIEW	= THIS.PATHUSERS + 'DOCVIEW\'

		THIS.TRAVAARQ		= 'TRAVADO.SIT'

		LOCAL lcCOMANDO AS String
		* MODO WAW (WINDOWS APPLICATION ANYWHERE): ARQUIVOS DENTRO DO BANCO DE DADOS
		IF 'WAW=ON' $ THIS.PARAMETROEXE
			THIS.WAWATIVO	= 1
		ENDIF
		
		LOCAL lcICO AS String
		STORE '' TO lcICO
		
		LOCAL loPICVAL AS Object

		* ICONE DEFAULT PARA TODO O SISTEMA		
		IF 'NOICON' $ THIS.PARAMETROEXE
			THIS.DEFAULTICO	= 1
			lcICO = 'ICONES\DEFAULT.ICO'
			IF FILE(lcICO)
				TRY
					loPICVAL = LOADPICTURE('ICONES\DEFAULT.ICO')
				CATCH
				ENDTRY
				IF VARTYPE(loPICVAL) = 'O'
					THIS.DEFAULTICOPVAL	= loPICVAL
				ELSE
					THIS.DEFAULTICOPVAL	= ''
				ENDIF
			ENDIF
		ENDIF
		
		* DATA/HORA DE ABERTURA DO SISTEMA
		THIS.DH_ABERTURA = DATETIME()
		
	ENDPROC

	PROC CARGAVALIDADE
		LOCAL lcCOMANDO AS String
		LOCAL ldSERVER AS Date

		ldSERVER = DATASERVER()
		THIS.VALIDADE	= 1

		DO LERTABLES WITH 'TS_%'

		* VERIFICA SE EXISTE HELP NO SISTEMA
		SELE TMPTABLES
		LOCATE FOR ALLTRIM(UPPER(TMPTABLES.DS_TABLENAME))=='TS_AJUDA'
		IF NOT EOF()
			goAPLICATIVO.HELPF1 = 1
		ENDIF

		* VERIFICA VALIDADE DO SISTEMA
		SELE TMPTABLES
		LOCATE FOR ALLTRIM(UPPER(TMPTABLES.DS_TABLENAME))=='TS_DUMMY'
		IF NOT EOF()
			lcCOMANDO	= 'SELECT * FROM TS_DUMMY WHERE PK_ID=1'
			=PESQUISASQL(lcCOMANDO,'TMPDUMMY')

			* VERIFICANDO VALIDADE DO SISTEMA
			IF TMPDUMMY.DT_CONTROLE < DATASERVER()
				TEXT TO lcMENS NOSHOW PRETEXT 3
					ACESSO NEGADO - VALIDADE VENCIDA.

					Este sistema expirou e não pode mais ser acessado
					até que sua validade seja renovada.
				ENDTEXT
				DO MENS WITH lcMENS
				THIS.VALIDADE	= 0
			ENDIF

			* VERIFICAÇÃO DE VERSÃO DO SISTEMA
			IF NOT EMPTY(TMPDUMMY.DS_VERSAOMINIMA) AND goAPLICATIVO.VERSAO < ALLTRIM(TMPDUMMY.DS_VERSAOMINIMA)
				TEXT TO lcMENS NOSHOW PRETEXT 3
					ATENÇÃO - SISTEMA FORA DE VERSÃO.

					A versão atual deste programa está defasada e não atende os
					requisitos mínimos para acessar a base de dados do sistema.
					Versão mínima exigida: [VERSAOMINIMA]
					Versão do programa: [VERSAOEXE]
					
					Atualize o seu programa (EXE) para evitar possíveis erros de incompatibilidade.
				ENDTEXT
				lcMENS = STRTRAN(lcMENS,'[VERSAOMINIMA]',TMPDUMMY.DS_VERSAOMINIMA)
				lcMENS = STRTRAN(lcMENS,'[VERSAOEXE]',goAPLICATIVO.VERSAO)
				DO MENS WITH lcMENS	
			ENDIF
			
			* VERIFICAÇÃO DE NOVA VERSÃO DO SISTEMA (SOMENTE SQL SERVER)
			IF goCONEXAO.BANCO = 'SQL'
				* SE CAMPO DE VERSÃO NÃO EXISTIR, TENTA CRIAR
				IF TYPE('TMPDUMMY.DS_VERSAOEXE') <> 'C'
					lcCOMANDOVERSAO = 'ALTER TABLE TS_DUMMY ADD DS_VERSAOEXE CHAR(10)'
					lnRET=SQLEXEC(GOCONEXAO.ALCA,lcCOMANDOVERSAO)
					lcCOMANDOVERSAO = "UPDATE TS_DUMMY SET DS_VERSAOEXE = '' WHERE PK_ID = 1"
					lnRET=SQLEXEC(GOCONEXAO.ALCA,lcCOMANDOVERSAO)
					
					* RECARREGA TMPDUMMY
					lcCOMANDO	= 'SELECT * FROM TS_DUMMY WHERE PK_ID=1'
					lnRET=PESQUISASQL(lcCOMANDO,'TMPDUMMY')
				ENDIF
				
				SELE TMPDUMMY
				IF TYPE('TMPDUMMY.DS_VERSAOEXE') = 'C'
					IF ALLTRIM(TMPDUMMY.DS_VERSAOEXE) < goAPLICATIVO.VERSAO OR EMPTY(ALLTRIM(TMPDUMMY.DS_VERSAOEXE))
						* ATUALIZAÇÃO DE TABELAS BÁSICAS DO SISTEMA - SOMENTE SCRIPTS QUE POSSUEM IMPACTOS NA BASE DE DADOS
						LOCAL lnRETORNO AS Integer
						DO FORM SYSTEM_AJUSTARDB TO lnRETORNO
					ENDIF
				ENDIF
			ENDIF
			
			* VERIFICA SE É UM VOLPE PADRÃO
			IF TYPE('TMPDUMMY.DS_VERSAO') = 'C' AND ALLTRIM(TMPDUMMY.DS_VERSAO) = 'STANDARD'
				goAPLICATIVO.VOLPEPADRAO = 1
			ENDIF
			
			* INFORMAÇÕES DA LICENÇA DO SISTEMA
			IF TYPE('TMPDUMMY.CD_KEY') <> 'C'
				goAPLICATIVO.CD_KEY = 'SEM NR.LICENÇA'
				goAPLICATIVO.REGISTRADO = 1
			ELSE
				goAPLICATIVO.CD_KEY = TMPDUMMY.CD_KEY
				IF VALIDA_CDKEY(goAPLICATIVO.CD_KEY)
					goAPLICATIVO.REGISTRADO = 1
					goAPLICATIVO.DATAEXPIRA = goAPLICATIVO.MONTAR_EXPIRACAO()
				ENDIF
			ENDIF

			* VERIFICANDO VALIDADE DO SISTEMA
			IF NOT EMPTY(goAPLICATIVO.DATAEXPIRA)
				IF ldSERVER > goAPLICATIVO.DATAEXPIRA
					THIS.REGISTRADO = 1
					THIS.VALIDADE = 0
					TEXT TO lcMENS NOSHOW PRETEXT 3
						ACESSO NEGADO - VALIDADE VENCIDA.

						Este sistema expirou e não pode mais ser acessado
						até que sua validade seja renovada.
					ENDTEXT
					DO MENS WITH lcMENS
				ENDIF
				* AVISO DE VALIDADE PROXIMA DA DATA PARA EXPIRAR
				IF ldSERVER > (goAPLICATIVO.DATAEXPIRA-7) AND ldSERVER < goAPLICATIVO.DATAEXPIRA
					LOCAL lcDIASTOEXPIRA as String
					lcDIASTOEXPIRA = TRANSFORM(goAPLICATIVO.DATAEXPIRA-TTOD(ldSERVER))
					TEXT TO lcMENS NOSHOW PRETEXT 3
						ATENÇÃO.
						SEU SISTEMA EXPIRA EM [[DIASTOEXPIRA]] DIA(s).
						
						O SISTEMA É VALIDO ATÉ [[DT_VALIDADE]].
						Após esta data o sistema não poderá mais ser acessado
						até que sua validade seja renovada.
					ENDTEXT
					lcMENS = STRTRAN(lcMENS,'[[DIASTOEXPIRA]]',lcDIASTOEXPIRA)
					lcMENS = STRTRAN(lcMENS,'[[DT_VALIDADE]]',DTOC(goAPLICATIVO.DATAEXPIRA))
					DO MENS WITH lcMENS
				ENDIF
			ENDIF
			
			USE IN TMPDUMMY
		ENDIF
		USE IN TMPTABLES
	ENDPROC

	PROC MONTAR_EXPIRACAO && EXTRAI DA DATA DE EXPIRAÇÃO DO CD_KEY
		LOCAL ldEXP AS Date
		LOCAL lcMES, lcANO, lcKEY
		
		lcKEY = SUBSTR(goAPLICATIVO.CD_KEY,16,4)
		
		DO CASE 
			CASE 'L' $ lcKEY
				ldEXP= ''
				
			CASE 'E' $ lcKEY
				lcMES = STRZERO(ASC(SUBSTR(lcKEY,4,1))-64,2)
				lcANO = SUBSTR(lcKEY,2,2)
				ldEXP = CTOD('01/'+lcMES+'/'+lcANO)
				ldEXP = GOMONTH(ldEXP,1)
				
			OTHERWISE
				ldEXP= ''
		ENDCASE
		
		RETURN(ldEXP)
	ENDPROC

	PROC CARREGARWAWVERSION
		LOCAL lnALCAFILE AS Integer
		
		IF THIS.WAWATIVO = 1

			* TABELA DE CONTROLE DO VOLPE WAW
			lcCOMANDO	= 'SELECT * FROM WAW_CONTROLE WHERE PK_ID=1'
			=PESQUISASQL(lcCOMANDO,'TMPWAWCONTROLE')
			
			* VERIFICANDO VERSÃO WAW PARA ATUALIZAÇÃO DE ARQUIVOS FUTURAMENTE
			THIS.WAWVERSION	= TMPWAWCONTROLE.NR_WAWVERSION
			
			* VERIFICA SE ESTÁ SENDO RODADO EM AMBIENTE DE TESTE UM SISTEMA COM TECNOLOGIA WAW
			** OPÇÃO UTILIZADA PARA IDENTIICAR FORM'S QUE NÃO ESTÃO SENDO RODADOS PELO "CHAMAFORM()"
			IF goAPLICATIVO.TESTE
				IF TYPE('TMPWAWCONTROLE.TG_MODOWAW') = 'N'
					IF TMPWAWCONTROLE.TG_MODOWAW = 1
						goAPLICATIVO.WAWTESTE = 1
					ENDIF
				ENDIF
			ENDIF
			
			* TRAVA DO SISTEMA VOLPE WAW
			IF TYPE('TMPWAWCONTROLE.TG_WAWBLOQUEADO') = 'N'
				IF TMPWAWCONTROLE.TG_WAWBLOQUEADO >= 1
					DO PROGTRAVADO
					* TEM 1 SEGUNDO PARA "FURAR O BLOQUEIO" COM CTRL+F1
					LOCAL lnKEY AS INTEGER
					lnKEY = INKEY(1)
					IF lnKEY<>94
						DO ENCERRAR
					ENDIF
					RELEASE lnKEY
					goAPLICATIVO.TRAVASIS = -1	&& NUNCA DERRUBAR
				ENDIF
			ENDIF
			
			IF USED('TMPWAWCONTROLE')
				USE IN TMPWAWCONTROLE
			ENDIF
			
		ENDIF
	ENDPROC

	PROC Min2Systray
		IF NOT THIS.PERMITESYSTRAY
			RETURN
		ENDIF
		goAPLICATIVO.MINSYSTRAY = .T.
		THIS.mySYSTRAY.ADDicontosystray()
		_SCREEN.Hide()
	ENDPROC

	PROC Bloq2Systray
		IF NOT THIS.PERMITESYSTRAY
			RETURN
		ENDIF
		goAPLICATIVO.MINSYSTRAY	= .T.
		goAPLICATIVO.BLOQSYSTRAY= .T.
		THIS.mySYSTRAY.ADDicontosystray()
		_SCREEN.Hide()		
	ENDPROC

	PROC CAREMPXEST
		LOCAL lcCOMANDO AS String
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT
				PK_ID,
				FK_ESTOQUE
			FROM
				TB_EMPRESAS
		ENDTEXT
		=PESQUISASQL(lcCOMANDO,'TMPEMPXEST')
		SELE TMPEMPXEST
		GO TOP
		goAPLICATIVO.EMPXEST	= ''
		SCAN WHILE NOT EOF()
			goAPLICATIVO.EMPXEST = goAPLICATIVO.EMPXEST + ;
									PADR(TMPEMPXEST.PK_ID,3) + '#' + PADR(TMPEMPXEST.FK_ESTOQUE,3) + ;
									CHR(13)
		ENDSCAN
		USE IN TMPEMPXEST

	PROC VERIFICARSLAVE
		* GUARDA OS VALORES DE SLAVE
		LOCAL lcAUX AS String
		STORE '' TO lcAUX
		IF 'JOB=' $ THIS.PARAMETROEXE
			lcAUX	= STREXTRACT(THIS.PARAMETROEXE,'JOB=',';')
		ENDIF
		THIS.JOB_NAME	= lcAUX

	PROC PERFILDEFAULT
		* SETAR VALORES DEFAULT DO PERFIL
		THIS.COR1					= RGB(255,255,255)
		THIS.COR2					= RGB(224,244,255)
		THIS.COREDIT				= RGB(250,250,235)
		THIS.GRIDLINES				= 3
		THIS.DISPOSITIVOIMPRESSAO	= 1

	PROC CARGAZWS
		* CARREGAR PARAMETROS GERAIS DO SISTEMA
		THIS.ZWS = ''
		IF goCONEXAO.ALCA<=0
			RETURN
		ENDIF
		LOCAL lcCOMANDO, lcAUX AS String
		LOCAL lnAUX AS Integer

		lcCOMANDO = 'SELECT * FROM TS_PARAMETROS WHERE TG_INICIO=1'
		=PESQUISASQL(LCCOMANDO,'TMPZWS')
		SELE TMPZWS
		GO TOP
		SCAN WHILE NOT EOF()
			IF ISNULL(TMPZWS.DS_CONTEUDO)
				LOOP
			ENDIF
			THIS.ZWS = THIS.ZWS + ;
						'<'+ALLTRIM(TMPZWS.DS_PARAMETRO)+'>'+;
						ALLTRIM(TMPZWS.DS_CONTEUDO)+;
						'</'+ALLTRIM(TMPZWS.DS_PARAMETRO)+'>'
		ENDSCAN
		USE IN TMPZWS
		lcAUX	= RETORNASET('OPNUMERO.PICTURE','C',1)
		IF NOT EMPTY(lcAUX)
			THIS.OPNUMERO_PICT	= lcAUX
		ENDIF
		lcAUX	= RETORNASET('CLAFIS.PICTURE','C',1)
		IF NOT EMPTY(lcAUX)
			THIS.CLAFIS_PICT	= lcAUX
		ENDIF

		* MASCARA PARA PREÇO UNITÁRIO
		lcAUX	= RETORNASET('PREUNI.PICTURE','C',1)
		IF NOT EMPTY(lcAUX)
			THIS.PREUNI_PICT	= lcAUX
		ENDIF
		* QTD DE DECIMAIS DO PREÇO UNITÁRIO
		lnAUX	= LEN( STREXTRACT(THIS.PREUNI_PICT,'.','') )
		lnAUX	= IIF( lnAUX<=0, 4, lnAUX )
		THIS.QT_PUDECIMAIS	= lnAUX

		* MASCARA PARA QUANTIDADE DE ESTOQUE
		lcAUX	= RETORNASET('ESTOQUE.PICTURE','C',1)
		IF NOT EMPTY(lcAUX)
			THIS.ESTOQUE_PICT	= lcAUX
		ENDIF
		* QTD DE DECIMAIS DA QUANTIDADE DE ESTOQUE
		lnAUX	= LEN( STREXTRACT(THIS.ESTOQUE_PICT,'.','') )
		lnAUX	= IIF( lnAUX<=0, 3, lnAUX )
		THIS.QT_QTDECIMAIS	= lnAUX

		lcAUX	= RETORNASET('SEGMENTOS.PICTURE','C',1)
		IF NOT EMPTY(lcAUX)
			THIS.SEGMENTO_PICT	= lcAUX
		ENDIF
		lcAUX	= RETORNASET('CONTABIL.PICTURE','C',1)
		IF NOT EMPTY(lcAUX)
			THIS.CONTABIL_PICT	= lcAUX
		ENDIF
		* REPORT DE ERRO (-1 - NÃO ENVIA REPORT DE ERRO / 0 - REPORT PADRÃO POR CDO / 1 - REPORT VIA MAPI)
		lnAUX	= RETORNASET('SISTEMA.REPORTERRO','N',1)
		THIS.REPORTERRO = lnAUX

		* AUTENTICAÇÃO DE USUARIO POR SENHA + GRUPOS
		lcAUX	= RETORNASET('SISTEMA.AUTENTICALOGIN','C',1)
		IF NOT EMPTY(lcAUX)
			THIS.AUTENTICALOGIN = lcAUX
		ENDIF
		
		lcAUX	= RETORNASET('SISTEMA.TIMEZONE','C',1)
		IF lcAUX == 'ON'
			THIS.TIMEZONE = 'ON'
		ELSE
			THIS.TIMEZONE = 'OFF'
		ENDIF
		
		* AUTOCLOSE DO SISTEMA
		lcAUX	= RETORNASET('SISTEMA.AUTOCLOSE','C',1)
		IF LEN(lcAUX) = 5
			THIS.AUTOCLOSE = lcAUX
		ENDIF

	ENDPROC

	PROC CARGATABLOG
		* CARREGA STRING DE TABELAS QUE PODEM GRAVAR LOGSYS
		LOCAL lcTABELA AS String
		DO LERTABLES WITH 'LG_%'
		IF USED('TMPTABLES')
			THIS.LOGTABSIM	= ''
			SELE TMPTABLES
			GO TOP
			SCAN WHILE NOT EOF()
				lcTABELA	= ALLTRIM(UPPER(TMPTABLES.DS_TABLENAME))
				IF LEFT( lcTABELA,3 ) <> 'LG_'
					LOOP
				ENDIF
				THIS.LOGTABSIM	= THIS.LOGTABSIM + SUBSTR( lcTABELA,4 ) + '#'
			ENDSCAN
			IF NOT EMPTY(THIS.LOGTABSIM)
				THIS.LOGTABSIM	= '#' + THIS.LOGTABSIM
			ENDIF
			USE IN TMPTABLES
		ENDIF
	
	PROC CARGACOLUMNS
		* CARREGA STRING DE TABELAS QUE NECESSITAM DE FILTRO POR EMPRESA
		LOCAL lcTABELA AS String
		DO LERCOLUMNS WITH 'COLUNA', 'FK_EMPRESA', 'UNIVERSO=VT;'
		IF USED('TMPCOLUMNS')
			THIS.EMPFKSIM = ''
			SELE TMPCOLUMNS
			GO TOP
			SCAN WHILE NOT EOF()
				*lcTABELA = ALLTRIM(UPPER(TMPCOLUMNS.DS_TABELA))
				lcTABELA = '#'+ALLTRIM(UPPER(TMPCOLUMNS.DS_TABELA))+'#'
				THIS.EMPFKSIM = THIS.EMPFKSIM + lcTABELA + CHR(13)
			ENDSCAN
			USE IN TMPCOLUMNS
		ENDIF
	
	PROC EMPRESADEFINIR
		* ATUALIZA CONTROLES DE VISUALIZAÇÃO DE EMPRESA
		LPARAMETERS tcEMPRESA AS String
		IF TYPE('tcEMPRESA') <> 'C'
			tcEMPRESA	= ''
		ENDIF
*!*			IF EMPTY(tcEMPRESA)
*!*				RETURN
*!*			ENDIF

		LOCAL lcCOMANDO, lcDS_EMPDIREITO, lcDS_EMPFORA, lcAUX, lcEMPS AS String
		STORE '' TO lcCOMANDO, lcDS_EMPDIREITO, lcDS_EMPFORA, lcAUX, lcEMPS

		* LE EMPRESA PADRÃO E DIREITOS
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT
				*
			FROM
				TS_USUARIOS
			WHERE
				PK_ID=<<FK_USUARIO>>
		ENDTEXT
		lcCOMANDO = STRTRAN(lcCOMANDO,'<<FK_USUARIO>>',XX(goCONEXAO.FK_USUARIOPERFIL))
		=PESQUISASQL(lcCOMANDO,'TMPUSUEMP')

		* MANTENDO COMPATIBILIDADE COM VERSÕES ANTERIORES
		IF TYPE('TMPUSUEMP.FK_EMPPADRAO')<>'C'
			RETURN
		ENDIF

		lcDS_EMPDIREITO	= TMPUSUEMP.DS_EMPDIREITO

		* INDICANDO QUE É PARA USAR A EMPRESA PADRAO DO USUARIO
		IF tcEMPRESA='PADRAO'
			tcEMPRESA = TMPUSUEMP.FK_EMPPADRAO
		ENDIF
		IF ISNULL(tcEMPRESA)
			tcEMPRESA = SPACE(3)
		ENDIF

		* EMPRESAS FORA DE USO, POR PADRÃO NÃO PODEM SER USADAS 
		* MANTENDO COMPATIBILIDADE COM VERSÕES ANTERIORES
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT
				*
			FROM
				TB_EMPRESAS
		ENDTEXT
		=PESQUISASQL(lcCOMANDO,'TMPEMPFORA')
		IF TYPE('TMPEMPFORA.TG_FORAUSO') = 'N'
			SELE TMPEMPFORA
			GO TOP
			SCAN WHILE NOT EOF()
				IF TMPEMPFORA.TG_FORAUSO = 0
					LOOP
				ENDIF
				lcAUX	= TMPEMPFORA.PK_ID + CHR(9)
				IF lcAUX $ lcDS_EMPDIREITO OR 'TODAS' $ lcDS_EMPDIREITO
					lcDS_EMPFORA	= lcDS_EMPFORA + lcAUX
					lcDS_EMPDIREITO	= STRTRAN(lcDS_EMPDIREITO,lcAUX,'' )
				ENDIF
				tcEMPRESA		= STRTRAN(tcEMPRESA,TMPEMPFORA.PK_ID)
			ENDSCAN
		ENDIF

		* VERIFICANDO SE NÃO ESTÁ SEM PERMISSÃO P/ ESTA EMPRESA
		IF NOT 'TODAS' $ lcDS_EMPDIREITO
			IF NOT tcEMPRESA $ lcDS_EMPDIREITO
				tcEMPRESA = ''
			ENDIF
		ENDIF

		* DEFINE A EMPRESA PADRÃO
		THIS.EMPATUAL = tcEMPRESA
		* DEFINE O LOGOTIPO DA EMPRESA PADRÃO
		THIS.LOGOTIPO = THIS.LOGOMONTAR(THIS.EMPATUAL)
		* DEFINE A STRING DE CONDIÇÃO DAS EMPRESAS
		IF 'TODAS' $ lcDS_EMPDIREITO
			* FILTRO COM EMPRESAS EM USO
			lcEMPS	= STRTRAN(lcDS_EMPFORA,CHR(9),"','" )
			lcEMPS	= "('ZZZZ','" + lcEMPS + "')"
			lcEMPS	= STRTRAN(lcEMPS,",''","")
			THIS.EMPFILTRO		= "FK_EMPRESA NOT IN "+lcEMPS
			THIS.EMPFILTROSF12	= "FK_EMPRESA NOT IN "+lcEMPS
			* FILTRO COM EMPRESAS FORA DE USO
			THIS.EMPFILTROCF12	= "FK_EMPRESA NOT IN ('ZZZZ') "
		ELSE
			* FILTRO COM EMPRESAS EM USO
			lcEMPS	= STRTRAN(lcDS_EMPDIREITO,CHR(9),"','" )
			lcEMPS	= "('" + lcEMPS + "')"
			lcEMPS	= STRTRAN(lcEMPS,",''","")
			THIS.EMPFILTRO		= "FK_EMPRESA IN "+lcEMPS
			THIS.EMPFILTROSF12	= "FK_EMPRESA IN "+lcEMPS
			* FILTRO COM EMPRESAS FORA DE USO
			lcEMPS	= STRTRAN(lcDS_EMPDIREITO+lcDS_EMPFORA,CHR(9),"','" )
			lcEMPS	= "('" + lcEMPS + "')"
			lcEMPS	= STRTRAN(lcEMPS,",''","")
			THIS.EMPFILTROCF12 = "FK_EMPRESA IN "+lcEMPS
		ENDIF
		USE IN TMPUSUEMP
		USE IN TMPEMPFORA
	ENDPROC

	PROC LOGOMONTAR
		* MONTA NOME DO LOGOTIPO DE ACORDO COM A EMPRESA
		LPARAMETERS tcEMPRESA
		LOCAL lcLOGO, lcLOGO2 AS STRING
		lcLOGO   = 'IMAGES\LOGO.BMP'
		IF NOT EMPTY(tcEMPRESA)
			lcLOGO2 = 'IMAGES\LOGO_'+tcEMPRESA+'.BMP'
			IF FILE(lcLOGO2)
				lcLOGO = lcLOGO2
			ENDIF
		ENDIF
		RETURN(lcLOGO)
	ENDPROC
	
	PROC MONTALOGOFNAME
	*******************
	LPARAMETERS tcEMP
		LOCAL lcFNAME AS STRING
		lcFNAME = FULLPATH(FORCEEXT('IMAGES\LOGO_'+tcEMP,'BMP'))
		RETURN(lcFNAME)
	ENDPROC
	
	PROC LOGOCAMINHO
	***************
	LPARAMETERS tcEMP
		IF TYPE('tcEMP')<>'C'
			tcEMP=''
		ENDIF
		IF EMPTY(tcEMP) OR THIS.LOGOMULTIEMPRESA = .F.
			RETURN(THIS.LOGOTIPO)
		ENDIF
		
		LOCAL lcIMG AS String 
		lcIMG=THIS.MONTALOGOFNAME(tcEMP)
		* NO MODO WAW, BAIXA ARQUIVO
		IF goAPLICATIVO.WAWATIVO=1
			lcIMG=WAW_COMPARAR(JUSTFNAME(lcIMG),.T.)
		ENDIF

		* ARQUIVO DE LOGO DA EMPRESA NÃO EXISTE, ASSUME DEFAULT DO SISTEMA
		IF NOT FILE(lcIMG)
			lcIMG= goAPLICATIVO.LOGOTIPO
		ENDIF
		RETURN(lcIMG)
	ENDPROC
	
	PROC SETARLOGO
	**************
	LPARAMETERS tcEMP
		IF TYPE('tcEMP')<>'C'
			tcEMP=''
		ENDIF
		IF EMPTY(tcEMP)
			RETURN
		ENDIF
		IF NOT goAPLICATIVO.LOGOMULTIEMPRESA
			RETURN
		ENDIF
		
		goAPLICATIVO.EMPLOGO = tcEMP
	ENDPROC
	
	PROC EMPFILTRO_COMEXTRA
	********************
	LPARAMETERS tcALIAS

		IF TYPE('tcALIAS') <> 'C'
			tcALIAS	= ''
		ENDIF
		IF EMPTY(tcALIAS)
			RETURN(goAPLICATIVO.EMPFILTRO)
		ENDIF 

		LOCAL lcRET AS String
		lcRET = goAPLICATIVO.EMPFILTRO + ' ' + STRTRAN(goAPLICATIVO.EMPFILTROEXTRA,'[TABELA]',ALLTRIM(tcALIAS))

		RETURN(lcRET)
		
	ENDPROC

	PROC UNLOAD

	ENDPROC

	PROC VFKEMPRESA
		LPARAMETERS tcTABELA
		* VERIFICA SE UMA TABELA DO SISTEMA TEM CAMPO PARA FILTRAR EMPRESA
		* SENDO: 0=NAO, 1=SIM (FK_EMPRESA), 2=SIM (PK_ID)
		LOCAL lnFK AS Integer
		lnFK = 0
		IF tcTABELA = 'TB_EMPRESAS'
			* TEM FILTRO MAS É PELO PK_ID
			lnFK = 2
		ELSE
			tcTABELA = '#'+tcTABELA+'#' + CHR(13)
			IF tcTABELA $ THIS.EMPFKSIM
				lnFK = 1
			ELSE
				lnFK = 0
			ENDIF
		ENDIF
		RETURN(lnFK)
	ENDPROC

	PROC KILLFORMS
		* MATAR OS FORMS ABERTOS
		LPARAMETERS tnNOKILL
		* NÃO MATAR: 0=SEM EXCEÇÃO, 1=TOOLBAR
		IF VARTYPE(tnNOKILL)<>'N'
			tnNOKILL = 0
		ENDIF
		
		LOCAL lnXI,lnQF AS Integer
		LOCAL lcFORMNAME AS String
		
		lnQF = _SCREEN.FORMCOUNT
		DIMENSION laFORMS(lnQF)
		* PASSA FORMULARIOS PARA ARRAY
		FOR lnXI = 1 TO lnQF
			laFORMS[lnXI] = _SCREEN.FORMS[lnXI]
		ENDFOR
		
		* FECHA FORMS
		FOR lnXI = 1 TO lnQF
			lcFORMNAME 	= UPPER(laFORMS[lnXI].NAME)
			IF ALLTRIM(lcFORMNAME) == 'FRMAPLICATIVO'
				LOOP
			ENDIF
			TRY
				laFORMS[lnXI].RELEASE()
			CATCH
			ENDTRY
		ENDFOR
	ENDPROC

	PROC tmrTIMER.TIMER
		* DATA/HORA DE EXECUÇÃO DO TIMER
		LOCAL ldEXECTIMER AS Datetime 
		ldEXECTIMER = DATETIME()
	
		* EXECUTANDO ALARME DO SISTEMA CASO TABELA DE ALARMES TENHA SIDO CARREGADA
		IF USED('TMPSYSALARMES')
			SELE TMPSYSALARMES
			IF goCONEXAO.FK_USUARIO > 0
				=EXECUTARALARME()
			ENDIF
		ENDIF
		
*!*			* VERIFICA TEMPO MÁXIMO DE CONEXÃO ABERTA (24HS)
*!*			LOCAL lnMINLIMITE, lnMINCONN AS Integer 
*!*			lnMINLIMITE	= 1440
*!*			lnMINCONN	= INT((DATETIME()-goCONEXAO.ULTCONECTA)/60)
*!*			
*!*			IF lnMINCONN >= lnMINLIMITE
*!*				* DEVE FECHAR CONEXÃO, A ABRIR TELA DE LOGIN NOVAMENTE
*!*			ENDIF
		
		LOCAL lcCOMANDO AS String
		LOCAL lnALCAFILE AS Integer
		
		* PARA WAW VERIFICA SE HOUVE MUDANÇA NA VERSÃO DE ARQUIVOS
		** OU SE SISTEMA ESTÁ BLOQUEADO
		IF goAPLICATIVO.WAWATIVO = 1 AND goCONEXAO.FK_USUARIO > 0 AND goCONEXAO.ALCA > 0
			lcCOMANDO = 'SELECT * FROM WAW_CONTROLE WHERE PK_ID=1'
			=PESQUISASQL(lcCOMANDO,'TMPWAWCONTROLE')
			* NECESSÁRIO PARA CORRIGIR BUG DE TMPWAWCONTROLE NÃO ENCONTRADO
			TRY
				SELE TMPWAWCONTROLE
				GO TOP
				* EXISTE ATUALIZAÇÃO ENTÃO É NECESSÁRIO CRIAR ARQUIVO TRAVADO.SIT PARA DERRUBAR SISTEMA
				IF TMPWAWCONTROLE.NR_WAWVERSION > goAPLICATIVO.WAWVERSION OR (TYPE('TMPWAWCONTROLE.TG_WAWBLOQUEADO')='N' AND TMPWAWCONTROLE.TG_WAWBLOQUEADO >= 1)
					lnALCAFILE = FCREATE(goAPLICATIVO.TRAVAARQ)
					=FPUTS(lnALCAFILE,'VOLPE (WAW)')
					=FCLOSE(lnALCAFILE)
				ENDIF
			CATCH
			ENDTRY
		ENDIF

		IF NOT EMPTY(THIS.Parent.JOB_NAME)
			* PLATAFORMA RODANDO EM MODO SLAVE
			THIS.Parent.EXECUTARSLAVE()
			* VERIFICA SE JÁ PASSOU DO TEMPO MAXIMO DE EXECUÇÃO E SE TEM QUE FECHAR NA FORÇA O VOLPE
			THIS.Parent.EXECMAXSLAVE()
		ENDIF
		
		* TRAVASIS: -1=NUNCA DERRUBAR  0=LIBERADO  1=TRAVADO
		IF THIS.PARENT.TRAVASIS<0
			RETURN
		ENDIF
		
		* REGRA PARA DERRUBAR O SISTEM EM DETERMINADO HORARIO APÓS 6 HORAS ABERTO
		IF NOT GOAPLICATIVO.TESTE AND  NOT EMPTY(THIS.PARENT.AUTOCLOSE) AND ldEXECTIMER - THIS.PARENT.DH_ABERTURA > (60 * 60 * 6) && 6 HORAS EXPRESSAS EM SEGUNDOS
			lcDH_ATUAL = PADL(ALLTRIM(SUBSTR(TTOC(ldEXECTIMER),12,5)),5,'0')
			
			* CALCULA TOLERANCIA DE 5 MINUTOS PARA POSSÍVEIS ATRASOS NO TIMER
			lnHORAS		= INT(VAL(LEFT(THIS.PARENT.AUTOCLOSE,2)))
			lnMINUTOS 	= INT(VAL(RIGHT(THIS.PARENT.AUTOCLOSE,2)))
					
			IF lnMINUTOS + 5 >= 60
				lnHORAS = lnHORAS + 1
				IF lnHORAS >= 24
					lnHORAS 	= 23
					lnMINUTOS	= 59
				ELSE
					lnMINUTOS = (lnMINUTOS-60) + 5 
				ENDIF			
			ELSE
				lnMINUTOS = lnMINUTOS + 5 
			ENDIF
			
			lcAUTOCLOSEMAX = STRZERO(lnHORAS,2) + ':' + STRZERO(lnMINUTOS,2)
			
			IF lcDH_ATUAL >= THIS.PARENT.AUTOCLOSE AND lcDH_ATUAL <= lcAUTOCLOSEMAX
				DO ESPERANDO WITH 'Este programa está se autoencerrando para manutenção...'
				THIS.ENABLED = .F.
				DO ENCERRAR
			ENDIF
		ENDIF
		
		IF NOT FILE(THIS.PARENT.TRAVAARQ)
			THIS.PARENT.TRAVASIS = 0
		ELSE
			IF THIS.PARENT.TRAVASIS=0
				THIS.PARENT.TRAVASIS = 1
				LOCAL lcAVISAFIM AS String
				
				* MENSAGEM DE SISTEMA TRAVADO DIFERENTE PARA VOLPE NORMAL E VOLPE WAW
				IF goAPLICATIVO.WAWATIVO = 0
					lcAVISAFIM = 'Este programa será finalizado!'+CHR(13)+CHR(13)+;
						'Voce tem 60 segundos para finalizá-lo ou ele será encerrado '+;
						'automaticamente para manutenção. Finalize seu trabalho com '+;
						'urgência. Encerramento automatico previsto para '+;
						TTOC(DATETIME()+60)+'.'
				ELSE
					lcAVISAFIM = 'Este programa será finalizado!'+CHR(13)+CHR(13)+;
						'Voce tem 60 segundos para finalizá-lo ou ele será encerrado '+;
						'automaticamente para atualização. Finalize seu trabalho com '+;
						'urgência. Após o encerramento do sistema reinicie o aplicativo logo em seguida '+;
						'para que as novas alterações entrem em vigor.'+;
						'Encerramento automatico previsto para '+TTOC(DATETIME()+60)+'.'
				ENDIF
				
				=MESSAGEBOX(lcAVISAFIM,'Aviso de autoencerramento',48,55000)
			ELSE
				DO ESPERANDO WITH 'Este programa está se autoencerrando para manutenção...'
				THIS.ENABLED = .F.
				DO ENCERRAR
			ENDIF
		ENDIF

	ENDPROC

	PROC EXECUTARSLAVE
	******************

		* MODO SLAVE
		IF THIS.JOB_STILLRUN
			* PROCESSO AINDA ESTA EM EXECUÇÃO
			RETURN
		ENDIF
		THIS.JOB_STILLRUN	= .T.

		LOCAL lhATUAL, lhFINAL AS Datetime
		LOCAL lcAUX_DATA, lcAUX_HORA, lcCOMANDO, lcROTINA AS String
		LOCAL lnXI AS Integer

		* HORARIO ATUAL SEM SEGUNDOS
		lhATUAL		= DATASERVER()
		lcAUX_DATA	= TRANSFORM( DTOS( TTOD(lhATUAL) ),'@R 9999-99-99' )
		lcAUX_HORA	= 'T' + STRZERO(HOUR(lhATUAL),2)+':'+STRZERO(MINUTE(lhATUAL),2)+':00'
		lhATUAL		= CTOT( lcAUX_DATA+lcAUX_HORA )
		
		* CASO SEJA A PRIMEIRA EXECUÇÃO, GRAVA A HORA
		IF EMPTY(THIS.JOB_PRIEXEC)
			THIS.JOB_PRIEXEC	= lhATUAL
		ENDIF

		* REGISTRO COM O SERVIÇO
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT
				*
			FROM
				TS_JOBS
			WHERE
				DS_SERVICO=<<JOB>>
		ENDTEXT
		lcCOMANDO = STRTRAN(lcCOMANDO,'<<JOB>>',XX(THIS.JOB_NAME))
		=PESQUISASQL(lcCOMANDO,'TMPJOB')
		IF RECCOUNT('TMPJOB') <= 0
			DO ENCERRAR
		ENDIF
		
		* CASO NÃO TENHA COLUNA DE DURAÇÃO MAXIMA, MANTEM O TEMPO DEFAULT DE 24HS
		IF TYPE('TMPJOB.NR_DURACAOMAX') <> 'U'
			THIS.JOB_DURAMAX = TMPJOB.NR_DURACAOMAX
		ENDIF
	
		lcAUX_DATA	= TRANSFORM( DTOS( TTOD(lhATUAL) ),'@R 9999-99-99' )
		lcAUX_HORA	= 'T' + STRZERO(HOUR(TMPJOB.DH_FIM),2)+':'+STRZERO(MINUTE(TMPJOB.DH_FIM),2)+':00'
		lhFINAL		= CTOT(lcAUX_DATA + lcAUX_HORA)

		* PRAZO DE VALIDADE DO SERVIÇO EXPIROU
		IF lhATUAL > lhFINAL
			DO ENCERRAR
		ENDIF

		* A EXECUÇÃO DO JOB ESTA NO INTERVALO SELECIONADO
		IF lhATUAL >= THIS.JOB_PROEXEC
			* VOLPE MODO NORMAL
			IF goAPLICATIVO.WAWATIVO = 0
				lcROTINA = FULLPATH('')+ALLTRIM(UPPER(TMPJOB.DS_ROTINA))
				IF NOT EMPTY(lcROTINA)
					IF FILE(lcROTINA+'.SCX') AND FILE(lcROTINA+'.SCT')
						TRY 
							=GRAVALOGJOB(ALLTRIM(UPPER(TMPJOB.DS_ROTINA)))
							=CHAMAFORM(lcROTINA,'')
						CATCH
						ENDTRY
					ENDIF
					IF TMPJOB.TG_FECHARFIM = 1
						DO ENCERRAR
					ENDIF
					THIS.JOB_PROEXEC	= THIS.JOB_PROEXEC + ( TMPJOB.NR_INTERVALO * 60 )
				ENDIF
			ELSE
				* VOLPE MODO WAW
				lcROTINA = ALLTRIM(UPPER(TMPJOB.DS_ROTINA))
				IF NOT EMPTY(lcROTINA)
					TRY 
						=GRAVALOGJOB(ALLTRIM(UPPER(TMPJOB.DS_ROTINA)))
						=CHAMAFORM(lcROTINA,'')
					CATCH
					ENDTRY
					IF TMPJOB.TG_FECHARFIM = 1
						DO ENCERRAR
					ENDIF
					THIS.JOB_PROEXEC	= THIS.JOB_PROEXEC + ( TMPJOB.NR_INTERVALO * 60 )
				ENDIF
			ENDIF
		ENDIF

		THIS.JOB_STILLRUN	= .F.
		IF THIS.JOB_FECHARFIM = 1
			DO ENCERRAR
		ENDIF

	ENDPROC
	
	PROC EXECMAXSLAVE
		LOCAL ldFIM AS Datetime 
		
		ldFIM = THIS.JOB_PRIEXEC + (THIS.JOB_DURAMAX * 60)
		
		IF DATETIME() >= ldFIM
			DO ENCERRAR
		ENDIF
	ENDPROC

	PROC OPRN
	* IMPRIMIR EM MODO TEXTO: OPEN PRINTER
	LPARAMETERS tnCOMPRESSAO
		* tnCOMPRESSAO	= se usa caracter de compressao (1) ou nao (0)
		IF TYPE('tnCOMPRESSAO') <> 'N'
			tnCOMPRESSAO = 0
		ENDIF
		LOCAL llAUX AS Logical
		LOCAL lcCHR1, lcCHR0 AS String
		IF tnCOMPRESSAO = 1
			THIS.CHRCOMPRIMIR1	= CHR(15)
			THIS.CHRCOMPRIMIR0	= CHR(18)
			llAUX	= RETORNASET('PRN.COMPRIME=ESPECIAL','L',1)
			IF llAUX
				lcCHR1	= RETORNASET('ZWPRNCOMP1','C',1)
				IF TYPE(lcCHR1)='C'
					THIS.CHRCOMPRIMIR1 = &lcCHR1
				ENDIF
				lcCHR0 = RETORNASET('ZWPRNCOMP0','C',1)
				IF TYPE(lcCHR0)='C'
					THIS.CHRCOMPRIMIR0 = &lcCHR0
				ENDIF
			ENDIF
		ELSE
			STORE '' TO THIS.CHRCOMPRIMIR1, THIS.CHRCOMPRIMIR0
		ENDIF
		THIS.ARQIMPRESSAO = TEMPFILE()
		THIS.ALCAIMPRESSAO	= FCREATE( THIS.ARQIMPRESSAO , 0 )
		IF THIS.ALCAIMPRESSAO < 0
			DO MENS WITH 'Não foi possivel criar o arquivo de impressão no momento: '+THIS.ARQIMPRESSAO
			RETURN(.F.)
		ENDIF
		IF tnCOMPRESSAO = 1
			IF NOT EMPTY(THIS.CHRCOMPRIMIR1)
				=FWRITE( THIS.ALCAIMPRESSAO, THIS.CHRCOMPRIMIR1 )
			ENDIF
		ENDIF
	ENDPROC

	PROC WPRN
		* IMPRIMIR EM MODO TEXTO: WRITE PRINTER
		LPARAMETERS tnLINHAS AS Integer, tnCOMACENTO AS Integer 
			IF TYPE( 'tnLINHAS' ) <> 'N'
				tnLINHAS = 1
			ENDIF
			IF TYPE('tnCOMACENTO') <> 'N'
				tnCOMACENTO = 0
			ENDIF
			IF ISNULL(THIS.LINHA)
				THIS.LINHA = ''
			ENDIF
			
			IF tnCOMACENTO <> 1
				THIS.LINHA	= SEMACENTO(THIS.LINHA)
			ENDIF
			
			IF tnLINHAS > 0
				THIS.LINHA = THIS.LINHA + THIS.PRNLF	&& Coloca LineFeed
			ELSE
				THIS.LINHA = THIS.LINHA + THIS.PRNCR	&& Coloca carriage return
			ENDIF
			LOCAL lnAUXLINHAS, lnXI AS Integer
			=FWRITE( THIS.ALCAIMPRESSAO, THIS.LINHA )
			FOR lnXI = 2 TO tnLINHAS
				=FWRITE( THIS.ALCAIMPRESSAO, THIS.PRNLF )  &&MPRNLF
			ENDFOR
	ENDPROC

	PROC CPRN
		* IMPRIMIR EM MODO TEXTO: CLOSE PRINTER
		LPARAMETERS tnEJETASN AS Integer, tnEXIBEFORM AS INTEGER, tcPRINTER AS String

		IF TYPE('tcPRINTER') <> 'C'
			tcPRINTER = ''
		ENDIF
		
		IF VARTYPE(tnEXIBEFORM) <> 'N'
			tnEXIBEFORM = 1
		ENDIF

		DECLARE INTEGER CopyFile IN kernel32;
		    STRING  lpExistingFileName,;
		    STRING  lpNewFileName,;
		    INTEGER bFailIfExists

			IF TYPE('tnEJETASN') <> 'N'
				tnEJETASN = 1
			ENDIF
			IF NOT EMPTY(THIS.CHRCOMPRIMIR0)
				THIS.LINHA	= THIS.CHRCOMPRIMIR0
				=THIS.WPRN( 0 )
			ENDIF
			IF tnEJETASN = 1
				THIS.LINHA	= THIS.PRNFF
				=THIS.WPRN( 0 )
			ENDIF
			=FCLOSE( THIS.ALCAIMPRESSAO )
			
			* VERIFICA SE DEVE EXIBIR FORMULARIO PARA IMPRESSAO OU ENVIAR DIRETO PARA IMPRESSORA
			LOCAL lcPRINTER AS STRING
			IF tnEXIBEFORM = 1
				
				* CASO TENHA PASSADO COMO PARAMETRO A IMPRESSORA QUE SERÁ UTILIZADA, ACRESCENTA UM PARAMETRO PARA A TELA DE IMPRESSÃO ENTENDER QUAL IMPRESSORA UTILIZAR
				IF NOT EMPTY( tcPRINTER ) AND LEFT( tcPRINTER, 12 ) <> 'PRINTERNAME='
					tcPRINTER = 'PRINTERNAME=' + ALLTRIM( tcPRINTER ) 
				ENDIF
				
				DO FORM SYSTEM_IMPRIMIRTXT WITH THIS.ARQIMPRESSAO, tcPRINTER
			ELSE
				lcPRINTER = RETORNASET('PRN.MODO','C',1)
				DO CASE 
					CASE NOT EMPTY(tcPRINTER) && IMPRESSORA RECEBIDA POR PARAMETRO
						=COPYFILE(THIS.ARQIMPRESSAO, tcPRINTER,1)
					CASE lcPRINTER = 'TYPE'
						lcCOMANDO = '/N2 CMD /C TYPE ' + lcARQUIVO + ' >PRN'
						RUN &lcCOMANDO
					CASE lcPRINTER = 'GETPRINTER'
						lcPRINTER = GETPRINTER()
						IF NOT EMPTY(lcPRINTER)
							=COPYFILE(THIS.ARQIMPRESSAO, lcPRINTER,1)
						ENDIF
					CASE lcPRINTER = 'PRINTERNAME='
						lcPRINTER = STREXTRACT(lcPRINTER,'PRINTERNAME=','')
						IF NOT EMPTY(lcPRINTER)
							=COPYFILE(THIS.ARQIMPRESSAO, lcPRINTER,1)
						ENDIF
					OTHERWISE
						=COPYFILE(THIS.ARQIMPRESSAO, "LPT1",1)
				ENDCASE
			ENDIF

			IF FILE(THIS.ARQIMPRESSAO)
				DELETE FILE &lcFILE
			ENDIF

	ENDPROC
	
	PROC STATUSBAR_DblClick
		* EVENTO "BINDADO" PARA PROGRAMAR DBCLICK DA STATUSBAR
		IF TYPE('_SCREEN.oSTATUSBAR')<>'O'
			RETURN
		ENDIF
		DO CASE 
			CASE _SCREEN.oSTATUSBAR.nPanel=1 && Informações da conexão
				DO FORM SYSTEM_BANCOMOSTRAR

			CASE _SCREEN.oSTATUSBAR.nPanel=2 && Informações do usuário
				DO FORM SYSTEM_USUARIOMOSTRAR

			CASE _SCREEN.oSTATUSBAR.nPanel=3 && Configuração de filtro de empresa
				DO FORM SYSTEM_FILTRAREMPRESAS

			CASE _SCREEN.oSTATUSBAR.nPanel=4 && Informações do alarme do sistema
				DO FORM SYSTEM_ALARMESHISTORICOS
				
			OTHERWISE
				RETURN
		ENDCASE
	ENDPROC

	PROC CRIARMYZIPCLASS
	********************
		THIS.NewObject( 'myZIP', 'ZIPCLASS', 'ZIPCLASS.VCX' )
	ENDPROC

	PROC CARGAMODULOS
	*******************
		LOCAL lcCOMANDO AS String
		
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT
				*
			FROM
				TB_FECHAMENTOS
			ORDER BY
				PK_ID
		ENDTEXT
		=PESQUISASQL(lcCOMANDO,'TMPSYSFECH')

		* VERIFICA EXISTÊNCIA DO CAMPO TG_MODULOSISTEMA		
		IF TYPE('TMPSYSFECH.TG_MODULOSISTEMA') = 'N'
			goAPLICATIVO.MODULOSATIVOS = '#'
			SELE TMPSYSFECH
			GO TOP
			SCAN FOR TG_MODULOSISTEMA = 1
				goAPLICATIVO.MODULOSATIVOS = goAPLICATIVO.MODULOSATIVOS + ALLTRIM(TMPSYSFECH.PK_ID) + '#'
			ENDSCAN
		ELSE
			goAPLICATIVO.MODULOSATIVOS = ''
		ENDIF

		USE IN TMPSYSFECH
	ENDPROC
	
	PROC CARREGARALARME
	*******************
	* VERIRICA A EXISTÊNCIA DA TABELA DE ALARMES		
		DO LERTABLES WITH 'TS_ALARMES'

		SELE TMPTABLES
		IF RECCOUNT() = 1
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					ALR.*
				FROM
					TS_ALARMES ALR
				WHERE
					ALR.TG_INATIVO = 0
			ENDTEXT
			=PESQUISASQL(lcCOMANDO,'TMPSYSALARMES')

			* CRIANDO CAMPO DATETIME NA TEMPORÁRIA
			SELECT *,;
				CAST(DATETIME()-60 AS DATETIME) AS DH_EXECUTADO,;
				CAST(0 AS INT) AS TG_NAOEXECUTAR;
			FROM;
				TMPSYSALARMES;
			INTO CURSOR TMPSYSALARMES READWRITE
			
			* CRIANDO TEMPORÁRIA DE HISTÓRICOS
			CREATE CURSOR TMPSYSALAHIST (DH_EXECUCAO DATETIME, DS_ALARME CHAR(100), DS_MENSAGEM CHAR(200))

			* VERIFICANDO ALARMES PARA O USUÁRIO
			SELE TMPSYSALARMES
			GO TOP
			SCAN WHILE NOT EOF()
				STORE .F. TO llCONTIDO
				* VERIFICA GRUPOS QUE É PARA APARECER ALARME (-1 INDICA QUE NÃO É PARA "LIBERAR" CASO SEJA SUPERVISOR)
				llCONTIDO = VERIFGRUPOS(goCONEXAO.GRUPO,DS_FKGRUPOS,-1)
				
				IF VIRGULAR(ALLTRIM(STR(goCONEXAO.FK_USUARIO))) $ VIRGULAR(ALLTRIM(DS_FKUSUARIOS))
					llCONTIDO = .T.
				ENDIF
				
				IF NOT llCONTIDO
					* DE ACORDO COM O TAMANHO DO CAMPO DE GRUPOS A SIGLA DO SUPERVISOR MUDA
					lcSUPERVISOR = IIF(goCONEXAO.TAMANHOGRUPO = 1,'S','SSS')
					IF lcSUPERVISOR $ goCONEXAO.GRUPO
						* CASO SEJA SUPERVISOR E NÃO TENHA QUE RECEBER O ALARME, O ALARME VAI APARECER PORÉM DESATIVADO
						REPLACE TG_NAOEXECUTAR WITH 1
					ELSE
						* CASO NÃO SEJA SUPERVISOR E NÃO TENHA QUE RECEBER O ALARME, O ALARME NEM APARECE
						REPLACE TG_INATIVO WITH 1
					ENDIF
				ENDIF
			ENDSCAN
		ENDIF
		USE IN TMPTABLES
	RETURN

	PROC EXECUTARALARME
	*******************
		LOCAL 		lcCOMANDO, lcRETORNO, lcMACRO, lcEXTR, lcOPCOES, lcALIAS AS String
		STORE '' TO lcCOMANDO, lcRETORNO, lcMACRO, lcEXTR, lcOPCOES, lcALIAS
		
		LOCAL lnXI AS Integer
		STORE 0 TO lnXI
		
		lcALIAS = ALIAS()
		
		IF NOT USED('TMPSYSALARMES')
			RETURN(.F.)
		ENDIF
		
		* JÁ EXISTE UM ALARME SENDO EXIBIDO NÃO É NECESSÁRIO EXIBIR OUTRO
		IF goAPLICATIVO.QTDMENSALARMES > 0
			RETURN(.F.)
		ENDIF
		
		* VERIFICA SE ALCA DE CONEXÃO É VALIDA
		IF goCONEXAO.ALCA < 0
			RETURN(.F.)
		ENDIF
		
		SELE TMPSYSALARMES
		GO TOP
		
		SCAN WHILE NOT EOF()
			* NÃO EXECUTA ALARMES INATIVOS E SETADOS PARA NÃO EXECUTAR
			IF TMPSYSALARMES.TG_NAOEXECUTAR = 1 OR TMPSYSALARMES.TG_INATIVO = 1
				LOOP
			ENDIF

			* SE ESTÁ DENTRO DO INTERVALO DE TEMPO, EXECUTA ALARME CADASTRADO
			IF DATETIME() >= (TMPSYSALARMES.DH_EXECUTADO + TMPSYSALARMES.NR_TEMPO)
				* GRAVANDO NOVA HORA DE EXECUÇÃO
				REPLACE DH_EXECUTADO WITH DATETIME()
				
				lcCOMANDO = DS_COMANDOSQL
		
				* REMOVENDO LIXO DA QUERY
				lcCOMANDO = STRTRAN(lcCOMANDO, CHR(9),'')
				lcCOMANDO = STRTRAN(lcCOMANDO, CHR(10),' ')
				lcCOMANDO = STRTRAN(lcCOMANDO, CHR(13),' ')

				* TROCANDO PALAVRAS CHAVE
				lcCOMANDO = STRTRAN(lcCOMANDO, '[USUARIO.CODIGO]',XX(goCONEXAO.FK_USUARIO))
				lcCOMANDO = STRTRAN(lcCOMANDO, '[USUARIO.LOGIN]',XX(goCONEXAO.USERNAME))
				lcCOMANDO = STRTRAN(lcCOMANDO, '[USUARIO.GRUPO]',XX(goCONEXAO.GRUPO))
				lcCOMANDO = STRTRAN(lcCOMANDO, '[DATAHORA]',XX(DATETIME()))
				lcCOMANDO = STRTRAN(lcCOMANDO, '[ASPAS]',"'")
				
				* TROCANDO COMANDOS FIXOS
				FOR lnXI = 1 TO OCCURS('[',lcCOMANDO)
					lcEXTR = STREXTRACT(lcCOMANDO,'[',']',lnXI)
					IF EMPTY(lcEXTR)
						LOOP
					ENDIF
					lcMACRO = EVALUATE(lcEXTR)
					lcCOMANDO = STRTRAN(lcCOMANDO,'['+lcEXTR+']', XX(lcMACRO))
				ENDFOR
			
				=PESQUISASQL(lcCOMANDO,'TMPSYSALACOMANDO')
				SELE TMPSYSALACOMANDO
				GO TOP

				* VERIFICA SE CAMPO NR_OCORRENCIA EXISTE
				IF TYPE('TMPSYSALACOMANDO.NR_IRREGULAR') = 'N'
					* VERIFICA SE ALGUMA OCORRENCIA FOI ENCONTRADA
					SELE TMPSYSALACOMANDO
					IF TMPSYSALACOMANDO.NR_IRREGULAR > 0
						* SE EXISTE OCORRÊCIA ENTÃO A TELA DE ALARME DO SISTEMA DEVE SER CHAMADA
					
						* INCLUINDO HISTÓRICO DO ALARME
						IF USED('TMPSYSALAHIST')
							SELE TMPSYSALAHIST
							APPEND BLANK
							REPLACE DH_EXECUCAO WITH DATETIME(),;
									DS_ALARME	WITH TMPSYSALARMES.DS_ALARME,;
									DS_MENSAGEM	WITH TMPSYSALARMES.DS_MENSAGEM
						ENDIF

						SELE TMPSYSALARMES
						* SE VOLPE ESTA NA SYSTRAY TROCA ICONE E EXIBE BALOONTOOTIP
						IF goAPLICATIVO.MINSYSTRAY
							goAPLICATIVO.mySYSTRAY.ShowBalloontip(ALLTRIM(TMPSYSALARMES.DS_MENSAGEM),'Volpe',4)
						ELSE
							* SE VOLPE ESTA MINIMIZADO FAZ TASKBAR PISCAR
							=ALERTARTASKBAR()
						ENDIF
						
						* INCREMENTA NÚMERO DE ALARMES EXIBIDOS PARA TER CONTROLE DA EXIBIÇÃO
						goAPLICATIVO.QTDMENSALARMES = goAPLICATIVO.QTDMENSALARMES + 1
					
						* VERIFICA SE CHKBOX "NÃO EXIBIR..." DEVE SER EXIBIDO
						IF TYPE('TMPSYSALARMES.TG_NAOEXIBIRCHK') = 'N' AND TMPSYSALARMES.TG_NAOEXIBIRCHK = 1
							lcOPCOES = '<TGNAOEXIBIRCHK>'
						ELSE
							lcOPCOES = ''
						ENDIF
		
						* MOSTRANDO TELA DE AVISOS DO SISTEMA
						SELE TMPSYSALARMES
						DO FORM SYSTEM_MENSALARME WITH TMPSYSALARMES.DS_MENSAGEM, DS_ABRIRFORM, lcOPCOES, TMPSYSALARMES.DS_ALARME TO lcRETORNO

						* NÃO EXIBIR MAIS ESSE ALERTA
						IF '<NAOEXIBIRNOVAMENTE>' $ lcRETORNO
							* TRATAMENTO DE ERRO QUANDO VOLPE ESTÁ SENDO FECHADO
							IF USED('TMPSYSALARMES')
								SELE TMPSYSALARMES
								REPLACE TG_NAOEXECUTAR WITH 1
							ENDIF
						ENDIF
						
						* NECESSÁRIO ABRIR FORM OPÇÃO "CLIQUE AQUI PARA SABER MAIS" FOI ACIONADA
						SELE TMPSYSALARMES
						IF '<CLIQUESABERMAIS>' $ lcRETORNO
							IF NOT EMPTY(TMPSYSALARMES.PR_PARAMETRO1)
								=CHAMAFORM(DS_ABRIRFORM, '', PR_PARAMETRO1)
							ELSE
								=CHAMAFORM(DS_ABRIRFORM, '')
							ENDIF
						ENDIF
					ENDIF
				ENDIF
			ENDIF
		ENDSCAN
		
		IF USED(lcALIAS)
			SELE (lcALIAS)
		ENDIF
	RETURN
ENDDEFINE

DEFINE CLASS MEUREPORT AS "FXLISTENER" OF "_REPORTLISTENER.VCX"

	Procedure LoadReport
		DoDefault()
		With This
			If .ListenerType==1 And Not Vartype(.PreviewContainer)=="O"
				.ExtendPreviewContainer()
			Endif
		Endwith
	Endproc

	PROCEDURE Init
		DoDefault()
		THIS.AddProperty('CAPTION','')
		THIS.QuietMode	= .T.
	ENDPROC

	PROCEDURE BeforeReport
		DoDefault()
		IF THIS.ListenerType = 1
			THIS.PreviewContainer.AllowPrintFromPreview	= .F.
			THIS.PreviewContainer.CAPTION				= THIS.CAPTION
		ENDIF
	ENDPROC

	FUNCTION ExtendPreviewContainer
		DoDefault()
		LOCAL loPREVIEWCONTAINER
		loPREVIEWCONTAINER	= Null
		Do (_ReportPreview) With loPREVIEWCONTAINER
		loPREVIEWCONTAINER.SetExtensionHandler(Newobject("MyExtensionHandler"))
		This.PreviewContainer = loPreviewContainer
	ENDFUNC

ENDDEFINE

DEFINE CLASS myEXTENSIONHANDLER AS CUSTOM
	*
	PROCEDURE Show(iStyle)
		WITH This.PreviewForm
			With .Toolbar
				.Dock(0)
				.cboZoom.ToolTipText = "Zoom"
				.cmdClose.ToolTipText = "Fechar a visualização"
				.cmdGoToPage.ToolTipText = "Ir para a página"
				.cmdPrint.ToolTipText = "Imprimir"
				With .cntNext
					.cmdBottom.ToolTipText = "Última página"
					.cmdForward.ToolTipText = "Próxima página"
				Endwith
				With .cntPrev
					.cmdBack.ToolTipText = "Página anterior"
					.cmdTop.ToolTipText = "Primeira página"
				Endwith
				With .opgPageCount
					.opt1.ToolTipText = "Uma página"
					.opt2.ToolTipText = "Duas páginas"
					.opt3.ToolTipText = "Quatro páginas"
				Endwith
				*
			Endwith
			.WindowState = 2 && Maximize report preview
		Endwith
		DoDefault(iStyle)
	Endproc
	*
Enddefine

DEFINE CLASS FORMEMPFU AS FORM
*!*		#DEFINE LWA_COLORKEY 1 
*!*		#DEFINE LWA_ALPHA 2 
*!*		#DEFINE GWL_EXSTYLE -20 
*!*		#DEFINE WS_EX_LAYERED 0x80000 
	Caption			= "INFORMAÇÕES"
	ShowWindow		= 2
	AlwaysOnTop		= .T.
	WindowType		= 0		&& MODLESS
	Width			= 300
	Height			= 0
	Left			= MAX( _SCREEN.Width - THIS.Width-100,0 )
	Top				= 0
	ShowInTaskBar	= .F.

	PROCEDURE Init
*!*			DECLARE INTEGER GetWindowLong IN user32;
*!*				INTEGER hWnd, INTEGER nIndex

*!*			DECLARE INTEGER SetWindowLong IN user32;
*!*				INTEGER hWnd, INTEGER nIndex, INTEGER dwNewLong

*!*			DECLARE INTEGER SetLayeredWindowAttributes IN user32;
*!*				INTEGER hwnd, INTEGER crKey,;
*!*				SHORT bAlpha, INTEGER dwFlags

*!*			LOCAL nExStyle
*!*			nExStyle = GetWindowLong(THIS.HWnd, GWL_EXSTYLE)
*!*			nExStyle = BITOR(nExStyle, WS_EX_LAYERED)
*!*			= SetWindowLong(THIS.HWnd, GWL_EXSTYLE, nExStyle)
*!*			= SetLayeredWindowAttributes(THIS.HWnd, 0,;
*!*				170, LWA_ALPHA)

	ENDPROC

	PROC UNLOAD
		* VOLTANDO O FILTRO PARA FICAR SEM EMPRESAS FORA DE USO
		goAPLICATIVO.EMPFILTRO	= goAPLICATIVO.EMPFILTROSF12
	ENDPROC

ENDDEFINE 

* NOVA CLASSE DE ENVIO DE SMS VIA COMPONETE DA DARUMA
DEFINE CLASS MYSENDSMS AS Custom
*********************************

	myTG_EXIBIRMENSAGEM	= 1
	myULTERRO			= ''
	myFK_ORIGEM			= ''
	myTG_ORIGEM			= ''
	myRETURNGRAVARLOG	= 0
	myPORTAABERTA		= .F.
	
	PROC INIT
	*********
		IF THIS.hmyDECLARAFUNCOES() <> 1
			RETURN(0)
		ENDIF
		
		RETURN(1)
	ENDPROC
	
	FUNC hmyDECLARAFUNCOES
	**********************		
		IF NOT FILE('DARUMAFRAMEWORK.DLL')
			THIS.myULTERRO = 'Arquivo "DARUMAFRAMEWORK.DLL" não localizado.'
			IF THIS.myTG_EXIBIRMENSAGEM = 1
				DO MENS WITH THIS.myULTERRO
			ENDIF
			RETURN(0)
		ENDIF
		
		DECLARE INTEGER eBuscarPortaVelocidade_MODEM_DarumaFramework IN DarumaFrameWork.dll
		DECLARE INTEGER tEnviarSms_MODEM_DarumaFramework IN DarumaFrameWork.dll String cTELEFONE,String cMSG
		DECLARE INTEGER eInicializar_MODEM_DarumaFramework IN DarumaFrameWork.dll 
		
		RETURN(1)
	ENDFUNC
	
	FUNC hmyABRIRPORTA
	******************
		LOCAL lnRETORNO AS Integer 
		LOCAL lcMSGERRO AS String 
		
		STORE 0 TO lnRETORNO
		STORE '' TO lcMSGERRO
		
		lnRETORNO = eInicializar_MODEM_DarumaFramework()
		
		* SE OCORREU ALGUM ERRO AO TENTAR INICIALIZAR O MODEM, TENTA DETECTAR
		* NOVAMENTE A PORTA QUE FOI CONFIGURADA 
		IF lnRETORNO <> 1
			= eBuscarPortaVelocidade_MODEM_DarumaFramework()
			lnRETORNO = eInicializar_MODEM_DarumaFramework()
		ENDIF
		
		IF lnRETORNO <> 1
			TEXT TO lcMSGERRO NOSHOW PRETEXT 7
				Não foi possível abrir a comunicação com o modem. Verifique:
				- Se o modem está ligado.
				- Se o modem está corretamente conectado ao computador.
				- Se o chip já está sincronizado com o modem (A luz de status 
				deverá estar piscando uma vez a cada 3 segundos)
				
				Detalhes do erro:
				Retorno: [NR_RETORNO]
			ENDTEXT
			lcMSGERRO 		= STRTRAN(lcMSGERRO,'[NR_RETORNO]',XX(lnRETORNO))
			THIS.myULTERRO	= lcMSGERRO
		ENDIF
		
		IF THIS.myTG_EXIBIRMENSAGEM = 1 AND lnRETORNO <> 1
			DO MENS WITH THIS.myULTERRO 
		ENDIF
		
		THIS.myPORTAABERTA = lnRETORNO = 1
		
		RETURN(lnRETORNO)
	ENDFUNC

	FUNC hmyENVIARSMS
	*****************
		LPARAMETERS tcDS_TELEFONE,tcDS_MENSAGEM
		LOCAL lnRETORNO AS Integer 
		LOCAL lcMSGERRO,lcAUX AS String 
		
		STORE 0 TO lnRETORNO
		STORE '' TO lcMSGERRO,lcAUX
				
		IF TYPE("tcDS_TELEFONE") <> 'C'
			tcDS_TELEFONE = ''
		ENDIF
		
		IF TYPE("tcDS_MENSAGEM") <> 'C'
			tcDS_MENSAGEM = ''
		ENDIF
		
		tcDS_TELEFONE = ALLTRIM(tcDS_TELEFONE)
		tcDS_MENSAGEM = ALLTRIM(tcDS_MENSAGEM)
		
		IF EMPTY(tcDS_TELEFONE)
			THIS.myULTERRO = 'Indique o telefone para enviar o sms.'
			
			IF THIS.myTG_EXIBIRMENSAGEM = 1
				DO MENS WITH THIS.myULTERRO
			ENDIF
			RETURN(0)
		ENDIF
		
		IF EMPTY(tcDS_MENSAGEM)
			THIS.myULTERRO = 'Indique a mensagem para enviar o sms.'
		
			IF THIS.myTG_EXIBIRMENSAGEM = 1
				DO MENS WITH THIS.myULTERRO
			ENDIF
			RETURN(0)
		ENDIF
		
		IF LEN(tcDS_MENSAGEM) > 140
			THIS.myULTERRO = 'Mensagem não pode ter mais que 140 caracteres.'
		
			IF THIS.myTG_EXIBIRMENSAGEM = 1
				DO MENS WITH THIS.myULTERRO 
			ENDIF
			RETURN(0)
		ENDIF
		
		lnRETORNO = tEnviarSms_MODEM_DarumaFramework(tcDS_TELEFONE,tcDS_MENSAGEM)
		
		IF lnRETORNO = 1
			THIS.hmyGRAVARLOG(tcDS_MENSAGEM, tcDS_TELEFONE)
		ELSE
			TEXT TO lcMSGERRO NOSHOW PRETEXT 7
				Não foi possível enviar a mensagem. Verifique:
				- Se o modem está ligado.
				- Se o chip já está sincronizado com o modem (A luz de status 
				deverá estar piscando uma vez a cada 3 segundos)
				- Se o número digitado é valido.
				
				Detalhes do erro:
				Retorno: [NR_RETORNO]
				Mensagem: [DS_MENSAGEM]
			ENDTEXT
			
			* DEFININDO MENSAGEM DE ERRO
			DO CASE
				CASE lnRETORNO = 0
					lcAUX = 'Erro de comunicação'
				
				CASE lnRETORNO = -1
					lcAUX = 'Erro na comunicação da serial/USB'

				CASE lnRETORNO = -2
					lcAUX = 'Modem retornou erro.'
					
				CASE lnRETORNO = -3
					lcAUX = 'Caracteres inválidos foram utilizados na mensagem.'						
			
			OTHERWISE
				lcAUX = ''
			ENDCASE
			
			lcMSGERRO 		= STRTRAN(lcMSGERRO,'[NR_RETORNO]',XX(lnRETORNO))
			lcMSGERRO 		= STRTRAN(lcMSGERRO,'[DS_MENSAGEM]',lcAUX)
			THIS.myULTERRO 	= lcMSGERRO
			
			IF THIS.myTG_EXIBIRMENSAGEM = 1
				DO MENS WITH lcMSGERRO
			ENDIF
		ENDIF
		
		RETURN(lnRETORNO)
	ENDFUNC
	
	FUNC hmyGRAVARLOG
	**************
	LPARAMETERS tcMSG, tcTELEFONE
	
		IF TYPE("tcMSG") <> 'C'
			tcMSG = ''
		ENDIF
		
		IF EMPTY(tcMSG)
			RETURN(0)
		ENDIF
		
		IF TYPE("tcTELEFONE") <> 'C'
			tcTELEFONE= ''
		ENDIF
		
		IF EMPTY(tcTELEFONE)
			RETURN(0)
		ENDIF
		
		LOCAL lnRETORNO AS Integer 
		LOCAL lcCOMANDO AS String 
		
		STORE 0 TO lnRETORNO
		STORE '' TO lcCOMANDO
		
		* Verificando se as propriedades para gravar o log da mensagem foram configuradas corretamente
		IF TYPE("THIS.myFK_ORIGEM") <> 'C'
			THIS.myFK_ORIGEM = ''
		ENDIF
		
		IF TYPE("THIS.myTG_ORIGEM") <> 'C'
			THIS.myTG_ORIGEM = ''
		ENDIF
		
		* ENVIOU A MENSAGEM COM SUCESSO,DEVE GRAVAR LOG
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT
				SMS.*
			FROM
				TS_SMS SMS
			WHERE
				SMS.PK_ID IS NULL
		ENDTEXT
		=PESQUISASQL(lcCOMANDO,'TMPSMS')
		
		SELE TMPSMS
		GO TOP
		SCATTER NAME loREG BLANK MEMO
			
			loREG.FK_ORIGEM 	= THIS.myFK_ORIGEM
			loREG.TG_ORIGEM 	= THIS.myTG_ORIGEM
			loREG.DS_MENSAGEM 	= tcMSG
			loREG.DS_TELEFONE	= tcTELEFONE
			
		SELE TMPSMS
		APPEND BLANK
		GATHER NAME loREG MEMO
		
		SELE TMPSMS
		GO TOP
		THIS.myRETURNGRAVARLOG = ATUSQL("A","TS_SMS")	
		
		RETURN(1)
	ENDFUNC

ENDDEFINE

DEFINE CLASS BOTAOSCROLL AS Image
	WIDTH 	= 20
	HEIGHT = 20
	VISIBLE = .T. 
	MOUSEPOINTER = 15
	
	PROC INIT
	ENDPROC
	
	PROC TAG_ASSIGN
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method		
		IF vNewVal = 'AVANÇAR'
			THIS.Picture = POEIMG('ARROW_RIGHT.PNG')
		ELSE
			THIS.Picture = POEIMG('ARROW_LEFT.PNG')
		ENDIF
		THIS.TAG = m.vNewVal
	ENDPROC
		
	PROC CLICK
		loOBJ = THIS.Parent.SCNTBRANCO
		lnMOVER = INT(loOBJ.Width/125) * 125 + IIF(MOD(loOBJ.Width,125)>70,125,0)
		
		lnPAGEATU = THIS.Parent.myPAGEATU
		lnPAGETOT = THIS.Parent.myPAGETOT
		
		IF UPPER(THIS.Tag) = 'AVANÇAR'
			* CONTROLE PARA NÃO ESTOURAR LIMITES DE PÁGINAS
			IF lnPAGEATU < lnPAGETOT
				lnPAGEATU = lnPAGEATU + 1
			ELSE
				RETURN(.F.)
			ENDIF
		ELSE	
			* CONTROLE PARA NÃO ESTOURAR LIMITES DE PÁGINAS
			IF lnPAGEATU > 1
				lnPAGEATU = lnPAGEATU - 1
			ELSE
				RETURN(.F.)
			ENDIF
		ENDIF
		
		THIS.Parent.SCNTBRANCO.CTLHVALUE = lnMOVER * (lnPAGEATU-1)
		
		THIS.Parent.myPAGEATU = lnPAGEATU
		THIS.Parent.SetAll('FontBold',.F.,'LABELSCROLL')
		
		* MARCA COMO NEGRITO SOMENTE A LABEL REFERENTE À PAGINA ATUAL
		lcLABEL = 'goDESKTOP.PAGINAS.' + THIS.Parent.Name + '.LBLPAGENO' + ALLTRIM(TRANSFORM(lnPAGEATU))
		loLABEL = &lcLABEL
		loLABEL.FontBold = 1
	ENDPROC
ENDDEFINE

DEFINE CLASS LABELSCROLL AS Label
	MousePointer = 15
	
	PROC CLICK
		LOCAL lnPAGENO AS Integer
		STORE 0 TO lnPAGENO
		
		lnPAGENO = INT(VAL(THIS.Caption))
		
		loOBJ = THIS.Parent.SCNTBRANCO
		lnMOVER = INT(loOBJ.Width/125) * 125 + IIF(MOD(loOBJ.Width,125)>70,125,0)
		
		THIS.Parent.SCNTBRANCO.CTLHVALUE = lnMOVER * (lnPAGENO-1)
		
		THIS.Parent.myPAGEATU = lnPAGENO
		THIS.Parent.SetAll('FontBold',.F.,'LABELSCROLL')		
		THIS.FontBold = .T.	
	ENDPROC
ENDDEFINE

DEFINE CLASS LabelToolBar As Label
ForeColor = RGB(255,255,255)
	PROC CLICK
		THIS.Parent.Click()
	ENDPROC
ENDDEFINE

DEFINE CLASS btnFECHAR AS Container 
*************************************************
* #FLAT - BOTÃO PARA FECHAR FORMS EM LAYOUT FLAT
*******************************	*****************
Width 	= 40
Height	= 20 
BorderWidth = 0

ADD OBJECT lblSYMBOL AS LabelToolBar

PROC Click 	
	IF THIS.Parent.Parent.Closable
		THIS.Parent.Parent.Release()
	ENDIF
ENDPROC 

PROC MouseLeave
	LPARAMETERS tnButton, tnShift, tnXCoord, tnYCoord
	THIS.BackColor = ALTERARGB(THIS.Parent.Parent.BackColor,20)
ENDPROC

PROC MouseEnter
	LPARAMETERS tnButton, tnShift, tnXCoord, tnYCoord
	IF THIS.Parent.Parent.Closable
		THIS.BackColor = ALTERARGB(THIS.Parent.Parent.BackColor,50)
	ENDIF
ENDPROC

PROC Refresh
	This.lblSymbol.Enabled = This.Parent.Parent.Closable
	This.Visible = This.Parent.Parent.MinButton OR This.Parent.Parent.MaxButton OR This.Parent.Parent.Closable
ENDPROC

PROC Init
	THIS.lblSYMBOL.Alignment = 1 
	THIS.lblSYMBOL.BackStyle = 0
	THIS.lblSYMBOL.Caption = 'r'
	THIS.lblSYMBOL.FontName = 'Marlett'
	THIS.lblSYMBOL.Left = 11
	THIS.lblSYMBOL.Top = 4
	THIS.lblSYMBOL.Width = 14
	THIS.lblSYMBOL.Height = 14
	THIS.MouseLeave()
	THIS.BackColor = ALTERARGB(THIS.Parent.Parent.BackColor,20)
ENDPROC
	
ENDDEFINE

DEFINE CLASS btnMINIMIZAR AS Container
****************************************************
* #FLAT - BOTÃO PARA MINIMIZAR FORMS EM LAYOUT FLAT
****************************************************
Width 	= 25
Height	= 20 
BackColor = RGB(255,255,255)
BorderWidth = 0

ADD OBJECT lblSYMBOL AS LabelToolBar

PROC Click
	IF THIS.Parent.Parent.MinButton AND THIS.Enabled AND THIS.lblSYMBOL.Enabled 
		*THIS.Parent.Parent.WindowState = 1
		_screen.ActiveForm.WindowState = 1
		THIS.MouseLeave()
		*THIS.Parent.Parent.GotFocus()
	ENDIF
ENDPROC 

PROC MouseLeave
	LPARAMETERS tnButton, tnShift, tnXCoord, tnYCoord
	THIS.BackStyle = 0		&& Transparent.
ENDPROC

PROC MouseEnter
	LPARAMETERS tnButton, tnShift, tnXCoord, tnYCoord
	IF THIS.Parent.Parent.MinButton AND THIS.lblSymbol.Enabled
		This.BackStyle = 1		&& FundoColorido.
	ENDIF
ENDPROC

PROC Refresh
	This.lblSymbol.Enabled = This.Parent.Parent.MinButton
	* SE O FORM FOR MODAL DESABILITA BOTÃO
	IF THIS.Parent.Parent.WindowType = 1
		This.lblSymbol.Enabled = .F.
	ENDIF
	This.Visible = This.Parent.Parent.MinButton OR This.Parent.Parent.MaxButton
ENDPROC

PROC Init
	THIS.BackColor = ALTERARGB(THIS.Parent.Parent.BackColor,50)
	THIS.lblSYMBOL.Alignment = 1 
	THIS.lblSYMBOL.BackStyle = 0
	THIS.lblSYMBOL.Caption = '0'
	THIS.lblSYMBOL.FontBold = .T.
	THIS.lblSYMBOL.FontName = 'Marlett'
	THIS.lblSYMBOL.Left = 4
	THIS.lblSYMBOL.Top = 5
	THIS.lblSYMBOL.Width = 16
	THIS.lblSYMBOL.Height = 14
	THIS.MouseLeave()
ENDPROC
	
ENDDEFINE
 
DEFINE CLASS btnMAXIMIZAR AS Container 
*****************************************************
* #FLAT - BOTÃO PARA MAXIMIZAR FORMS EM LAYOUT FLAT
*****************************************************
Width 	= 25
Height	= 20 
BackColor = RGB(255,255,255)
BorderWidth = 0

ADD OBJECT lblSYMBOL AS LabelToolBar

PROC Click
	IF THIS.Parent.Parent.MaxButton	
		IF THIS.Parent.Parent.WindowState == 2
			THIS.Parent.Parent.WindowState = 0
			This.lblSymbol.Caption = "1"	&& Restore.
		ELSE
			THIS.Parent.Parent.WindowState = 2
			This.lblSymbol.Caption = "2"	&& Restore.
		ENDIF
		THIS.MouseLeave()
	ENDIF
ENDPROC 

PROC MouseLeave
	LPARAMETERS tnButton, tnShift, tnXCoord, tnYCoord
	THIS.BackStyle = 0		&& Transparent.
ENDPROC

PROC MouseEnter
	LPARAMETERS tnButton, tnShift, tnXCoord, tnYCoord
	IF THIS.Parent.Parent.MaxButton
		This.BackStyle = 1		&& FundoColorido.
	ENDIF
ENDPROC

PROC Refresh
	This.lblSymbol.Enabled = This.Parent.Parent.MaxButton
	This.Visible = This.Parent.Parent.MinButton OR This.Parent.Parent.MaxButton
	
	IF THIS.Parent.Parent.WindowState == 2	&& Maximized.
		This.lblSymbol.Caption = "2"	&& Restore.
	ELSE								&& Normal.
		This.lblSymbol.Caption = "1"	&& Maximize.
	ENDIF
	
	THIS.MouseLeave()
ENDPROC

PROC Init
	THIS.BackColor = ALTERARGB(THIS.Parent.Parent.BackColor,50)
	THIS.lblSYMBOL.Alignment = 1 
	THIS.lblSYMBOL.BackStyle = 0
	THIS.lblSYMBOL.Caption = '1'
	THIS.lblSYMBOL.FontBold = .T.
	THIS.lblSYMBOL.FontName = 'Marlett'
	THIS.lblSYMBOL.Left = 4
	THIS.lblSYMBOL.Top = 5
	THIS.lblSYMBOL.Width = 16
	THIS.lblSYMBOL.Height = 14
	THIS.MouseLeave()
ENDPROC
	
ENDDEFINE

DEFINE CLASS FLATTEMP AS Label  
********************************************************
* #FLAT - CONTROLE PARA EXIBIÇÃO DE TELAS NA TEMPORÁRIA 
********************************************************

* DEFINE CONFIGURAÇÕES 
BackColor 	= RGB(241,196,15)
Caption		= ' TEMP '
FontBold	= .T.
FontSize	= 25 
ForeColor	= RGB(255,255,255)
Height		= 41 
Width		= 112 

* OMITIR MARCAÇÃO NO DUPLO CLIQUE 
PROC DblClick 
	This.Visible = .F.
ENDPROC 

ENDDEFINE 

DEFINE CLASS FLATAMBIENTE AS Control 
*************************************************************************
* #FLAT - CONTROLE PARA EXIBIÇÃO DE AMBIENTE (PRODUÇÃO/TREINAMENTO ETC)
*************************************************************************

* DEFINIÇÕES DE PROPRIEDADES 
myAMBIENTE 		= ''
BackStyle 		= 0
BorderWidth 	= 0
Width			= 50
Height			= 50

ADD OBJECT shpFUNDOAMBIENTE AS SHAPE 
ADD OBJECT lblAMBIENTE AS LABEL 

*#FLATEMP OMITIR MARCAÇÃO NO DUPLO CLIQUE 
PROC shpFUNDOAMBIENTE.DblClick 
	THIS.Parent.DblCLick() 
ENDPROC 

PROC lblAMBIENTE.DblClick 
	THIS.Parent.DblCLick() 
ENDPROC 

PROC DblCLICK
	This.shpFUNDOAMBIENTE.Visible 	= .F.
	This.lblAMBIENTE.Visible 		= .F.
ENDPROC 

* CONFIGURA OBJETOS  DO CONTROLE  
PROC INIT
	* SHAPE 
	WITH THIS.shpFUNDOAMBIENTE AS Shape 
		.BackColor 	= RGB(241,196,15)
		.Curvature 	= 99
		.Height		= 50
		.Width 		= 50
	ENDWITH 

	* LABEL 
	WITH THIS.lblAMBIENTE AS Label 
		.BackStyle	= 0 
		.FontBold	= .T. 
		.FontSize	= 25
		.ForeColor 	= RGB(255,255,255)
		.Caption 	= ''
		.Top		= 8
		.Left 		= 0 
		.Width 		= 50 
		.Height 	= 50 
		.Alignment  = 2 
	ENDWITH 
ENDPROC  

PROC myAMBIENTE_ASSIGN 
LPARAMETERS vNewVal

* CARREGA CONTEÚDO PARA EXIBIÇÃO 
	THIS.lblAMBIENTE.Caption = LEFT(ALLTRIM(UPPER(vNewVal)),1)
ENDPROC 	
	
ENDDEFINE 

DEFINE CLASS FLATCONTROLBOX AS Control 
**************************************************************
* #FLAT - CONTROLE PARA AÇÕES DO FORM (FECHAR, MINIMIZAR ETC)
**************************************************************

* TRANSPARÊNCIA 
BackStyle 		= 0 
BorderWidth 	= 0 
Width 			= 92
Height			= 20

* ADICIONA BOTÕES  
ADD OBJECT btnMINIMIZAR AS btnMINIMIZAR 
ADD OBJECT btnMAXIMIZAR AS btnMAXIMIZAR 
ADD OBJECT btnFECHAR AS btnFECHAR

PROC init 
	THIS.btnMINIMIZAR.left 	= 0 
	THIS.btnMAXIMIZAR.left 	= 26
	THIS.btnFECHAR.left 	= 52
ENDPROC 
 
PROC Refresh
	THIS.btnMINIMIZAR.MouseLeave()
	THIS.btnMAXIMIZAR.MouseLeave()
	THIS.btnFECHAR.MouseLeave()
ENDPROC

 
ENDDEFINE

PROC DESABILITARPK
******************
* DESABILITA O CAMPO PK_ID NA ALTERAÇÃO (FORMDIG / FORMDBF)
LPARAMETERS toOBJETO AS Object
	IF TYPE('toOBJETO') <> 'O'
		RETURN
	ENDIF

	LOCAL loSUB, loPAGINA AS Object
	LOCAL lcBASE AS String
	STORE '' TO lcBASE

	FOR EACH loSUB IN toOBJETO.CONTROLS

		lcBASE	= ALLTRIM( UPPER( loSUB.BASECLASS ) )

		DO CASE
			CASE lcBASE	= 'PAGEFRAME'
				FOR EACH loPAGINA IN loSUB.PAGES
					DO DESABILITARPK WITH loPAGINA
				ENDFOR

			CASE lcBASE = 'CONTAINER'
				DO DESABILITARPK WITH loSUB

			OTHERWISE
				IF lcBASE = 'TEXTBOX'
					IF ALLTRIM(UPPER(loSUB.CONTROLSOURCE)) = 'THISFORM.EE.PK_ID'
						loSUB.ENABLED	= .F.
					ENDIF
				ENDIF

		ENDCASE
	ENDFOR
RETURN

FUNC VERIFOBRIGATORIO
*********************
* VERIFICA DIGITAÇÃO DE CAMPOS OBRIGATÓRIOS
LPARAMETERS toOBJETO AS Object
	IF TYPE('toOBJETO') <> 'O'
		RETURN
	ENDIF

	LOCAL loSUB, loPAGINA, loFRAME AS Object
	LOCAL lcBASE, lcCLASS AS String
	LOCAL llERRO AS Logical
	STORE '' TO lcBASE, lcCLASS 
	STORE .F. TO llERRO

	FOR EACH loSUB IN toOBJETO.CONTROLS

		lcBASE	= ALLTRIM( UPPER( loSUB.BASECLASS ) )
		lcCLASS = ALLTRIM( UPPER( loSUB.CLASS ) )
		
		DO CASE
			CASE lcBASE	= 'PAGEFRAME'
				FOR EACH loPAGINA IN loSUB.PAGES
					llERRO	= VERIFOBRIGATORIO(loPAGINA)
					IF llERRO
						EXIT
					ENDIF
				ENDFOR

			CASE lcBASE = 'CONTAINER'
				llERRO	= VERIFOBRIGATORIO(loSUB)
			
			CASE lcBASE = 'CONTROL'

				* TRATAMENTO ESPECIAL PARA O COMBONN
				IF lcCLASS = 'COMBONN'
					IF '*' $ loSUB.COMMENT AND loSUB.Enabled = .T.
						IF EMPTY(ALLTRIM(loSUB.mySELECIONADOS))
							loFRAME = loSUB.Parent
							IF ALLTRIM(UPPER(loFRAME.BASECLASS)) == 'PAGE'
								loFRAME.Parent.ActivePage = loFRAME.PageOrder
							ENDIF
							DO MENS WITH 'CAMPO DE PREENCHIMENTO OBRIGATÓRIO'
							loSUB.SetFocus()
							llERRO	= .T.
						ENDIF
					ENDIF
				ENDIF

			OTHERWISE
				IF lcBASE $ ',TEXTBOX,EDITBOX,SPINNER,'
					IF '*' $ loSUB.COMMENT AND loSUB.Enabled = .T.
						IF VARTYPE(loSUB.VALUE)='C'
							loSUB.VALUE = STRTRAN(loSUB.VALUE,"'","")
						ENDIF
						IF EMPTY(loSUB.VALUE)
							loFRAME = loSUB.Parent
							IF ALLTRIM(UPPER(loFRAME.BASECLASS)) == 'PAGE'
								loFRAME.Parent.ActivePage = loFRAME.PageOrder
							ENDIF
							DO MENS WITH 'CAMPO DE PREENCHIMENTO OBRIGATÓRIO'
							loSUB.SetFocus()
							llERRO	= .T.
						ENDIF
					ENDIF
				ENDIF
				IF lcBASE $ ',COMBOBOX,'
					IF '*' $ loSUB.COMMENT AND loSUB.Enabled = .T.
						IF VARTYPE(loSUB.VALUE)='C'
							IF loSUB.Style = 0 	&& DropDownCombo
								loSUB.Value = STRTRAN(loSUB.Text,"'","")
							ELSE 				&& DropDownList
								loSUB.Value = STRTRAN(loSUB.Value,"'","")							
							ENDIF
						ENDIF
						IF EMPTY(loSUB.VALUE)
							loFRAME = loSUB.Parent
							IF ALLTRIM(UPPER(loFRAME.BASECLASS)) == 'PAGE'
								loFRAME.Parent.ActivePage = loFRAME.PageOrder
							ENDIF
							DO MENS WITH 'CAMPO DE PREENCHIMENTO OBRIGATÓRIO'
							loSUB.SetFocus()
							llERRO	= .T.
						ENDIF
					ENDIF
				ENDIF				
				IF lcBASE $ ',LISTBOX,'
					IF '*' $ loSUB.COMMENT AND loSUB.Enabled = .T.
						IF loSUB.ListCount<=0
							loFRAME = loSUB.Parent
							IF ALLTRIM(UPPER(loFRAME.BASECLASS)) == 'PAGE'
								loFRAME.Parent.ActivePage = loFRAME.PageOrder
							ENDIF
							DO MENS WITH 'CAMPO DE PREENCHIMENTO OBRIGATÓRIO'
							loSUB.SetFocus()
							llERRO	= .T.
						ENDIF
					ENDIF
				ENDIF
 		ENDCASE
		IF llERRO
			EXIT
		ENDIF
	ENDFOR
RETURN(llERRO)

FUNC VERIFNEGATIVO
	LPARAMETERS toOBJETO AS Object

	IF TYPE('toOBJETO') <> 'O'
		RETURN(.F.)
	ENDIF

	LOCAL loSUB, loPAGINA AS Object
	LOCAL lcBASE, lcZWNOME AS String
	STORE '' TO lcBASE

	FOR EACH loSUB IN toOBJETO.CONTROLS
		lcBASE	= ALLTRIM( UPPER( loSUB.BASECLASS ) )
		DO CASE
			CASE lcBASE	= 'PAGEFRAME'
				FOR EACH loPAGINA IN loSUB.PAGES
					IF VERIFNEGATIVO(loPAGINA)
						RETURN(.T.)
					ENDIF
				ENDFOR
			CASE lcBASE = 'CONTAINER'
				IF VERIFNEGATIVO(loSUB)
					RETURN(.T.)
				ENDIF
			OTHERWISE
				IF lcBASE $ ',TEXTBOX,SPINNER,'
					IF '<NEG=YES>' $ loSUB.COMMENT
						LOOP
					ELSE
						IF TYPE('loSUB.Value') = 'N'
							IF loSUB.Enabled = .T. AND loSUB.Value < 0
								DO MENS WITH 'Campo não pode ser negativo.'
								loFRAME = loSUB.Parent
								IF ALLTRIM(UPPER(loFRAME.BASECLASS)) == 'PAGE'
									loFRAME.Parent.ActivePage = loFRAME.PageOrder
								ENDIF
								loSUB.Setfocus()
								RETURN(.T.)
							ENDIF
						ENDIF
					ENDIF
				ENDIF
		ENDCASE
	ENDFOR

	RETURN(.F.)

ENDFUNC

PROC EXECUTARF12
****************
	LOCAL lnATIVO AS Integer
	STORE 0 TO lnATIVO
	lnATIVO	= RETORNASET('REDEINFO.F12','N',1)
	IF lnATIVO = 0
		* F12 DESABILITADO
		RETURN
	ENDIF
	IF TYPE('goFORMEMPFU.BaseClass') = 'C'
		IF ALLTRIM(UPPER(goFORMEMPFU.BaseClass)) = 'FORM'
			* ESTA ATIVO
			goFORMEMPFU.Release()
			goAPLICATIVO.EMPFILTRO	= goAPLICATIVO.EMPFILTROSF12
		ENDIF
	ELSE
		goAPLICATIVO.EMPFILTRO	= goAPLICATIVO.EMPFILTROCF12
		goFORMEMPFU	= CREATEOBJECT('FORMEMPFU')
		goFORMEMPFU.Show(2)
	ENDIF
RETURN

FUNC SEMACENTO
**************
* TROCA LETRAS ACENTUADAS
LPARAMETERS tcSUJA
	LOCAL I AS INTEGER
	LOCAL lcLETRA, lcLIMPA AS STRING
	LOCAL lcCARACS1, lcCARACS2 AS STRING
	lcCARACS1 = 'ãáàâéèêõóòôíìîúùüûçÃÁÀÂÉÈÊÕÓÒÔÍÌÎÚÙÜÛÇ'
	lcCARACS2 = 'aaaaeeeooooiiiuuuuCAAAAEEEOOOOIIIUUUUC'
	lcLIMPA = ''
	FOR I = 1 TO LEN(tcSUJA)
		lcLETRA = SUBS(tcSUJA,I,1)
		IF ASC(lcLETRA)>122
			lnPOSICAO = AT(lcLETRA,lcCARACS1)
			IF lnPOSICAO>0
				lcLETRA = SUBSTR(lcCARACS2,lnPOSICAO,1)
			ENDIF
		ENDIF
		lcLIMPA = lcLIMPA + lcLETRA
	ENDFOR
RETURN(lcLIMPA)

PROC STARTAFILE
***************
LPARAMETERS tcARQUIVO AS String, tnOUTROS AS Integer 
* tcARQUIVO   ->   ARQUIVO OU COMANDO A SER EXECUTADO
* tcOUTROS    ->   COMANDOS ADICIONAIS 
*			  ->   0 - NADA FAZ (COMO ANTES)
*			  ->   1 - NÃO VERIFICA SE O ARQUIVO EXISTE

	IF TYPE('tcARQUIVO') <> 'C'
		tcARQUIVO = ''	
	ENDIF
	IF EMPTY(tcARQUIVO)
		RETURN
	ENDIF
	IF TYPE('tnOUTROS') <> 'N'
		tnOUTROS = 0
	ENDIF
	
	* CASO SEJA ZERO, VERIFICA EXISTENCIA DO ARQUIVO
	IF tnOUTROS = 0
		IF NOT FILE(tcARQUIVO)
			DO MENS WITH 'Arquivo não encontrado: '+tcARQUIVO
			RETURN
		ENDIF
	ENDIF

	DECLARE LONG ShellExecute IN "shell32.dll" ;
		LONG HWND, STRING lpszOp, ;
		STRING lpszFile, STRING lpszParams, ;
		STRING lpszDir, LONG nShowCmd
		
	* SE FOR IGUAL A 1 NÃO PASSA O FULLPATH NO COMANDO	
	IF tnOUTROS = 1
		SHELLEXECUTE( 0, 'Open', tcARQUIVO, 0, 0, 1)
	ELSE
		SHELLEXECUTE( 0, 'Open', FULLPATH(tcARQUIVO), 0, 0, 1)		
	ENDIF

RETURN

PROC AMBIENTAR
**************
	SET TALK OFF
	SET ESCAPE OFF
	SET EXCL OFF
	SET DELE ON
	SET DATE BRITISH
	SET CURSOR ON
	SET NOTIFY OFF
	SET SAFETY OFF
	SET READBORDER ON
	SET DECIMAL TO 8
	SET REPROCESS TO 3 SECONDS
	SET POINT TO ','
	SET SEPA TO '.'
	SET EXACT OFF
	SET NEAR OFF
	SET CONFIRM ON
	SET CLOCK STATUS
	SET CENTURY ON
	SET MEMOWIDTH TO 512
	SET HOURS TO 24
	SET ENGINEBEHAVIOR 80
	SET REPORTBEHAVIOR 90
	
	* TRATAMENTO DE COLLATE DO SISTEMA PARAMETRIZÁVEL POR ZW
	IF TYPE('GOAPLICATIVO.COLLATE') = 'C'
		SET COLLATE TO GOAPLICATIVO.COLLATE
	ENDIF
RETURN

PROC ENCERRAR
*************
LPARAMETERS tnPERGUNTAR
* PERGUNTAR SE FINALIZA OU NÃO
	IF TYPE('tnPERGUNTAR')<>'N'
		tnPERGUNTAR=0
	ENDIF

	IF tnPERGUNTAR= 1
		LOCAL lnRESP AS LOGICAL
		lnRESP = SIMOUNAO('Deseja encerrar o aplicativo?','Sair',1)
		IF NOT lnRESP
			RETURN
		ENDIF
	ENDIF
	ON SHUTDOWN
	IF TYPE('goCONEXAO')='O'
		* MATA CONEXÃO
		TRY 
			goCONEXAO.DESCONECTAR()
		CATCH
			CANCEL
		ENDTRY
	ENDIF
	
	IF TYPE('goAPLICATIVO')='O'
		* DESLIGA TODOS OS FORMS
		TRY 
			goAPLICATIVO.KILLFORMS()
			IF NOT EMPTY(goAPLICATIVO.JOB_NAME)
				goAPLICATIVO.MYSYSTRAY.RemoveIconFromSystray()
			ENDIF
			*RELEASE ALL
		CATCH
			CANCEL
		ENDTRY
	ENDIF
	IF TYPE('_SCREEN.oSTATUSBAR')='O'
		_SCREEN.RemoveObject('oSTATUSBAR')
	ENDIF
	
	SET PROCEDURE TO
	CLEAR EVENTS
*	CLEAR PROGRAM

	IF TYPE('goAPLICATIVO')='O'
		IF goAPLICATIVO.TESTE = .T.
			CLEAR WINDOWS
			SET SYSMENU TO DEFA
			CLEAR CLASSLIB PWICLASS
			CLEAR CLASSLIB RESCLASS
			IF tnPERGUNTAR<>0
				TRY 
					CLEAR ALL
				CATCH
				ENDTRY
			ENDIF
		ENDIF
	ENDIF
	CLEAR WINDOWS
	SET PATH TO
	CLOSE DATA
	CANCEL
RETURN

PROC MONTADESKTOP
*****************
	* NÃO ESTÁ CONECTADO ENTÃO NÃO INICIA MENU
	IF goCONEXAO.ALCA <= 0
		RETURN
	ENDIF

	* LÊ CONFIGURAÇÃO DAS OPÇÕES DO MENU
	LOCAL lcCOMANDO, lcSUPERVISOR AS String
	LOCAL llTEMICONES AS Logical
	LOCAL lnMAXHEIGHT AS Integer
	llTEMICONES	= .T.
	
	goCONEXAO.MONTADIREITOS()
	SELE TMPSYS

	DO MENUTOPO

	* CONTA QUANTAS PAGINAS TEM
	LOCAL llTEMDIREITO AS Logical
	LOCAL lcGRUPO AS String
	LOCAL lnPAGES, lnXI, lnQTDGRUPOS AS Integer
	lnPAGES			= 0
	llTEMDIREITO	= .F.
	
	* DEPENDENDO DO TAMANHO DO CAMPO DE GRUPOS A SIGLA DE SUPERVISOR MUDA
	lcSUPERVISOR = IIF(goCONEXAO.TAMANHOGRUPO=1,'S','SSS')
	
	SELE TMPSYS
	GO TOP
	* VERIFICA APENAS AS GUIAS
	SCAN FOR NR_TIPO=0
		IF NR_GUIA=0
			LOOP
		ENDIF
		llTEMDIREITO	= .F.
		IF NOT lcSUPERVISOR $ goCONEXAO.GRUPO
			* NÃO É SUPERVISOR ENTÃO TEM QUE VERIFICAR SE USUÁRIO POSSUI DIREITO NA ROTINA
			IF VERIFGRUPOS(GOCONEXAO.GRUPO,TMPSYS.DS_DIREITOS)
				llTEMDIREITO = .T.
			ENDIF
		ELSE
			llTEMDIREITO = .T.
		ENDIF

		IF llTEMDIREITO
			lnPAGES = lnPAGES + 1
		ENDIF
	ENDSCAN

	* OBJETO DE DESKTOP SEMPRE É REFEITO
	IF TYPE('goDESKTOP') = 'O'
		RELEASE goDESKTOP
	ENDIF

	PUBLIC goDESKTOP AS CUSTOM

	goDESKTOP = CREATEOBJECT("MEUDESKTOP")
	goDESKTOP.Name = 'frmDESKTOP'
	
	* ICONE EM AMBIENTE DE TESTES
	IF GOAPLICATIVO.TESTE 
		IF FILE('P:\TESTES.ICO')
			goDESKTOP.Icon = 'P:\TESTES.ICO'
		ELSE
			IF FILE(SYS(5) + '\TESTESVF\PLATA\TESTES.ICO')
				goDESKTOP.Icon = SYS(5) + '\TESTESVF\PLATA\TESTES.ICO'
			ENDIF
		ENDIF
	ENDIF
		
	* SE NÃO EXISTE NENHUM ABA COM DIREITO, ENTÃO MOSTRA MENSAGEM
	IF lnPAGES = 0
		
		* CRIA LABEL COM MENSAGEM PARA O USUÁRIO
		goDESKTOP.AddObject('lblMENSAGEM','LABEL')
		WITH goDESKTOP.lblMENSAGEM AS Label
			TEXT TO .Caption NOSHOW PRETEXT 7
				ATENÇÃO! Não existe nenhum módulo disponível para o seu usuário.
				Entre em contato com o administrador do sistema para saber mais detalhes.
			ENDTEXT
			.Alignment 	= 2 
			.Width 		= goDESKTOP.Width
			.Height 	= goDESKTOP.Height
			.Top		= goDESKTOP.Height/2 - 50
			.FontBold 	= .T.
			.FontSize 	= 16
			.ForeColor 	= RGB(255,0,0)			
			.Visible 	= .T.
		ENDWITH
		
		RETURN
	ENDIF

	* VERIFICAR GUIA FAVORITOS
	IF UPPER(RETORNASET('DESKTOP.FAVORITOS','C',1)) == 'ON'
		goAPLICATIVO.FAVORITOS = 1
	ENDIF
	
	IF goAPLICATIVO.FAVORITOS = 1
	
		LOCAL lcCOMANDO,lcCOLUNA AS String
		STORE '' TO lcCOMANDO,lcCOLUNA
		
		LOCAL lnORDEM, lnCOLUNA AS Integer
		STORE 1 TO lnORDEM, lnCOLUNA
		
		* VARIAVEL PARA CONFIGURAR TOTAL DE ICONES POR COLUNA EM FAVORITOS
		LOCAL lnQT_MAX AS Integer
		STORE 10 TO lnQT_MAX
		
		* CONSULTAR E ADICIONAR ROTINAS FAVORITAS
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT
				MOD.*,
				CAST( ' ' AS CHAR(25) ) AS DS_GINOME,
				CAST(0 AS INTEGER) AS TG_GUIAHOME
			FROM TS_FAVORITOS FAV
				LEFT JOIN TS_MODULOS MOD ON MOD.PK_ID = FAV.FK_ROTINA
			WHERE FAV.FK_USUARIO = [FK_USUARIO]
				AND MOD.TG_INATIVO=0
			ORDER BY MOD.DS_TITULO
		ENDTEXT
		
		* SE TIVER SIMULANDO USUÁRIO HERDA A HOME DO USUÁRIO SIMULADO
		IF goCONEXAO.FK_USUARIOPERFIL<>goCONEXAO.FK_USUARIO
			lcCOMANDO	= STRTRAN( lcCOMANDO, '[FK_USUARIO]', XX(goCONEXAO.FK_USUARIOPERFIL) )
		ELSE
			lcCOMANDO	= STRTRAN( lcCOMANDO, '[FK_USUARIO]', XX(goCONEXAO.FK_USUARIO) )
		ENDIF
		=PESQUISASQL(lcCOMANDO,'TMPSYSFAVORITOS')
		
		* CASO EXISTIR FAVORITOS
		SELE TMPSYSFAVORITOS
		GO TOP
		IF RECCOUNT('TMPSYSFAVORITOS') > 0
			
			* LIMPAR A CADA NOVA EXECUÇÃO
			goAPLICATIVO.MEUSFAVORITOS = ''
			
			* ALIMENTAR PROPRIEDADE COM ROTINAS FAVORITAS DO USUARIO
			SELE TMPSYSFAVORITOS
			GO TOP
			SCAN WHILE NOT EOF()
				IF EMPTY(goAPLICATIVO.MEUSFAVORITOS)
					goAPLICATIVO.MEUSFAVORITOS = ALLTRIM(TMPSYSFAVORITOS.DS_ROTINA) + ','
				ELSE
					IF NOT ALLTRIM(TMPSYSFAVORITOS.DS_ROTINA) $ goAPLICATIVO.MEUSFAVORITOS
						goAPLICATIVO.MEUSFAVORITOS = goAPLICATIVO.MEUSFAVORITOS + ALLTRIM(TMPSYSFAVORITOS.DS_ROTINA) + ','
					ENDIF
				ENDIF		
			ENDSCAN
	
			SELE TMPSYS
			GO TOP
			SELECT * FROM TMPSYS INTO CURSOR TMPSYSBKP
			
			* QTDE MAXIMA DE GUIAS
			LOCAL lnMAX_GUIA as Integer
			STORE 0 TO lnMAX_GUIA
			
			SELE TMPSYS
			GO TOP
			SELECT TOP 1 NR_GUIA FROM TMPSYS ORDER BY NR_GUIA DESC INTO CURSOR TMPMAXGUIA
			
			SELE TMPMAXGUIA
			GO TOP
			lnMAX_GUIA = TMPMAXGUIA.NR_GUIA + 1
			USE IN TMPMAXGUIA
			
			* APAGAR CURSOR DE ROTINAS DO SISTEMA
			SELE TMPSYS
			ZAP
			
			* ADICIONAR GUIA DE FAVORITOS	
			SELE TMPSYS
			SCATTER NAME loREG MEMO
				loREG.NR_TIPO 		= 0
				loREG.NR_GUIA		= lnMAX_GUIA
				loREG.DS_ROTINA		= 'HOME_GUIA'
				loREG.DS_TITULO		= 'Home'
				loREG.DS_TIPTITULO	= 'Módulos de favoritos por usuário'
				loREG.DS_NOMEDOPAI	= 'GUIAHOME'
				loREG.DS_ICONE 		= 'GUIA_HOME'
				loREG.DS_OBJETIVO	= 'Módulo utilizado para concentrar os recursos mais utilizados do sistema para cada usuário. Utilize o ambiente abaixo para acessar as opções que você mais utiliza.'
				loREG.TG_GUIAHOME	= 1
			SELE TMPSYS
			APPEND BLANK
			GATHER NAME loREG MEMO
				
			* TRATAR CURSOR TMPSYSFAVORITOS PARA APRENSETAÇÃO NA GUIA DE FAVORITOS
			SELE TMPSYSFAVORITOS
			REPLACE ALL TMPSYSFAVORITOS.NR_GUIA WITH lnMAX_GUIA
			
			SELE TMPSYSFAVORITOS
			GO TOP
			SCAN WHILE NOT EOF()
				* VERIFICAR COLUNA DO ICONE NA GUIA FAVORITOS
				lcCOLUNA = FAVORITOS_GUIACOLUNA(lnCOLUNA)
				
				REPLACE TMPSYSFAVORITOS.NR_POSICAO 	WITH lnORDEM,;
						TMPSYSFAVORITOS.DS_GI		WITH lcCOLUNA,;
						TMPSYSFAVORITOS.DS_GINOME	WITH 'Meus Favoritos #' + ALLTRIM(STR(lnCOLUNA))
				
				lnORDEM = lnORDEM + 1
				
				IF lnORDEM > lnQT_MAX
					lnCOLUNA = lnCOLUNA + 1
					lnQT_MAX = lnCOLUNA * lnQT_MAX
				ENDIF
			ENDSCAN
					
			* ADICIONAR ROTINAS FAVORITAS
			SELE TMPSYSFAVORITOS
			GO TOP
			SCAN WHILE NOT EOF()
				SCATTER NAME loREG MEMO
				
				SELE TMPSYS
				APPEND BLANK
				GATHER NAME loREG MEMO
			ENDSCAN		
			
			* ADICIONAR NOVAMENTE OUTRAS GUIAS E ROTINAS DO SISTEMA
			SELE TMPSYSBKP
			GO TOP
			SCAN WHILE NOT EOF()			
				SCATTER NAME loREG MEMO
				
				SELE TMPSYS
				APPEND BLANK
				GATHER NAME loREG MEMO
			ENDSCAN
			
			* ADD NOVA GUIA FAVORITO
			lnPAGES = lnPAGES + 1
			
			USE IN TMPSYSBKP
			USE IN TMPSYSFAVORITOS
		ENDIF
	ENDIF
		
	goDESKTOP.PAGINAS.PAGECOUNT = lnPAGES

	LOCAL loPAGE AS Page
	FOR EACH loPAGE IN goDESKTOP.PAGINAS.PAGES
		loPAGE.AddProperty('CARREGADO',.F.)
		=BINDEVENT(loPAGE,'ACTIVATE',loPAGE.Parent,'CARREGAICONES')
		
		* FLAT - MOVER PAGINAÇÃO NO MOUSEWHEEL
		IF goAPLICATIVO.FLAT = 1 
			=BINDEVENT(loPAGE,'MouseWheel',loPAGE.Parent,'MouseWheel')		
		ENDIF 
	ENDFOR
	
	goDESKTOP.PAGINAS.TABSTRETCH	= 0	&& MULTIPLAS LINHAS DE TITULO
	goDESKTOP.PAGINAS.HEIGHT		= goDESKTOP.HEIGHT-10

	* MONTA ATALHOS E NOMES DAS OPÇÕES EM CADA PAGINA
	LOCAL lnCODIGOPG, lnPAGINA, lnATALHO, lnTOPO, lnMARGEM, lnQTMARGEM, lnANTGUIA, lnCOR AS Integer
	STORE 0 TO lnCODIGOPG, lnPAGINA, lnATALHO, lnTOPO, lnMARGEM, lnQTMARGEM, lnCOR
	LOCAL lcPAGENAME, lcATALHO, lcICONE, lcPICTURE, lcGI, lcAUX AS String
	STORE '' TO lcPAGENAME, lcATALHO, lcICONE, lcPICTURE, lcGI, lcAUX
	LOCAL lcXML AS String
	STORE '' TO lcXML
	
	lnANTGUIA = 0
	
	SELE TMPSYS
	GO TOP
	SCAN WHILE NOT EOF()
		llTEMDIREITO	= .F.
		IF NOT lcSUPERVISOR $ goCONEXAO.GRUPO
			* NÃO É SUPERVISOR E TEM QUE OLHAR PARA VER SE TEM DIREITO
			IF VERIFGRUPOS(GOCONEXAO.GRUPO,TMPSYS.DS_DIREITOS) OR TMPSYS.TG_GUIAHOME = 1
				llTEMDIREITO	= .T.
			ENDIF
		ELSE
			llTEMDIREITO	= .T.
		ENDIF
		IF NOT llTEMDIREITO
			LOOP
		ENDIF
		IF TMPSYS.NR_TIPO = 0
			lnCODIGOPG	= TMPSYS.NR_GUIA
			lnPAGINA	= lnPAGINA + 1
			lcPAGENAME	= 'PAGE'+ALLTRIM(STR(lnPAGINA))
			goDESKTOP.PAGINAS.&lcPAGENAME .CAPTION 		= ALLTRIM(TMPSYS.DS_TITULO)
		
			* #FLAT - CASO ATIVO CONFIGURA PÁGINA
			IF goAPLICATIVO.FLAT = 1 
				* CCONFIGURA COR DA PÁGINA  
				TEXT TO lcCOMANDO NOSHOW PRETEXT 7
					SELECT 
						COR.PK_ID,
						COR.NR_COR
					FROM 
						TS_FLATCORES AS COR 
					WHERE 
						PK_ID = [[FK_FLATCOR]]
				ENDTEXT
				lcCOMANDO = STRTRAN(lcCOMANDO,'[[FK_FLATCOR]]',XX(TMPSYS.FK_FLATCOR))
				=PESQUISASQL(lcCOMANDO,'TMPCOR')
				
				* DEFINE COR 
				IF NOT EMPTY(NVL(TMPCOR.NR_COR,0))
					goDESKTOP.PAGINAS.&lcPAGENAME .BackColor = TMPCOR.NR_COR
				ELSE
					* COR PADRÃO 
					goDESKTOP.PAGINAS.&lcPAGENAME .BackColor = goAPLICATIVO.FLATCORDEFAULT
				ENDIF 
				
				* CONFIGURA CORES E FONTE 
				goDESKTOP.PAGINAS.&lcPAGENAME .ForeColor = RGB(255,255,255)
				goDESKTOP.PAGINAS.&lcPAGENAME .FontName	 = goAPLICATIVO.FLATFONT2		
				
				* ADICIONA ICONE DO MODULO
				goDESKTOP.PAGINAS.&lcPAGENAME .AddObject('imgICON','Image')
				lcAUX = 'goDESKTOP.PAGINAS.' + ALLTRIM(lcPAGENAME) + '.imgICON'
				WITH &lcAUX AS Image 
					.Visible	= .T. 
					.Left 		= 25 
					.Top 		= 12  
					.Width		= 100 - 20
					.Height		= 100 - 20 
					.Stretch	= 1
					
					* CASO NÃO TENHA ICONE PARAMETRIZADO ADICIONA ICONE PADRÃO 
					LOCAL lcPATHICON AS String 
					STORE '' TO lcPATHICON
					
					IF goAPLICATIVO.TESTE OR goAPLICATIVO.WAWATIVO = 0   
						lcPATHICON = 'ICONFLAT\'
					ELSE 
						lcPATHICON = 'ICONES\'
					ENDIF 
					
					IF FILE(lcPATHICON +ALLTRIM(JUSTSTEM(TMPSYS.DS_ICONE))+'.PNG')
						.Picture	= lcPATHICON + ALLTRIM(JUSTSTEM(TMPSYS.DS_ICONE))+'.PNG'
					ELSE 
						.Picture	= lcPATHICON + "DEFAULT_MODULOS.PNG"
					ENDIF 
				ENDWITH 
				
				* ADICIONA TÍTULO DO MÓDULO 
				goDESKTOP.PAGINAS.&lcPAGENAME .AddObject('lblTITULO','Label')
				lcAUX = 'goDESKTOP.PAGINAS.' + ALLTRIM(lcPAGENAME) + '.lblTITULO'
				WITH &lcAUX AS Label
					.Visible	= .T. 
					.AutoSize 	= .T.
					.BackStyle	= 0
					.Caption	= TMPSYS.DS_TITULO 
					.FontName	= goAPLICATIVO.FLATFONT1
					.FontSize	= 35 - 5
					.ForeColor	= RGB(255,255,255)
					.Left		= 140 - 23
					.Top		= 7 
				ENDWITH 
				
				* ADICIONA DESCRIÇÃO DO MÓDULO 
				goDESKTOP.PAGINAS.&lcPAGENAME .AddObject('lblDESCRICAO','Label')
				lcAUX = 'goDESKTOP.PAGINAS.' + ALLTRIM(lcPAGENAME) + '.lblDESCRICAO'
				WITH &lcAUX AS Label
					.Visible	= .T.
					.WordWrap	= .T.
					.BackStyle	= 0
					*.AutoSize 	= .T. 
					.Caption	= TMPSYS.DS_OBJETIVO
					.FontName	= goAPLICATIVO.FLATFONT2
					.FontSize	= 10 - 2
					.ForeColor	= RGB(255,255,255)
					.Left		= 145 - 23
					.Top		= 72 - 13
					.Width 		= 800 
					.Height 	= 55 
				ENDWITH 
				
			ENDIF 
		ENDIF
		IF lnANTGUIA <> TMPSYS.NR_GUIA
			* MONTA NOVA PÁGINA
			lnANTGUIA	= TMPSYS.NR_GUIA

			* ARMAZENA CONTEUDO DAS GUIAS NO TAG PARA FUTURO CARREGAMENTO
			SELECT * FROM TMPSYS WHERE NR_GUIA = lnCODIGOPG AND NR_TIPO IN (0,1) INTO CURSOR TMPSYSAUX READWRITE

			lcPAGENAME	= 'PAGE'+ALLTRIM(STR(lnPAGINA))
			
			IF TYPE('goDESKTOP.PAGINAS.'+lcPAGENAME) <> 'O'
				LOOP
			ENDIF
			
			=CURSORTOXML('TMPSYSAUX','lcXML',3,0,0,"1")
			goDESKTOP.PAGINAS.&lcPAGENAME .TAG = lcXML
			
			IF USED('TMPSYSAUX')
				USE IN TMPSYSAUX
			ENDIF
		ENDIF
	ENDSCAN
	
	
	* INFORMAÇÕES DO USUÁRIO PASSAM A SEREM EXIBIDAS NA CAPTION DA _SCREEN
	_SCREEN.CAPTION = goAPLICATIVO.NOMEPROGRAMA + ' - ' + goAPLICATIVO.SISTEMA + ' - Usuário: '+ goCONEXAO.USERNAME
	
	IF GOAPLICATIVO.FLAT = 0
		goDESKTOP.CAPTION = 'Raiz - Usuário:'+goCONEXAO.USERNAME
		IF goCONEXAO.FK_USUARIOPERFIL<>goCONEXAO.FK_USUARIO
			_SCREEN.CAPTION = _SCREEN.CAPTION + '(Simulando:'+ALLTRIM(goCONEXAO.USERNAMEPERFIL)+')'
		ENDIF
	ELSE
		*#FLAT - QUANDO FOR FLAT REMOVE A TITLE BAR E O BORDERSTYLE
		goDESKTOP.TitleBar 		= 0
		goDESKTOP.BorderStyle 	= 0
		goDESKTOP.WindowState	= 2
		
		IF goCONEXAO.FK_USUARIOPERFIL<>goCONEXAO.FK_USUARIO
			_SCREEN.CAPTION = _SCREEN.CAPTION + '(Simulando:'+ALLTRIM(goCONEXAO.USERNAMEPERFIL)+')'
		ENDIF
	ENDIF
	
	IF USED('TMPSYS')
		USE IN TMPSYS
	ENDIF

	IF NOT EMPTY(goAPLICATIVO.JOB_NAME)
		* MODO SLAVE (SYSTEM TRAY)
*		goAPLICATIVO.ADDOBJECT( 'myJOBSYSTRAY', 'MEUJOBSYSTRAY' )
		goAPLICATIVO.mySYSTRAY.TipText = 'Volpe em modo slave (JOB='+goAPLICATIVO.JOB_NAME+')'
		goAPLICATIVO.mySYSTRAY.ADDICONTOSYSTRAY()
		goDESKTOP.HIDE()
		_SCREEN.Hide()

*!*			TRY 
*!*				goDESKTOP.AddObject('oleMINIMIZAR','MEUOLETRAY')
*!*			CATCH
*!*			FINALLY
*!*			ENDTRY
*!*			IF TYPE('goDESKTOP.oleMINIMIZAR') <> 'O'
*!*				=MESSAGEBOX('Erro para iniciar bandeja (SYSTRAY)!',0+16+4096,'AVISO',5000)
*!*				CLEAR EVENTS
*!*			ENDIF
*!*			goDESKTOP.oleMINIMIZAR.IconSource	= 'LOGO.ICO'
*!*			goDESKTOP.oleMINIMIZAR.IconTip		= 
*!*			goDESKTOP.oleMINIMIZAR.ShowIcon()

	ENDIF

RETURN

PROC SUPERGRADE
***************
LPARAMETERS tcNOMEVAR
	IF TYPE('tcNOMEVAR') <> 'C'
		RETURN
	ENDIF
	IF TYPE(tcNOMEVAR) = 'O'
		RELEASE &tcNOMEVAR
	ENDIF
	PUBLIC &tcNOMEVAR AS Form
	&tcNOMEVAR = CREATEOBJECT("SUPERFORMGRADE",tcNOMEVAR)
RETURN

* ROTINAS GENERICAS
FUNC VDIREITOS
**************
LPARAMETERS tcOBJETO, tnMENS, tcTIPO, tcFORM
* VERIFICA SE A ACÇÃO DESEJADA É PERMITIDA NO MOMENTO
* tcOBJETO 		-> NOME DO OBJETO A SER VERIFICADO O DIREITO
* tnMENS		-> 0 - NÃO MOSTRA MSG / 1 - MOSTRA MSG
* tcTIPO		-> TIPO DE VERIFICACAO ('O' - FORMS E PRG / 'I' - IMPRESSÕES / 'E' - EXPORTAÇÃO DE DADOS
* tcFORM		-> NOME DO FORMULARIO QUE SE ENCONTRA O RELATORIO (PARAMETRO UTILIZADO SOMENTE NA OPÇÃO PARA IMPRESSÃO)
	IF 	EMPTY(tcOBJETO)
		RETURN(.T.)
	ENDIF
	IF TYPE('tnMENS')<>'N'
		tnMENS = 0
	ENDIF
	IF TYPE('tcTIPO') <> 'C'
		tcTIPO	= 'O'
	ENDIF
	IF TYPE('tcFORM') <> 'C'
		tcFORM = ''
	ENDIF

	tcOBJETO	= UPPER(ALLTRIM(tcOBJETO))
	LOCAL lnPK_ID AS Integer
	LOCAL lcMENS, lcCOMANDO, lcGRUPO, lcGRUPOS, lcSUPERVISOR AS String

	lcSUPERVISOR = IIF(goCONEXAO.TAMANHOGRUPO=1,'S','SSS')

	DO CASE
		CASE tcTIPO = 'O'
			***********************************************************
			* OBJETOS (FORM'S E PRG'S)
			***********************************************************
			IF LEFT(tcOBJETO,7) = 'SYSTEM_' OR LEFT(tcOBJETO,4) = 'SYS_'
				* OBJETOS DO SISTEMA
				RETURN(.T.)
			ENDIF
			IF NOT '#'+tcOBJETO+'#' $ goCONEXAO.DIREITOS
				
				IF lcSUPERVISOR $ goCONEXAO.GRUPO AND goAPLICATIVO.TESTE AND tnMENS>0
					TEXT TO lcMENS NOSHOW PRETEXT 3
						ACESSO NEGADO!

						Como você é um supervisor em uma área de desenvolvimento,
						é possível cadastrar este módulo no sistema.
						Módulo: [[MODULO]]
						
						Deseja cadastrar este módulo agora?
						
					ENDTEXT
					lcMENS	= STRTRAN( lcMENS, '[[MODULO]]', tcOBJETO )
					IF SIMOUNAO( lcMENS, 'MÓDULO NÃO CADASTRADO', 2 )
						* COMO É SUPERVISOR DO SISTEMA E ESTA NA ÁREA DE TESTE, PODE INCLUIR RAPIDAMENTE O MÓDULO
						DO FORM SYSTEM_INCLUIRMODULO WITH 0, '', tcOBJETO TO lnPK_ID
						goCONEXAO.MONTADIREITOS()
						IF '#'+tcOBJETO+'#' $ goCONEXAO.DIREITOS
							RETURN(.T.)
						ENDIF
					ENDIF
				ENDIF
				IF tnMENS>0
					lcMENS = 'Acesso negado! Você não tem permissão para efetuar esta operação, '+goCONEXAO.USERNAME+'.'
					* VERIFICA SE ESTA SIMULANDO OUTRO USUÁRIO E EXIBE NOME DO USUÁRIO SIMULADO
					IF goCONEXAO.FK_USUARIOPERFIL <> goCONEXAO.FK_USUARIO
						lcMENS = lcMENS + ' (Simulando usuário: ' + ALLTRIM(goCONEXAO.USERNAMEPERFIL) + ').'
					ENDIF 
					DO MENS WITH lcMENS
				ENDIF
				RETURN(.F.)
			ENDIF

		CASE tcTIPO = 'I'
			***********************************************************
			* FORMULÁRIOS DE IMPRESSÃO (REPORT'S)
			***********************************************************
			IF lcSUPERVISOR $ goCONEXAO.GRUPO && NÃO PRECISA VERIFICAR SUPERVISOR
				RETURN(.T.)
			ELSE
				* CASO SEJA UM RELATORIO GERAL
				IF tcOBJETO = 'GERAL' AND NOT '_' $ tcOBJETO
					tcOBJETO = 'GERAL'
				ENDIF
				 
				TEXT TO lcCOMANDO NOSHOW PRETEXT 7
					SELECT
						IMP.PK_ID,
						IMP.DS_DIREITOS
					FROM
						TS_IMPRESSOES IMP
					WHERE  
						IMP.DS_REPORT = [[REPORT]]
					    AND IMP.DS_FORM = [[FORM]]
				ENDTEXT
				lcCOMANDO	= STRTRAN( lcCOMANDO, '[[REPORT]]', XX(tcOBJETO) )
				lcCOMANDO	= STRTRAN( lcCOMANDO, '[[FORM]]', XX(tcFORM) )
				=PESQUISASQL(lcCOMANDO,'TMPSYSDIRIMP')
				
				SELE TMPSYSDIRIMP
				GO TOP
				
				IF VERIFGRUPOS(goCONEXAO.GRUPO,TMPSYSDIRIMP.DS_DIREITOS)
					RETURN(.T.)
				ENDIF
			ENDIF 
		
			RETURN(.F.)

		CASE tcTIPO = 'E'
			***********************************************************
			* EXPORTAÇÃO DE DADOS
			***********************************************************
			IF lcSUPERVISOR $ goCONEXAO.GRUPO && NÃO PRECISA VERIFICAR SUPERVISOR
				RETURN(.T.)
			ELSE 
				IF NOT '#'+tcOBJETO+'#' $ goCONEXAO.DIREITOS_EXPORTACAO
					IF tnMENS>0
						DO MENS WITH 'Acesso negado! Você não tem permissão para efetuar esta operação, '+goCONEXAO.USERNAME+'.'
					ENDIF
					RETURN(.F.)
				ENDIF
			ENDIF
	ENDCASE
RETURN(.T.)

PROC CARGASISTEMA
*****************
*!*		USE (goAPLICATIVO.ARQSISTEMA) IN 0 ALIAS SISTEMA NOUPDATE
*!*		SELE SISTEMA
*!*		goAPLICATIVO.EMPRESA		= ALLTRIM(SISTEMA.EMPRESA)
*!*		goAPLICATIVO.NOMEPROGRAMA	= ALLTRIM(SISTEMA.PROGRAMA)
*!*		IF TYPE('SISTEMA.OUTROS') = 'C'
*!*			IF 'NTLOGIN=ON' $ UPPER(SISTEMA.OUTROS)
*!*				goAPLICATIVO.NTLOGIN	= goAPLICATIVO.NTLOGIN + 1
*!*			ENDIF
*!*		ENDIF
*!*		USE IN SISTEMA

	goAPLICATIVO.NOMEPROGRAMA	= 'Volpe'
	goAPLICATIVO.SISTEMA		= 'Sistema ERP'

	_SCREEN.Caption				= goAPLICATIVO.NOMEPROGRAMA + ' - ' + goAPLICATIVO.SISTEMA
RETURN

PROC ROTERRO
************
PARAMETERS tnMYERRO, tcMYMESS, tcMYPROG, tnMYLINH

	LOCAL lcNAMEFORM, lcERROJOB, lcERRORFILE, lcFILENAME AS String
	STORE '' TO lcNAMEFORM, lcERROJOB, lcERRORFILE, lcFILENAME
		
	* ENCERRA TRANSAÇÃO COM BANCO DE DADOS EM QUALQUE HIPOTESE DE ERRO
	IF TYPE('goCONEXAO') = 'O'
		IF goCONEXAO.OPENTRANSACTION = 1
			goCONEXAO.ENDTRANSACTION(-1)
		ENDIF
	ENDIF
	
	* VOLTANDO VARIÁVEIS DE EXECUÇÃO PARA DEFAULT
	IF TYPE('goAPLICATIVO.DESKTOP_STILLRUN') = 'L'
		goAPLICATIVO.DESKTOP_STILLRUN 	= .F.
	ENDIF
*!*		IF TYPE('goAPLICATIVO.F4_STILLRUN') = 'L'
*!*			goAPLICATIVO.F4_STILLRUN = .F.
*!*		ENDIF

	DO CASE

	CASE tnMYERRO = 1705
		DO MENS WITH 'Acesso nao permitido no momento! Arquivo bloqueado',1

	CASE tnMYERRO = 1958
		DO MENS WITH 'Erro para acessar impressora, verifique se a impressora esta disponível.',1
		
	OTHERWISE
		* TRATAMENTO PARA CAMINHO DO ARQUIVO NA MENSAGEM DE ERRO
		IF tnMYERRO = 1104 AND ( 'ERROR READING FILE' $ UPPER(tcMYMESS) )
			lcFILENAME = JUSTFNAME(STREXTRACT(tcMYMESS,' ','', OCCURS(' ',tcMYMESS)))
			tcMYMESS = 'Error reading file ' + lcFILENAME
		ENDIF
		
		LOCAL lcERRO AS STRING
		TEXT TO lcERRO NOSHOW PRETEXT 7
			Ocorreu uma falha no seu aplicativo e este terá que ser encerrado.
			Reporte o erro e entre em contato com o suporte técnico do seu software.
		ENDTEXT
		lcERRO = lcERRO +CHR(13)+CHR(10)+;
				 'ERRO: '+ALLTRIM(STR(tnMYERRO))+'='+tcMYMESS+CHR(13)+CHR(10)+;
				 'LINHA: ' + ALLTRIM(STR(tnMYLINH))+CHR(13)+CHR(10)+;
				 'ROTINA: '+ tcMYPROG
		
		LOCAL loFORM AS Object
		
		IF TYPE('_SCREEN.ActiveForm') = 'O'
			lcNAMEFORM = SYS(1271,_SCREEN.ActiveForm)
			loFORM = _SCREEN.ActiveForm
		ENDIF

		* SE É JOB GRAVA ERRO EM ARQUIVO TEXTO
		IF 'JOB=' $ goAPLICATIVO.PARAMETROEXE
			TEXT TO lcERROJOB NOSHOW PRETEXT 7
				##################################################
				DATA/HORA: [[DATETIME]]
				[[ERROMENS]]
				
			ENDTEXT
			lcERROJOB = STRTRAN(lcERROJOB,'[[DATETIME]]',TTOC(DATETIME()))
			lcERROJOB = STRTRAN(lcERROJOB,'[[ERROMENS]]',lcERRO)
			lcERROJOB = lcERROJOB + CHR(13) + CHR(13)
			lcERRORFILE = goAPLICATIVO.PATHUSERS + 'JOB_ERR.txt'
			TRY 
				=STRTOFILE(lcERROJOB, lcERRORFILE, 1)
			CATCH
			ENDTRY
		ENDIF
		
		* DATASESSIONID ATUAL
		PRIVATE pnDATASESSIONID AS INTEGER
		pnDATASESSIONID = SET('datasession')		
				
		* CHAMA FORMULÁRIO DE ERRO
		DO FORM SYSTEM_ERROMENS WITH lcERRO, ALIAS(), lcNAMEFORM, loFORM

		WAIT CLEAR
		
		* FINALIZAÇÕES FORÇADAS DO APLICATIVO TODO
		IF UPPER(tcMYPROG)=='ENCERRAR'
			CANCEL
		ENDIF
		IF UPPER(tcMYPROG)=='MENURAIZ'
			CANCEL
		ENDIF
		IF TYPE('goCONEXAO.FK_USUARIO')<>'N' 
			CANCEL
		ENDIF
		IF goCONEXAO.FK_USUARIO=0
			CANCEL
		ENDIF
		
		* LIMPA DADOS DO ULTIMO ERRO DE COMANDO SQL
		goCONEXAO.LASTERRORSQL = ''
		
		* FINALIZAR SOMENTE O MODULO COM ERRO
		IF TYPE('_SCREEN.ACTIVEFORM')='O'
			_SCREEN.ActiveForm.RELEASE()
			RETURN TO MASTER
		ENDIF
	ENDCASE
	CANCEL
RETURN


PROC ESPERANDO
**************
LPARAMETER tcMESS AS String
	WAIT WINDOW tcMESS NOWAIT NOCLEAR
	
*!*		IF TYPE('_screen.osTATUSBAR')='O'
*!*			_screen.osTATUSBAR.paNELMESSAGE.ctlcaption=tcMESS
*!*			_screen.osTATUSBAR.proGRESSBAR.ctlmarquee=.t.
*!*			_screen.osTATUSBAR.proGRESSBAR.ctlvisible=.t.
*!*		ENDIF
RETURN

PROC FIMESPERANDO
*****************
	WAIT CLEAR
	IF TYPE('_SCREEN.oSTATUSBAR')='O'
		_SCREEN.oSTATUSBAR.ctlMessage=''
		_SCREEN.oSTATUSBAR.PANELMESSAGE.CTLICON = ''
		_SCREEN.oSTATUSBAR.PROGRESSBAR.ctlVIsible=.F.
		_SCREEN.oSTATUSBAR.PROGRESSBAR.ctlMArquee=.F.
	ENDIF
RETURN

PROC MENS
*********
LPARAMETERS tcMENSAGEM,tnERRO
* MENSAGEM AO USUARIO, SE TNERRO=1 A MENSAGEM É MAIS GRAVE.
	IF TYPE('tnERRO')<>'N'
		tnERRO = 0
	ENDIF
	tnERRO = IIF(tnERRO>0,48,64)
	IF EMPTY( goAPLICATIVO.JOB_NAME )
		=MESSAGEBOX(tcMENSAGEM,'AVISO',tnERRO)
	ENDIF
RETURN

PROC SIMOUNAO
*************
LPARAMETERS tcPERGUNTA, tcTITULO, tnDEFAULT
	LOCAL lnBOTAO AS Number
	IF VARTYPE(tnDEFAULT) <> 'N'
		tnDEFAULT = 0
	ENDIF
	IF tnDEFAULT = 1
		tnBOTAO = 0
	ELSE
		tnBOTAO = 256
	ENDIF
	IF MESSAGEBOX( tcPERGUNTA, tcTITULO, 32+4+tnBOTAO )=6
		RETURN(.T.)
	ENDIF
RETURN(.F.)

PROC EMP2STATUSBAR
******************
* EXIBE LEGENDA DE FILTRO DE EMPRESA NA STATUSBAR
	IF TYPE('_SCREEN.oSTATUSBAR')<>'O'
		RETURN
	ENDIF

	LOCAL lcSTATUS AS String
	lcSTATUS = STREXTRACT(goAPLICATIVO.EMPFILTRO,'(',')')
	lcSTATUS = STRTRAN(lcSTATUS,' ','')
	lcSTATUS = STRTRAN(lcSTATUS,"'",'')
	IF lcSTATUS = 'ZZZZ'
		lcSTATUS='(TODAS)'
	ENDIF
	_SCREEN.oSTATUSBAR.PAnel3.ctlCAption=lcSTATUS
RETURN

FUNC TIRANONUM
**************
* PEGA APENAS OS NUMEROS DE UMA STRING
LPARAMETERS lcCAMPO
	
	* TRATAMENTO DE NULO
	IF ISNULL(lcCAMPO)
		lcCAMPO = ''
	ENDIF

	LOCAL lcSONUM AS String
	LOCAL lnI AS INTEGER
	lcSONUM = ''

	FOR lnI = 1 TO LEN(lcCAMPO)
		lcALGA = SUBS(lcCAMPO,lnI,1)
		IF lcALGA $ '0987654321'
			lcSONUM = lcSONUM + lcALGA
		ENDIF
	ENDFOR
	
RETURN(lcSONUM)

FUNC TEMPFILE
*************
LPARAMETERS tcEXTENSAO
	IF TYPE('tcEXTENSAO')<>'C'
		tcEXTENSAO = 'TMP'
	ENDIF
	LOCAL lcCPOOUT AS String
	lcCPOOUT = goAPLICATIVO.PATHTEMP+SYS(2015)+'.'+tcEXTENSAO
RETURN(lcCPOOUT)

PROC CRIATEMPDIR
****************
* CRIA PASTA SEPARADA DE ARQ.TEMPORARIOS
	LOCAL		lcPASTA, lcPASTAVERIF AS STRING
	STORE '' TO lcPASTA, lcPASTAVERIF
	lcPASTA = goAPLICATIVO.PATHTEMP
	IF ADIR(laDIR,lcPASTA,'DHS')=0
		lcPASTA = '\'+lcPASTA+'\'
		TRY
			FOR lnXI = 1 TO OCCURS('\',lcPASTA)-1
				lcPASTAVERIF = ADDBS(lcPASTAVERIF + STREXTRACT(lcPASTA,'\','\',lnXI))
				IF NOT DIRECTORY(lcPASTAVERIF,1)
					MD (lcPASTAVERIF)
				ENDIF
			ENDFOR
		CATCH
			DO MENS WITH 'Erro de acesso: Falha para gravar/criar em pasta de arquivos temporários.'+CHR(13)+CHR(10)+;
			'Verifique seus priviégios para gravar dados neste computador (sem acesso na pasta de temporários)'+CHR(13)+CHR(10)+;
			lcPASTAVERIF
			CLOSE ALL
			CANCEL
		ENDTRY
	ENDIF
RETURN

PROC KILLTEMPFILE
*****************
* LIMPA PASTA DE ARQUIVOS TEMPORARIOS
	LOCAL lnFILES AS Integer
	lnFILES = ADIR(laKILL, goAPLICATIVO.PATHTEMP+'*.*')
	LOCAL lnI AS INTEGER, lcFILE AS STRING
	FOR lnI = 1 TO lnFILES
		lcFILE = goAPLICATIVO.PATHTEMP+ALLTRIM(laKILL[lnI,1])
		IF FILE(lcFILE)
			TRY 
				DELETE FILE (lcFILE)
			CATCH
			ENDTRY
		ENDIF
	ENDFOR
RETURN

FUNC SBDVEM
***********
*DECRIPTA SENHA DE CONEXÃO
PARAMETERS tcHIDEN
	tcHIDEN = ALLTRIM(tcHIDEN)
	LOCAL lcSENHA, lcSEMENTE, lcLETRA AS String
	lcSENHA = ''
	lcSEMENTE = SUBSTR(tcHIDEN,2,1)
	LOCAL X, Y AS INTEGER

	FOR X = LEN(tcHIDEN) TO 3 STEP -3
		Y = VAL( SUBSTR(tcHIDEN,X-2,3) ) -ASC(lcSEMENTE)
		lcLETRA = ''
		IF Y>27 AND Y<256
			lcLETRA = CHR(Y)
		ENDIF
		lcSENHA = lcSENHA + lcLETRA
	ENDFOR
RETURN(lcSENHA)

FUNC SBDVAI
***********
* ENCRIPTA SENHA DE BANCO DE DADOS
PARAMETERS tcSENHA
	tcSENHA = ALLTRIM(tcSENHA)
	LOCAL lcHIDEN, lcSEMENTE, lcLETRA AS String
	lcHIDEN = ''
	LOCAL X, Y AS INTEGER
	X = INT(RAND()*25)
	Y = MOD(ASC(tcSENHA+' '),10)
	lcSEMENTE = CHR(X+65)
	lcHIDEN = STR(Y,1)+lcSEMENTE
	FOR X = LEN(tcSENHA) TO 1 STEP -1
		lcLETRA = SUBSTR(tcSENHA,X,1)
		Y = ASC(lcLETRA)+ASC(lcSEMENTE)
		lcLETRA = PADL( ALLTRIM(STR(Y)) ,3,'0')
		lcHIDEN = lcHIDEN + lcLETRA
	ENDFOR
RETURN(lcHIDEN)

PROC GUIAUSUARIO
****************
	LOCAL lcMANUAL AS STRING
	lcMANUAL = 'MANUAL\MANUAL.DOC'
	IF NOT FILE(lcMANUAL)
		DO MENS WITH 'Documento (manual do sistema) não foi encontrado'
	ELSE
		lcCOMANDOM = '/N2 CMD /C START '+lcMANUAL
		RUN &lcCOMANDOM
	ENDIF
RETURN

PROC PROGTRAVADO
****************
	LOCAL lcTRAVADO1, lcTRAVADO2 AS String, lnALCA AS Integer
	lcTRAVADO1 = 'Acesso bloqueado temporariamente - Sistema em manutenção'+CHR(13)
	lcTRAVADO2 = ''
	TRY
		lcTRAVADO2 = FILETOSTR(gOAPLICATIVO.TRAVAARQ)
	CATCH
	ENDTRY
	=MESSAGEBOX(lcTRAVADO1+lcTRAVADO2,48,'Acesso bloqueado',8000)
RETURN

* ROTINAS DE CONEXÃO E VALIDAÇÃO DE USUÁRIO
FUNC CONECTASQL
***************
	LOCAL llCONECTADO,llRETURN, llDESCONECTOU AS LOGICAL
	STORE .F. TO llCONECTADO,llRETURN
	LOCAL lcSUPERVISOR,lcSALVARPASTA,lcCOMANDOEXPIRACAO AS String
	STORE '' TO lcCOMANDOEXPIRACAO
	
	llDESCONECTOU = .F.
	
	LOCAL lnSENEXP AS Integer 
	STORE 0 TO lnSENEXP 
	
	LOCAL ldDT_EXPIRACAO AS Date 
	STORE {} TO ldDT_EXPIRACAO 
	IF ACESSASQL()
		* SIGLA DE SUPERVISOR
		lcSUPERVISOR = IIF(goCONEXAO.TAMANHOGRUPO=1,'S','SSS')
		* CARREGANDO ZWS
		goAPLICATIVO.CARGAZWS()
		
		goAPLICATIVO.FLAT = RETORNASET('SISTEMA.FLAT','N',0)
		
		* FLAG PARA VERIFICAÇÃO SE A LGPD ESTA ATIVA NO SISTEMA
		goAPLICATIVO.LGPD = RETORNASET('LGPD.HABILITAR', 'N', 0)
		
		IF VALIDAUSER()
			llCONECTADO = .T.
			* USUARIO CONECTADO
			goCONEXAO.GRUPO			= ALLTRIM(TMPUSU.FK_GRUPO)
			goCONEXAO.FK_USUARIO	= TMPUSU.PK_ID
			
			* VALIDAÇÃO DA SENHA DO USUÁRIO EM RELAÇÃO AO CADASTRO DOS PARAMETROS
			* NÃO VALIDA COMPLEXIDADE DE SENHA QUANDO O SISTEMA ESTÁ EM MODO SLAVE (JOB)
			IF NOT VECOMPLEXIDADE(goCONEXAO.SENHA) AND EMPTY(goAPLICATIVO.JOB_NAME)
				DO FORM SYSTEM_SENHACOMPLEXIDADE TO llRETURN
				IF NOT llRETURN
					goCONEXAO.DESCONECTAR()
					llDESCONECTOU = .T.
				ENDIF
			ENDIF
			
			* SE JÁ DESCONECTOU ANTES NEM OLHA PARÂMETROS DE EXPIRAÇÃO
			IF NOT llDESCONECTOU
				* VALIDA SE A SENHA DO USUARIO EXPIROU
				* SE ZERO A SENHA NÃO EXPIRA NUNCA.
				lnSENEXP 	= RETORNASET('SENHA.EXPIRARDIAS', 'N', 1)
				IF lnSENEXP > 0
				
					* BUSCA DATA DA SENHA ATUALIZADA DIRETO NO BANCO PARA EVITAR CONFLITO COM A VECOMPLEXIDADE
					TEXT TO lcCOMANDOEXPIRACAO NOSHOW PRETEXT 7
						SELECT 
							* 
						FROM
							TS_USUARIOS
						WHERE 
							PK_ID = [[PK_ID]]
					ENDTEXT
					lcCOMANDOEXPIRACAO = STRTRAN( lcCOMANDOEXPIRACAO, '[[PK_ID]]', XX(TMPUSU.PK_ID) )
					=PESQUISASQL(lcCOMANDOEXPIRACAO,'TMPUSUEXPIRACAO')
					
					SELE TMPUSUEXPIRACAO
					GO TOP
					
					IF NOT ISNULL(TMPUSUEXPIRACAO.DH_SENHA)
						ldDT_EXPIRACAO = TTOD(TMPUSUEXPIRACAO.DH_SENHA) + lnSENEXP 
					ELSE 
						ldDT_EXPIRACAO = TTOD(TMPUSUEXPIRACAO.DH_INCLUSAO) + lnSENEXP 
					ENDIF 
							
					IF ldDT_EXPIRACAO < DATE()
						DO FORM SYSTEM_SENHACOMPLEXIDADE WITH 'Atenção! Sua senha expirou, favor trocá-la.' TO llRETURN
						IF NOT llRETURN
							goCONEXAO.DESCONECTAR()
							llDESCONECTOU = .T.
						ENDIF
					ENDIF 	
				ENDIF 
			ENDIF
			
			* VALIDA BLOQUEI POR IP
			* CASO HABILITADO VALIDA SE O IP DO USUÁRIO É PERMITIDO
			IF EMPTY(goAPLICATIVO.JOB_NAME) AND NOT llDESCONECTOU
				IF NOT VERIFICARBLOQIP()
					goCONEXAO.DESCONECTAR()
					llDESCONECTOU = .T.
				ENDIF 
			ENDIF  
					
			* VALIDA SE NÃO ESTA NO MODO SLAVE
			* VALIDA SE O TERMO LGPD ESTÁ HABILITADO NO SISTEMA
			* VALIDA SE O TERMO ATUAL JÁ FOI ACEITO PELO USUÁRIO
			IF EMPTY(goAPLICATIVO.JOB_NAME) AND NOT llDESCONECTOU
				IF VETERMOLGPD()
					goCONEXAO.DESCONECTAR()
					llDESCONECTOU = .T.
				ENDIF 
			ENDIF  	
			
			IF NOT llDESCONECTOU
				goCONEXAO.SUPERUSUARIO	= IIF(lcSUPERVISOR $ TMPUSU.FK_GRUPO,1,0)
				goCONEXAO.DS_EMAIL		= ALLTRIM(TMPUSU.DS_EMAIL)
				* PERFIL DO USUÁRIO
				goCONEXAO.DEFINICOES		= TMPUSU.DS_PERFIL
				goCONEXAO.USERNAMEPERFIL	= goCONEXAO.USERNAME
				goCONEXAO.FK_USUARIOPERFIL	= goCONEXAO.FK_USUARIO
				* MARCANDO COMO CONECTADO E APLICANDO PERFIL
				goCONEXAO.APLICARPERFIL()
				
				* CARREGAR NOTIFICACOES
				IF UPPER(RETORNASET('SISTEMA.NOTIFICACOES','C',1)) == 'ON'
					IF CAMPOEXISTE('FK_NOTIFICASSUNTO','TMPUSU')
						goCONEXAO.ASSUNTOS = ALLTRIM(TMPUSU.FK_NOTIFICASSUNTO)
					ENDIF
				ENDIF
				
				* VERIFICA SE AO INVÉS DE ENVIAR EMAIL, SALVAR NA PASTA (APENAS MAPI)
				lcSALVARPASTA = UPPER(RETORNASET('EMAIL.SALVARPASTA','C(2)',1))
			
				IF lcSALVARPASTA = 'ON'
					* VERIFICA SE USUÁRIO PODE UTILIZAR FUNCIONALIDADE DE SALVAR NA PASTA.
					lcCOMANDO = 'SELECT * FROM TS_USUARIOS WHERE PK_ID = '+XX(goCONEXAO.FK_USUARIO)
					=PESQUISASQL(lcCOMANDO,'TMPUSER')
				
					goCONEXAO.USERSALVARMAIL = NVL(TMPUSER.TG_SALVARMAIL,0)
				ELSE
					goCONEXAO.USERSALVARMAIL = 0
				ENDIF
				
				IF USED('TMPUSER')
					USE IN TMPUSER
				ENDIF
				
				DO USUCONECTADO
			ENDIF 
		ELSE
			IF NOT NEWUSER()
				goCONEXAO.DESCONECTAR()
			ENDIF
		ENDIF
	ENDIF
	IF USED('TMPUSU')
		USE IN TMPUSU
	ENDIF
	IF USED('TMPUSUEXPIRACAO')
		USE IN TMPUSUEXPIRACAO
	ENDIF
RETURN(llCONECTADO)

PROC USUCONECTADO
*****************
* REQUISICAO SIMPLES, APROVEITA P/ MARCAR QUE USUARIO ESTA CONECTADO
* 0=DESCONECTADO, 1=CONECTADO
LPARAMETERS tnATIVO
	IF TYPE('tnATIVO')<>'N'
		tnATIVO=1
	ENDIF
	goCONEXAO.ULTCONECTA = DATETIME()
	LOCAL lcCOMANDO, lcCOMPUTER, lcDOMINIOUSU AS String
	IF tnATIVO=1
		lcHOJE = D2SQL(DATE(),'HOJE')
		lcCOMPUTER	= XX( GETENV("COMPUTERNAME") )
		lcLOGONREDE	= XX( GETENV("USERNAME") )
	ELSE
		lcHOJE = 'NULL'
		lcCOMPUTER	= XX(' ')
		lcLOGONREDE	= XX(' ')
	ENDIF
	LOCAL lcTABELA AS String
	IF RETORNASET('USUARIOS.EXTERNO','C',1)='ON'
		lcTABELA = 'TS_USUVOLPE'
	ELSE
		lcTABELA = 'TS_USUARIOS'
	ENDIF
	lcCOMANDO = 'UPDATE ' + lcTABELA + ' SET'+;
				' DH_CONECTADO='	+lcHOJE+;
				' ,DS_MAQUINA='		+lcCOMPUTER+;
				' ,DS_LOGONREDE='	+LcLOGONREDE+;
				' WHERE PK_ID='+XX(goCONEXAO.FK_USUARIO)
	=EXECUTASQL(lcCOMANDO)
RETURN

FUNC ACESSASQL
**************
	=goCONEXAO.DESCONECTAR()
	goCONEXAO.NOMECONEXAO	= CONFIG.NOME
	goCONEXAO.DRIVER		= ALLTRIM(UPPER(CONFIG.DRIVER))
		
	* DEFINE BANCO DE DADOS UTILZADO NO SISTEMA
	DO CASE
		CASE 'ORACLE' $ goCONEXAO.DRIVER
			goCONEXAO.BANCO	= 'ORA'
		CASE 'POSTGRE' $ goCONEXAO.DRIVER
			goCONEXAO.BANCO	= 'POS'
		CASE 'FOXPRO' $ goCONEXAO.DRIVER
			goCONEXAO.BANCO	= 'DBC'
		CASE 'MYSQL' $ goCONEXAO.DRIVER
			goCONEXAO.BANCO	= 'MYS'
		OTHERWISE
			goCONEXAO.BANCO	= 'SQL'
	ENDCASE
	
	* SALVA CONFIGURAÇÕES DE SERVIDOR
	goCONEXAO.SERVIDORBD	= ALLTRIM(UPPER(CONFIG.SERVER))
	* PORTA PODE SER DECLARADA DE DUAS FORMAS:
	* PORT=9999;
	* OU
	* SERVIDOR,9999
	goCONEXAO.PORTABD		= INT(VAL(STREXTRACT(ALLTRIM(UPPER(CONFIG.OUTROS)),'PORT=',';')))
	IF EMPTY(goCONEXAO.PORTABD)
		goCONEXAO.PORTABD	= INT(VAL(STREXTRACT(ALLTRIM(UPPER(CONFIG.SERVER)),',','')))
	ENDIF
	* SE PORTA NÃO FOI PREENCHIDA, UTILIZA A PADRÃO DO BANCO
	IF EMPTY(goCONEXAO.PORTABD)
		LOCAL lcBD AS STRING
		lcBD = goCONEXAO.BANCO
		goCONEXAO.PORTABD	= ICASE(lcBD='SQL',1433,lcBD='ORA',1521,lcBD='POS',5432,lcBD='MYS',3306,0)
	ENDIF
		
	lcCONEXAO = MONTACONN()
	IF EMPTY(lcCONEXAO)
		DO MENS WITH 'Erro para acessar base de dados: (Configuração incompleta)'
		RETURN
	ENDIF

	DO ESPERANDO WITH 'Conectando ao servidor de dados...'
	goCONEXAO.ALCA = SQLSTRINGCONNECT(lcCONEXAO)
	WAIT CLEAR
	IF goCONEXAO.ALCA<0
		*DO MENS WITH 'Erro para acessar base de dados: '+ALLTRIM(CONFIG.NOME)
		* TRATAMENTO DE ERRO PARA CONEXÃO COM BASE DE DADOS
		DO ERROBD
		RETURN(.F.)
	ENDIF
	* GARANTIR PALAVRA-CHAVE UNICA
	IF 'SQL NATIVE CLIENT' $ UPPER(goCONEXAO.DRIVER)
		goCONEXAO.DRIVER = 'SQL SERVER'
	ENDIF
	* VERIFICA TAMANHO CONFIGURADO PARA GRUPOS - CHAR(1) OU CHAR(3)
	DO LERCOLUMNS WITH 'TABELA','TS_GRUPOS', 'UNIVERSO=VT;'
	SELE TMPCOLUMNS 
	LOCATE FOR ALLTRIM(UPPER(DS_CAMPO)) = 'PK_ID' 
	IF FOUND()
		IF ALLTRIM(STR(TMPCOLUMNS.VL_TAMANHO)) $ '13'
			goCONEXAO.TAMANHOGRUPO = TMPCOLUMNS.VL_TAMANHO
		ELSE
			DO MENS WITH 'Tamanho de grupo de usuários não está configurado corretamente!'
			DO ENCERRAR
		ENDIF 
	ENDIF	
RETURN(.T.)

PROC ERROBD
***********
	* CHAMA FORM DE DIAGNÓSTICO DE REDE
	=CHAMAFORM('SYSTEM_AVISOERROREDE')
ENDPROC

FUNC VALIDAUSER
***************
LPARAMETERS tcUSERNAME, tcSENHA

	IF TYPE('tcUSERNAME')<>'C'
		tcUSERNAME = goCONEXAO.USERNAME
	ENDIF
	IF TYPE('tcSENHA')<>'C'
		tcSENHA = goCONEXAO.SENHA
	ENDIF

	LOCAL lcCOMANDO, lcCONDAUX, lcAUX, lcAUX_DATA, lcAUXHORA,lcDOMINIO AS String
	LOCAL llOKLOGIN AS Logical
	STORE '' TO lcCOMANDO, lcCONDAUX, lcAUX, lcAUX_DATA, lcAUXHORA, lcDOMINIOSQL, lcDOMINIOPADRAO, lcDOMINIOUSU, lcLISTADOMINIOS
	STORE .F. TO llOKLOGIN
	
	LOCAL lnSENHATENTATIVAS AS Integer
	STORE 0 TO lnSENHATENTATIVAS
 
	* DOMINIO DE REDE PADRÃO(OPCIONAL)
	lcDOMINIOPADRAO = RETORNASET('DOMINIO.NAME','C',0)
	lcDOMINIO = lcDOMINIOPADRAO
	
	* VERIFICA SE FOI INFORMADO DOMÍNIO\USUÁRIO
	IF '\' $ tcUSERNAME
		lcDOMINIOUSU = SUBSTR(tcUSERNAME,1,AT('\',tcUSERNAME)-1)
		
		* SE INFORMOU DOMÍNIO NO LOGIN, NÃO CONSIDERA O PADRÃO
		IF NOT EMPTY(lcDOMINIOUSU)
			lcDOMINIO = lcDOMINIOUSU
		ENDIF
		
		* VALIDA SE NOME DE USUÁRIO FOI INFORMADO CORRETAMENTE
		tcUSERNAME = SUBSTR(tcUSERNAME,AT('\',tcUSERNAME)+1)
		IF EMPTY(tcUSERNAME)
			DO MENS WITH 'LOGIN NÃO INFORMADO.'
			RETURN(.F.)
		ENDIF
	ENDIF	
		
	* CARREGA LISTA DE DOMÍNIOS PERMITIDOS NO SISTEMA
	lcLISTADOMINIOS = RETORNASET('DOMINIO.LISTALOGIN','C',0)
	
	DO CASE
		CASE EMPTY(lcDOMINIO) AND NOT EMPTY(lcLISTADOMINIOS)
			DO MENS WITH	'LOGIN INVÁLIDO.' + CHR(13) + CHR(10) +;
							'Sistema habilitado para autenticação por domínio e não foi informado seu domínio de rede.' + CHR(13) +;
							'Ex: DOMINIO\LOGIN'
			RETURN(.F.)
			
		CASE NOT EMPTY(lcDOMINIOPADRAO) AND lcDOMINIOPADRAO == lcDOMINIO
			* OK, NADA A FAZER:
			* SOMENTE PARA EVITAR IMPACTOS EM CLIENTES QUE JÁ FAZIAM AUTENTICAÇÃO VIA DOMÍNIO,
			* O DOMÍNIO PADRÃO NÃO PRECISA ESTAR NA LISTA DE DOMÍNIOS PERMITIDOS
		
		CASE NOT EMPTY(lcDOMINIO) AND EMPTY(lcLISTADOMINIOS)
				DO MENS WITH	'DOMÍNIO INVÁLIDO.' + CHR(13) + CHR(10) +;
								'Sistema não permite autenticação no domínio de rede informado.'
				RETURN(.F.)
		
		* CONFERE SE DOMÍNIO INFORMADO ESTÁ NA LISTA DE PERMITIDOS
		CASE NOT EMPTY(lcDOMINIO) AND NOT EMPTY(lcLISTADOMINIOS)
			IF NOT ',' + lcDOMINIO + ',' $ ',' + lcLISTADOMINIOS + ','
				DO MENS WITH	'DOMÍNIO INVÁLIDO.' + CHR(13) + CHR(10) +;
								'Sistema não permite autenticação no domínio de rede informado.' + CHR(13) +;
								'Domínio = '+ALLTRIM(lcDOMINIO)
				RETURN(.F.)
			ENDIF
	ENDCASE
	
	IF NOT EMPTY(lcDOMINIO)
		* VALIDAR PRIMEIRO SE O USUÁRIO EXISTE NO SISTEMA
		TEXT TO lcCOMANDO NOSHOW TEXTMERGE PRETEXT 7
			SELECT
				DS_SENHA,
				FK_GRUPO,
				PK_ID,
				DS_PERFIL,
				DS_EMAIL
			FROM
				TS_USUARIOS
			WHERE
				DS_LOGIN = <<XX(tcUSERNAME)>>
				AND TG_INATIVO = 0
		ENDTEXT
		=PESQUISASQL(lcCOMANDO,'TMPUSU')

		IF RECCOUNT('TMPUSU')=0
			DO MENS WITH 'LOGIN INVÁLIDO. '+CHR(13)+CHR(13)+;
					'Confira os seus dados de login e tente novamente.'+CHR(13)+;
					'Seu login não está ativo no sistema.'
			RETURN(.F.)
		ENDIF

		* VALIDAR USUARIO E SENHA NO DOMINIO DE REDE
		IF NOT VALIDAAD(ALLTRIM(tcUSERNAME),ALLTRIM(tcSENHA),ALLTRIM(lcDOMINIO))
			DO MENS WITH 'LOGIN INVÁLIDO. '+CHR(13)+CHR(13)+;
					'Este sistema está associado a um domínio e o seu login precisa estar válido no seu servidor de rede.'+CHR(13)+;
					'Domínio = '+ALLTRIM(lcDOMINIO)
			RETURN(.F.)
		ENDIF
		
		* PEGA SOMENTE NOME DO USUÁRIO
		IF '\' $ goCONEXAO.USERNAME
			goCONEXAO.USERNAME = SUBSTR(goCONEXAO.USERNAME,AT('\',goCONEXAO.USERNAME)+1)
		ENDIF
		
		RETURN(.T.)
	ENDIF
	

	tcSENHA = UPPER(tcSENHA)

	
	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		SELECT
			*
		FROM
			TS_USUARIOS
		WHERE
			<<CONDAUX>>
			AND TG_INATIVO<1
	ENDTEXT

	LOCAL lcSENHA, lcSEMENTE, lcAUTENTICACAO, lcNEWAUTENTICACAO AS STRING

	IF EMPTY(goAPLICATIVO.JOB_NAME)
		* LOGIN NORMAL
		lcCONDAUX	= 'DS_LOGIN='+XX(tcUSERNAME)
		lcCOMANDO	= STRTRAN(lcCOMANDO,'<<CONDAUX>>',lcCONDAUX)
		=PESQUISASQL(lcCOMANDO,'TMPUSU')
		lcSEMENTE	= LEFT(TMPUSU.DS_SENHA,1)
		
		lcSENHA		= CRIPTAR(tcSENHA, lcSEMENTE)
		* CASO SEJA PARA AUTENTICAR O LOGIN => SENHA + GRUPOS
		IF goAPLICATIVO.AUTENTICALOGIN == 'ON'
			lcAUTENTICACAO = NVL(TMPUSU.DS_AUTENTICACAO,'')
		ENDIF
	ELSE
		* LOGIN EM MODO SLAVE
		TEXT TO lcAUX NOSHOW PRETEXT 7
			SELECT TOP 1
				TG_FECHARFIM,
				DH_INICIO,
				FK_USUARIO
			FROM
				TS_JOBS
			WHERE
				DS_SERVICO=<<JOB>>
				AND TG_INATIVO<1
		ENDTEXT
		lcAUX = STRTRAN(lcAUX,'<<JOB>>',XX(goAPLICATIVO.JOB_NAME))
		=PESQUISASQL(lcAUX,'TMPJOB')

		lcAUX_DATA	= TRANSFORM( DTOS( TTOD(TMPJOB.DH_INICIO) ),'@R 9999-99-99' )
		lcAUX_HORA	= 'T' + STRZERO(HOUR(TMPJOB.DH_INICIO),2)+':'+STRZERO(MINUTE(TMPJOB.DH_INICIO),2)+':00'

		goAPLICATIVO.JOB_PROEXEC	= CTOT(lcAUX_DATA + lcAUX_HORA)
		goAPLICATIVO.JOB_FECHARFIM	= TMPJOB.TG_FECHARFIM

		lcCONDAUX	= 'PK_ID='+XX(TMPJOB.FK_USUARIO)
		lcCOMANDO	= STRTRAN(lcCOMANDO,'<<CONDAUX>>',lcCONDAUX)
		=PESQUISASQL(lcCOMANDO,'TMPUSU')
		lcSENHA		= TMPUSU.DS_SENHA
		USE IN TMPJOB
	ENDIF

	lnSENHATENTATIVAS = 0

	* LOGIN DEFAULT
	IF RECCOUNT('TMPUSU')=0
		DO MENS WITH 'LOGIN INVÁLIDO. '+CHR(13)+CHR(13)+;
			'Usuário não encontrado/habilitado.' +CHR(13)+;
			'Entre em contato com o administrador do sistema.'
		llOKLOGIN = .F.
	ELSE
		
		lnSENHATENTATIVAS = RETORNASET('SENHA.TENTATIVAS','N',1)
		
		IF lnSENHATENTATIVAS > 0 AND NVL(TMPUSU.NR_TENTATIVAS_LOGIN,0) >= lnSENHATENTATIVAS
		
			DO MENS WITH 'LOGIN BLOQUEADO. '+CHR(13)+CHR(13)+;
					'Este usuário excedeu as tentativas de login inválidas.'+CHR(13)+;
					'Entre em contato com a administrador do sistema.' + CHR(13)+;
					'Máximo de tentativas inválidas: ' + ALLTRIM(TRANSFORM(lnSENHATENTATIVAS,'9999'))
					
			llOKLOGIN = .F.
			
		ELSE
		
			IF NOT(ALLTRIM(TMPUSU.DS_SENHA)==ALLTRIM(lcSENHA))
							
				* ATUALIZA NÚMERO DE TENTATIVAS DE LOGIN SEM SUCESSO
				IF lnSENHATENTATIVAS > 0
					lcUPDATE = 'UPDATE TS_USUARIOS SET NR_TENTATIVAS_LOGIN = ' + XX(NVL(TMPUSU.NR_TENTATIVAS_LOGIN,0)+1) + ' WHERE PK_ID = ' + XX(TMPUSU.PK_ID)
					=EXECUTASQL(lcUPDATE)
					
					DO MENS WITH 'SENHA INVÁLIDA. '+CHR(13)+CHR(13)+;
					'Confira os seus dados de login e senha e tente novamente.'+CHR(13)+;
					'obs: não há diferença em usar maiúsculas ou minúsculas.' + CHR(13)+;
					'Tentativas inválidas: ' + ALLTRIM(TRANSFORM(NVL(TMPUSU.NR_TENTATIVAS_LOGIN,0)+1)) + CHR(13)+;
					'Máximo de tentativas inválidas: ' + ALLTRIM(TRANSFORM(lnSENHATENTATIVAS,'9999'))
					
				ELSE
					DO MENS WITH 'LOGIN INVÁLIDO. '+CHR(13)+CHR(13)+;
					'Confira os seus dados de login e senha e tente novamente.'+CHR(13)+;
					'obs: não há diferença em usar maiúsculas ou minúsculas.'
				ENDIF
				
				llOKLOGIN = .F.
				
			ELSE
			
				* VERIFICA SE É PARA AUTENTICAR LOGIN
				IF goAPLICATIVO.AUTENTICALOGIN == 'ON'
					goAPLICATIVO.myZIP.Init()
					goAPLICATIVO.myZIP.OpenLib('VFPENCRYPTION.FLL')
					lcNEWAUTENTICACAO = STRCONV(goAPLICATIVO.myZIP.HASH(ALLTRIM(TMPUSU.DS_SENHA) + ALLTRIM(TMPUSU.FK_GRUPO)),13)
					IF !lcNEWAUTENTICACAO == lcAUTENTICACAO
						DO MENS WITH 'LOGIN NÃO AUTENTICADO.'+CHR(13)+CHR(13)+;
							'Seus dados de login não estão autenticados para utilização do sistema.'+CHR(13)+;
							'Entre em contato com o administrador do sistema.'
						llOKLOGIN = .F.
					ELSE
						llOKLOGIN = .T.	
					ENDIF
				ELSE
					llOKLOGIN = .T.
				ENDIF
				
			ENDIF
			
		ENDIF
		
	ENDIF
	
	* SE LOGIN FOI OK, ZERA NÚMERO DE TENTATIVAS DE LOGIN SEM SUCESSO
	IF lnSENHATENTATIVAS > 0 AND llOKLOGIN
		lcUPDATE = 'UPDATE TS_USUARIOS SET NR_TENTATIVAS_LOGIN = 0 WHERE PK_ID = ' + XX(TMPUSU.PK_ID)
		=EXECUTASQL(lcUPDATE)
	ENDIF
		
	
RETURN(llOKLOGIN)

FUNC VALIDAAD
*************
LPARAMETERS tcUSER, tcPASS, tcDOMINIO

	LOCAL llRET AS Logical
	LOCAL lcCOMANDO AS String
	LOCAL lnTOKEN AS Integer
	llRET = .F.
	lnTOKEN = 0
	
	* VALIDAÇÃO PARA PERMITIR USUÁRIO PWI EM AMBIENTE DE TESTE
	IF GOAPLICATIVO.TESTE AND tcUSER == 'PWI' 
		RETURN(.T.)
	ENDIF
	
	* VALIDANDO USUARIO POR API
	DECLARE integer GetLastError IN kernel32 
	DECLARE integer CloseHandle IN kernel32 integer hObject 
	DECLARE integer LogonUser IN advapi32 string lpzUser, string lpzDomain, string lpzPass, integer dwLogonType, integer dwLogonProvider, integer @phToken 

	IF LogonUser(tcUSER,ALLTRIM(tcDOMINIO),tcPASS,2,0,@lnTOKEN) = 0 
		llRET=.F.
	ELSE 
	  llRET=.T.
	  = CloseHandle(lnTOKEN) 
	ENDIF 

RETURN llRET

PROC MONTACONN
**************
LPARAMETERS toCFG
* RETORNA A STRING DE CONEXÃO MONTADA E PRONTA
	IF TYPE('toCFG')<>'O'
		* DEVERIA RECEBER OBJETO TIPO "EMPTY" DO REGISTRO DE CONEXÃO
		* SENÃO MONTA O OBJETO
		SELE CONFIG
		SCATTER NAME toCFG
		toCFG.PWD = SBDVEM(toCFG.PWD)
	ENDIF
	IF EMPTY(toCFG.DRIVER)
		RETURN('')
	ENDIF
	
	LOCAL lcDRIVER AS String, lcCONN AS STRING
	lcDRIVER = ALLTRIM(toCFG.DRIVER)
	IF 'DSN' $ UPPER(lcDRIVER)
		* STRING USANDO ARQUIVO DSN
		lcCONN = 'FILEDSN='+FULLPATH('')+ALLTRIM(toCFG.DBNAME)+';'+;
				'UID='   +ALLTRIM(toCFG.USER)+';'+;
				'PWD='   +ALLTRIM(toCFG.PWD)
	ELSE
		* STRING NO PADRÃO NORMAL
		lcCONN = 'DRIVER='+lcDRIVER
		IF NOT EMPTY(toCFG.SERVER)
			lcCONN = lcCONN+';SERVER='+ALLTRIM(toCFG.SERVER)
		ENDIF
		IF NOT EMPTY(toCFG.USER)
			lcCONN = lcCONN+';UID='   +ALLTRIM(toCFG.USER)
		ENDIF
		IF NOT EMPTY(toCFG.PWD)
			lcCONN = lcCONN+';PWD='   +ALLTRIM(toCFG.PWD)
		ENDIF
		IF NOT EMPTY(toCFG.DBNAME)
			lcCONN = lcCONN+';DATABASE='+ALLTRIM(toCFG.DBNAME)
		ENDIF
		IF NOT EMPTY(toCFG.OUTROS)
			lcCONN = lcCONN + ';'+ALLTRIM(toCFG.OUTROS)
		ENDIF
	ENDIF
RETURN(lcCONN)

* ROTINAS DE CONEXAO E ACESO AOS DADOS (SQL)

FUNC PESQUISASQL
****************
PARAMETERS tcSINTAXE, tcARQUIVO
	IF USED(tcARQUIVO)
		USE IN &tcARQUIVO
	ENDIF
	LOCAL lnQTDDATAS, lnXI, lnOCO AS Integer
	LOCAL lcAUX, lcLETRA, lcTAG1, lcTAG2 AS String
	STORE 0 TO lnQTDDATAS, lnXI, lnOCO
	STORE '' TO lcAUX, lcLETRA, lcTAG1, lcTAG2

*!*		lnOCO = AT(CHR(9),tcSINTAXE)
*!*		IF lnOCO > 0
*!*			DO MENS WITH '<TAB> no meio da sintaxe SQL'+CHR(13)+;
*!*						SUBSTR(tcSINTAXE,MAX(1,lnOCO-15),30)
*!*		ENDIF

	* TRATAMENTO DE CAMPOS DATETIME
	IF 'TO_CHART(' $ tcSINTAXE
		lcTAG1 = 'TO_CHART('
		lcTAG2 = ')TO_CHART'
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS'
				lcNEW1 = "DATE_FORMAT("
				lcNEW2 = ",'%d/%m/%Y %H:%I:%S')"
			CASE goCONEXAO.BANCO = 'POS'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY HH24:MI:SS')"
			CASE goCONEXAO.BANCO = 'ORA'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY HH24:MI:SS')"
			CASE goCONEXAO.BANCO = 'DBC'
				lcNEW1 = 'TTOC('
				lcNEW2 = ")"
			OTHERWISE
				lcNEW1 = 'CONVERT(VARCHAR(19),'
				lcNEW2 = ',120)'
		ENDCASE
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG1, lcNEW1 )
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG2, lcNEW2 )
	ENDIF
	
	* TRATAMENTO DE CAMPOS DATA
	IF 'TO_CHAR(' $ tcSINTAXE
		lcTAG1 = 'TO_CHAR('
		lcTAG2 = ')TO_CHAR'
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS'
				lcNEW1 = 'DATE_FORMAT('
				lcNEW2 = ",'%d/%m/%Y')"
			CASE goCONEXAO.BANCO = 'POS'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY')"
			CASE goCONEXAO.BANCO = 'ORA'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY')"
			CASE goCONEXAO.BANCO = 'DBC'
				lcNEW1 = 'DTOC('
				lcNEW2 = ")"
			OTHERWISE
				lcNEW1 = 'CONVERT(VARCHAR(10),'
				lcNEW2 = ',103)'
		ENDCASE
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG1, lcNEW1 )
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG2, lcNEW2 )
	ENDIF

	* CAMPOS DIA DA SEMANA
	IF 'FNOMDIA(' $ tcSINTAXE
		STORE '' TO lcNEW1, lcNEW2
		lcTAG1 = 'FNOMDIA('
		lcTAG2 = ')FNOMDIA'
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS'
				**
			CASE goCONEXAO.BANCO = 'POS'
				**
			CASE goCONEXAO.BANCO = 'ORA'
				**
			CASE goCONEXAO.BANCO = 'DBC'
				**
			OTHERWISE
				lcNEW1 = "SUBSTR('DomingoSegundaTerça  Quarta Quinta Sexta  Sábado ',(DATEPART(dw,"
				lcNEW2 = ')-1)*7+1,7)'
		ENDCASE
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG1, lcNEW1 )
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG2, lcNEW2 )
	ENDIF

	* TRATAMENTO DE CAMPOS NULOS
	IF 'ISNULL(' $ tcSINTAXE
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS' &&&  LINHA ALTERADA  &&&
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','COALESCE(')
			CASE goCONEXAO.BANCO = 'POS'
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','COALESCE(')
			CASE goCONEXAO.BANCO = 'ORA'
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','NVL(')
			CASE goCONEXAO.BANCO = 'DBC'
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','NVL(')
			OTHERWISE
				* NÃO PRECISA FAZER (PADRÃO MS-SQL SERVER)'
		ENDCASE
	ENDIF

	* TRATAMENTOS ESPECIAIS DE SINTAXE
	DO CASE
		CASE goCONEXAO.BANCO = 'DBC'
			tcSINTAXE = TRATASQLFOX(tcSINTAXE)
		CASE goCONEXAO.BANCO = 'POS'
			tcSINTAXE = TRTSINPGSQL(tcSINTAXE)
			tcSINTAXE = TRTFUNPGSQL(tcSINTAXE)
		CASE goCONEXAO.BANCO = 'ORA'
			tcSINTAXE = TRATASQLORACLE(tcSINTAXE)
		CASE goCONEXAO.BANCO = 'MYS'
			tcSINTAXE = TRATASQLMYSQL(tcSINTAXE)
		OTHERWISE
			tcSINTAXE = TRATASQLMSSQL(tcSINTAXE)
	ENDCASE

	* SE DEBUG-SQL ESTÁ ATIVADO, MOSTRAR COMANDO
	IF goAPLICATIVO.DEBUGSQL=1
		lnRESP=MESSAGEBOX(tcSINTAXE,'DEBUG DE COMANDO SQL',2)
		IF lnRESP=3
			goAPLICATIVO.DEBUGSQL=0
		ENDIF
		IF lnRESP=4
			_CLIPTEXT = tcSINTAXE
		ENDIF
	ENDIF

	* SALVA COMANDO PARA POSSÍVEL USO
	goAPLICATIVO.ULTPSQL	= tcSINTAXE
	goCONEXAO.LASTCOMMAND   = tcSINTAXE
	goCONEXAO.LASTCURSOR    = tcARQUIVO
	
	DO CASE
		CASE goCONEXAO.BANCO = 'DBC'
			* BANCO DE DADOS NATIVO DO FOX, NÃO UTILIZA DRIVER ODBC. TODAS AS PESQUISAS FUNCIONAM COM COMANDOS NATIVOS.
			tcSINTAXE	= STRTRAN( tcSINTAXE, CHR(13)+CHR(10), ' ' )
			tcSINTAXE	= STRTRAN( tcSINTAXE, CHR(09), '' )
	ENDCASE

	* EXECUTA COMANDO NA BASE
	LOCAL lnSECINI, lnSECFIM AS Integer 
	LOCAL ldDATETIME AS Datetime 
	
	ldDATETIME 	= DATETIME()
	lnSECINI 	= SECONDS()
	gnSQLOK		= SQLEXEC(goCONEXAO.ALCA,tcSINTAXE,tcARQUIVO)
	lnSECFIM	= SECONDS()
	
	* LOG DE PEFORMANCE
	IF GOAPLICATIVO.LOGPERF = 1 AND gnSQLOK > 0 AND USED(tcARQUIVO)
		LOGPERF_GRAVAR(ldDATETIME,lnSECFIM-lnSECINI,RECCOUNT(tcARQUIVO),'PESQ',tcSINTAXE)
	ENDIF
	
	IF NOT goAPLICATIVO.TESTE AND gnSQLOK<0
		=AERROR(laERRO)
		* CASO SEJA ERRO DE CONEXÃO
		IF VERERROCONEXAO(laERRO[4], laERRO[5], laERRO[3])
			DO FORM SYSTEM_ERROCONEXAO
			* SE OPTOU POR RECONECTAR, TENTA REPETIR A QUERY
			gnSQLOK = REPETIRQUERY()
		ENDIF
	ENDIF
	
	* RETORNO 0(ZERO) DA FUNÇÃO GERALMENTE PRESCEDE UM ALIAS NOT FOUND
	* LOGAMOS O ERRO NA TS_LOG E TENTAREMOS REPETIR A QUETY
	IF NOT goAPLICATIVO.TESTE AND gnSQLOK=0
		TEXT TO lcLOGERROZERO NOSHOW TEXTMERGE PRETEXT 7
			INSERT INTO TS_LOGS
				(
					FK_USUARIO,
					DH_LOG,
					DS_ROTINA,
					TG_ACAO,
					DS_OBJETOPK,
					DS_TABELA,
					DS_OBS				
				)
			VALUES
				(
					<<GOCONEXAO.FK_USUARIO>>,
					GETDATE(),
					'ERRO PESQUISASQL',
					'*',
					'0',
					<<LEFT(ALLTRIM(GOCONEXAO.LASTCURSOR),30>)>,
					<< LEFT(CHRTRAN('ERRO QUERY:'+ALLTRIM(goCONEXAO.LASTCOMMAND),CHR(13)+CHR(10),' '),70))>>
				)
		ENDTEXT
		=SQLEXEC(GOCONEXAO.ALCA,lcLOGERROZERO)
		* POR ENQUANTO NÃO REEXECUTA A QUERY - SOLICITADO POR ROGÉRIO
		*gnSQLOK = REPETIRQUERY()
	ENDIF
	
	goCONEXAO.LASTCOMMAND   = ''
	goCONEXAO.LASTCURSOR    = ''
        
	IF gnSQLOK<0
		=AERROR(laERRO)
		
		lcNUMERRO		= ALLTRIM(STR(laERRO(1)))
		lcERRO			= laERRO(3)
		lcODBCSTATE 	= NVL(laERRO[4],' ')
		lcNUMODBCSTATE	= ALLTRIM(STR(NVL(laERRO[5],0)))
		
		goCONEXAO.LASTERRORSQL = lcNUMERRO + ' - ' + lcERRO + ' (ODBC NUM: ' + lcNUMODBCSTATE + ' - ODBC STATE: ' + lcODBCSTATE + ')'

		IF NOT goAPLICATIVO.TESTE
			DO ROTERRO WITH 0-laERRO(1), lcERRO, SYS(16), 0
		ELSE
			lnRESP	= MESSAGEBOX('ERRO NO ACESSO À BASE DE DADOS: ' + CHR(13)+CHR(10)+;
									SYS(16)+CHR(13)+CHR(10)+;
									lcNUMERRO+CHR(13)+CHR(10)+;
									lcERRO,'AVISO: SQL-ERRO',48+2+256)
			IF lnRESP = 3
				_CLIPTEXT	= tcSINTAXE
				DEBUG
				SUSP
			ENDIF
			IF lnRESP = 4
				_CLIPTEXT = tcSINTAXE
			ENDIF
		ENDIF
	ELSE
	
		* MEDIDORES DE TRAFEGO
		IF NOT EMPTY(tcARQUIVO) AND USED(tcARQUIVO)
			LOCAL 		lnTRAFEGOVAI, lnTRAFEGOVEM AS Double
			STORE 0 TO	lnTRAFEGOVAI, lnTRAFEGOVEM 
		
			lnTRAFEGOVAI = LEN(tcSINTAXE)
			lnTRAFEGOVEM = HEADER(tcARQUIVO) + (RECSIZE(tcARQUIVO)*RECCOUNT(tcARQUIVO)+1)

			goCONEXAO.QT_QUERYS 	= goCONEXAO.QT_QUERYS + 1 
			goCONEXAO.QT_TEMPO		= goCONEXAO.QT_TEMPO + lnSECFIM-lnSECINI
			goCONEXAO.QT_TRAFEGOVAI = goCONEXAO.QT_TRAFEGOVAI + lnTRAFEGOVAI
			goCONEXAO.QT_TRAFEGOVEM = goCONEXAO.QT_TRAFEGOVEM + lnTRAFEGOVEM
		ENDIF
	
		* TRATAMENTO DE ARREDONDAMENTO DAS CASAS DECIMAIS SOMENTE NO ORACLE
		** DEVIDO A BUG DO DRIVER {MICROSOFT ODBC PARA ORACLE} AO EFETUAR FUNÇÕES COMO SUM, MAX, MIN E ETC...
		LOCAL ARRAY laCAMPOS[1]
		
		LOCAL lnXI AS Integer
		STORE 0 TO lnXI
		
		LOCAL lcMACRO, lcFIELDS AS String
		STORE '' TO lcMACRO, lcFIELDS

		LOCAL llOK AS Logical
		STORE .F. TO llOK

		IF 'ORACLE' $ UPPER(goCONEXAO.DRIVER)
			=AFIELDS(laCAMPOS,tcARQUIVO)
			FOR lnXI = 1 TO ALEN(laCAMPOS,1)
				IF 'VL_' $ UPPER(laCAMPOS[lnXI,1]) OR 'VAL_' $ UPPER(laCAMPOS[lnXI,1]) AND laCAMPOS[lnXI,2] = 'N' AND laCAMPOS[lnXI,3] = 20 AND laCAMPOS[lnXI,4] = 0
					lcFIELDS = lcFIELDS + ',CAST(' + laCAMPOS[lnXI,1] + ' AS N(20,2)) AS ' + laCAMPOS[lnXI,1]
					llOK = .T.
				ELSE
					lcFIELDS = lcFIELDS + ',' + laCAMPOS[lnXI,1]
				ENDIF
			ENDFOR
			IF llOK
				lcFIELDS = SUBSTR(lcFIELDS,2)
				lcMACRO = 'SELECT ' + lcFIELDS + ' FROM ' + tcARQUIVO + ' INTO CURSOR ' + tcARQUIVO + ' READWRITE'
				&lcMACRO
			ENDIF
		ENDIF
	ENDIF
RETURN

FUNC TRATASQLFOX
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	IF ' CASE WHEN ' $ lcCPOOUT
		lcCPOOUT = STRTRAN( lcCPOOUT, ' CASE WHEN '	, ' IIF( '	)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' THEN '			, ' , '		)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' ELSE '			, ' , '		)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' END '			, ' ) '		)
	ENDIF
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LPAD(', 'PADL(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'RPAD(', 'PADR(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(')
RETURN(lcCPOOUT)

FUNC TRTSINPGSQL
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(')
	*lcCPOOUT = STRTRAN( lcCPOOUT, "\'", "\.'" )
	lcCPOOUT = STRTRAN( lcCPOOUT, "\'", "\.'" )
	lcCPOOUT = STRTRAN( lcCPOOUT, "\", "\\" )
RETURN(lcCPOOUT)

FUNC TRTFUNPGSQL
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = REMOVERTOPSQL(lcCPOOUT,'LIMIT')
	lcCPOOUT = STRTRAN( lcCPOOUT, ' SPACE( ', ' LPAD(" ",')
RETURN(lcCPOOUT)

FUNC TRATASQLORACLE
*******************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT, lcP1, lcP2 AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT	= tcCPOIN
	lcCPOOUT	= STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(' )
	lcCPOOUT	= STRTRAN( lcCPOOUT, ' SPACE( ', ' LPAD(" ",' )
	* TRATANDO POR PARTES
	IF 'FROM' $ lcCPOOUT
		lcP1 = STREXTRACT(lcCPOOUT,'','FROM',1,4)
		lcP2 = STREXTRACT(lcCPOOUT,'FROM','',1,0)
		lcP2 = STRTRAN( lcP2, ' AS ', ' ')
		lcP1 = REMOVERTOPSQL(lcP1,'ROWNUM')
		lcCPOOUT = lcP1+lcP2
	ENDIF
	IF 'DATE_PART(' $ lcCPOOUT
		LOCAL lcAUX, lcCONTEUDO AS String
		LOCAL lnXI AS Integer
		FOR lnXI = 1 TO OCCURS('DATE_PART(',lcCPOOUT)
			lcCONTEUDO = STREXTRACT(lcCPOOUT,'DATE_PART(',')',lnXI)
			IF EMPTY(lcCONTEUDO)
				LOOP
			ENDIF
			DO CASE
				CASE 'DAY' $ lcCONTEUDO
					lcAUX = STREXTRACT( lcCONTEUDO, ',' , '' ) + ", 'DD'" 
					lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
				CASE 'MONTH' $ lcCONTEUDO
					lcAUX = STREXTRACT( lcCONTEUDO, ',' , '' ) + ", 'MM'"
					lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
				CASE 'YEAR' $ lcCONTEUDO
					lcAUX = STREXTRACT( lcCONTEUDO, ',' , '' ) + ", 'YYYY'"
					lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
				OTHERWISE
					LOOP
			ENDCASE										
		ENDFOR
		lcCPOOUT= STRTRAN(lcCPOOUT,'DATE_PART(','TO_CHAR(')
	ENDIF
	IF ('CONCAT(' $ lcCPOOUT) AND (')CONCAT' $ lcCPOOUT)
		lcCPOOUT= STRTRAN(lcCPOOUT,'CONCAT(','(')
		lcCPOOUT= STRTRAN(lcCPOOUT,')CONCAT',')')
	ENDIF
RETURN(lcCPOOUT)

FUNC TRATASQLMYSQL
***************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT, lcAUX, lcP1, lcP2 AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT	= tcCPOIN
	lcCPOOUT 	= STRTRAN( lcCPOOUT, ' INTEGER' , ' DECIMAL(11,0)' )
	lcCPOOUT 	= STRTRAN( lcCPOOUT, '\' , '\\' )
	
	IF ( 'CONCAT(' $ lcCPOOUT ) AND ( ')CONCAT' $ lcCPOOUT )
		LOCAL lcAUX, lcCONTEUDO AS String
		LOCAL lnXI AS Integer
		FOR lnXI = 1 TO OCCURS('CONCAT(',lcCPOOUT)
			lcCONTEUDO = STREXTRACT(lcCPOOUT,'CONCAT(',')CONCAT',lnXI)
			IF EMPTY(lcCONTEUDO)
				LOOP
			ENDIF
			lcAUX 	= STRTRAN( lcCONTEUDO, '||' , ',' )
			lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
			lcCPOOUT= STRTRAN(lcCPOOUT,')CONCAT',')',1,1)
		NEXT
	ENDIF
	IF (' NUMERIC(' $ lcCPOOUT)
		lcCPOOUT	= STRTRAN(lcCPOOUT,' NUMERIC(',' DECIMAL(')
	ENDIF
	
	* AJUSTANDO COALESCE PARA CAMPOS DECIMAIS
	IF ('COALESCE(' $ lcCPOOUT)
		LOCAL lcAUX, lcCAMPO, lcCONTEUDO AS String
		LOCAL lnXI AS Integer
		PRIVATE pnFUNCS AS Integer
		STORE 0 TO pnFUNCS

		FOR lnXI = 1 TO OCCURS('COALESCE(',lcCPOOUT)
			lcCONTEUDO = PEGAMYSQLCONTEUDO(lcCPOOUT,lnXI)
			IF EMPTY(lcCONTEUDO)
				LOOP
			ENDIF

			lcCAMPO = PEGAMYSQLCAMPO(lcCONTEUDO)
			lcAUX 	= PEGAMYSQLAUX(lcCONTEUDO)
			IF ALLTRIM(lcAUX) == '0'
				lcCPOOUT	= STRTRAN(lcCPOOUT,'COALESCE(' + lcCAMPO + ',' + lcAUX + ')','COALESCE(' + lcCAMPO + ', 0.0)',1,1)
			ENDIF
		NEXT
	ENDIF
	
	* AJUSTANDO COUNT
	IF ('COUNT(*)' $ lcCPOOUT OR 'COUNT(1)' $ lcCPOOUT)
		lcCPOOUT	= STRTRAN(lcCPOOUT,'COUNT(*)','COALESCE(COUNT(1),0.0)')
		lcCPOOUT	= STRTRAN(lcCPOOUT,'COUNT(1)','COALESCE(COUNT(1),0.0)')
	ENDIF

	* AJUSTANDO TOP PARA LIMIT
	lcAUX = STREXTRACT(lcCPOOUT,'SELECT','FROM')
	IF ' TOP ' $ lcAUX
		lcCPOOUT = REMOVERTOPSQL(lcCPOOUT,'LIMIT')
	ENDIF
RETURN(lcCPOOUT)

PROC PEGAMYSQLCONTEUDO
************
LPARAMETERS tcCPO, tnXI, tnFUNCSINI
	IF TYPE('tcCPO')<>'C'
		tcCPO = ''
	ENDIF
	IF TYPE('tnXI')<>'N'
		tnXI = 0
	ENDIF
	IF TYPE('tnFUNCSINI')<>'N'
		tnFUNCSINI = 0
	ENDIF

	IF EMPTY(tcCPO) OR EMPTY(tnXI)
		RETURN('')
	ENDIF
	
	LOCAL lnINI,lnFIM AS Integer 
	LOCAL lcFUNC,lcRET AS String 
	STORE '' TO lcRET
	
	lcFUNC = 'COALESCE('
	lnINI = AT(lcFUNC,tcCPO,tnXI)+LEN(lcFUNC)
	lnFIM = AT(')',tcCPO,tnXI+pnFUNCS)
	
	lcRET = SUBSTR(tcCPO,lnINI,lnFIM-lnINI) 
	* PROTEÇÃO, NO CASO DE FUNÇÕES DENTRO DO COALESCE
	IF '(' $ lcRET AND (pnFUNCS = 0 OR pnFUNCS <> tnFUNCSINI)
		pnFUNCS = pnFUNCS + OCCURS('(',lcRET)
		lcRET = PEGAMYSQLCONTEUDO(tcCPO,tnXI,pnFUNCS)
	ENDIF
	RETURN(lcRET)
ENDPROC

PROC PEGAMYSQLAUX
************
LPARAMETERS tcCONTEUDO
	IF TYPE('tcCONTEUDO')<>'C'
		tcCONTEUDO = ''
	ENDIF
 
	IF EMPTY(tcCONTEUDO)
		RETURN('')
	ENDIF
	LOCAL lcRET AS String
	LOCAL lnULTVIR AS Integer 
	lnULTVIR = AT(',',tcCONTEUDO,OCCURS(',',tcCONTEUDO)) + 1
	lcRET = ALLTRIM(SUBSTR(tcCONTEUDO,lnULTVIR,100))
	RETURN(lcRET)
ENDPROC

PROC PEGAMYSQLCAMPO
************
LPARAMETERS tcCONTEUDO
	IF TYPE('tcCONTEUDO')<>'C'
		tcCONTEUDO = ''
	ENDIF
	IF EMPTY(tcCONTEUDO)
		RETURN('')
	ENDIF
	LOCAL lcRET AS String
	LOCAL lnULTVIR AS Integer 
	lnULTVIR = AT(',',tcCONTEUDO,OCCURS(',',tcCONTEUDO)) -1
	lcRET = ALLTRIM(SUBSTR(tcCONTEUDO,1,lnULTVIR))
	RETURN(lcRET)
ENDPROC

FUNC TRATASQLMSSQL
******************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT, lcCONTEUDO, lcSUBSTITUI, lcAUX AS String
	LOCAL lnXI, lnOCO AS Integer
	STORE '' TO lcCPOOUT, lcCONTEUDO, lcSUBSTITUI, lcAUX
	STORE 0 TO lnXI, lnOCO
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = STRTRAN( lcCPOOUT, '||' , '+' )
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTR(', 'SUBSTRING(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LENGTH(', 'LEN(')
	IF 'LPAD(' $ lcCPOOUT
		FOR lnXI = 1 TO 100
			lcCONTEUDO	= STREXTRACT(lcCPOOUT,'LPAD(',')')
			IF EMPTY(lcCONTEUDO)
				EXIT
			ENDIF
			lnOCO		= RAT( ',' , lcCONTEUDO )
			lcSUBSTITUI	= 'CAST( ' + ;
							LEFT( lcCONTEUDO,lnOCO-1 ) + ;
							' AS CHAR(' + ;
							RIGHT( lcCONTEUDO,lnOCO-2 ) + '))'
			lcCPOOUT	= STRTRAN( lcCPOOUT, 'LPAD(' + lcCONTEUDO + ')', lcSUBSTITUI )
		ENDFOR
	ENDIF
	IF 'RPAD(' $ lcCPOOUT
		FOR lnXI = 1 TO 100
			lcCONTEUDO	= STREXTRACT(lcCPOOUT,'RPAD(',')')
			IF EMPTY(lcCONTEUDO)
				EXIT
			ENDIF
			lnOCO		= RAT( ',' , lcCONTEUDO )
			lcSUBSTITUI	= 'CAST( ' + ;
							LEFT( lcCONTEUDO,lnOCO-1 ) + ;
							' AS ' + ;
							RIGHT( lcCONTEUDO,lnOCO-2 ) + ')'
			lcCPOOUT	= STRTRAN( lcCPOOUT, 'LPAD('+lcCONTEUDO+')', lcSUBSTITUI )
		ENDFOR
	ENDIF
	IF 'DATE_PART(' $ lcCPOOUT
		FOR lnXI = 1 TO 100
			lcCONTEUDO	= STREXTRACT(lcCPOOUT,'DATE_PART(',')')
			IF EMPTY(lcCONTEUDO)
				EXIT
			ENDIF
			lcAUX		= UPPER(STREXTRACT(lcCONTEUDO, "'", "'," ))
			IF NOT lcAUX $ 'DAY,MONTH,YEAR'
				LOOP
			ENDIF
			lcSUBSTITUI	= UPPER(lcAUX) + '(' + ;
							UPPER(STREXTRACT(lcCONTEUDO, "',")) + ')'
			lcCPOOUT	= STRTRAN( lcCPOOUT, 'DATE_PART('+lcCONTEUDO+')', lcSUBSTITUI )
		ENDFOR
	ENDIF
	IF ('CONCAT(' $ lcCPOOUT) AND (')CONCAT' $ lcCPOOUT)
		lcCPOOUT= STRTRAN(lcCPOOUT,'CONCAT(','(')
		lcCPOOUT= STRTRAN(lcCPOOUT,')CONCAT',')')
	ENDIF
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LENGTH(', 'LEN(')
	
	* TRATAMENTO DE DATA/HORA DE ACORDO COM ZW
	IF GOAPLICATIVO.TIMEZONE = 'ON'	
		lcCPOOUT = STRTRAN(lcCPOOUT,'GETDATE(','DBO.GETDATEZONE(')
		lcCPOOUT = STRTRAN(lcCPOOUT,'getdate(','DBO.GETDATEZONE(')
	ENDIF
	
RETURN(lcCPOOUT)

FUNC REMOVERTOPSQL
******************
LPARAMETERS tcSQL, tcOUTROS
	LOCAL lcOUT AS String
	lcOUT = tcSQL
	IF ' TOP ' $ lcOUT
		LOCAL lcAUX, lcLETRA AS String
		LOCAL lnOCO AS Integer
		lcAUX	= ''
		lnOCO	= AT(' TOP ',lcOUT)
		FOR lnXI = lnOCO+5 TO LEN(lcOUT)
			lcLETRA = SUBSTR(lcOUT,lnXI,1)
			IF EMPTY(lcLETRA)
				EXIT
			ENDIF
			lcAUX = lcAUX + lcLETRA
		ENDFOR
		lcOUT	= STRTRAN(lcOUT,' TOP '+lcAUX,'')
		IF 'LIMIT' $ tcOUTROS
			lcOUT	= lcOUT + ' LIMIT '+lcAUX
		ENDIF
	ENDIF
RETURN(lcOUT)


FUNC DATASERVER
******************************
* PEGA DATA/HORA DO SERVIDOR *
******************************
* Criada opção para pegar o UTC da empresa passada por parâmetro

	LPARAMETERS tcFK_EMPRESA AS String
	
	LOCAL		lcALIASOLD, lcCOMANDO AS String
	STORE '' TO	lcALIASOLD, lcCOMANDO
	
	LOCAL ldDATAOUT AS Datetime
	
	IF TYPE( 'tcFK_EMPRESA' ) <> 'C' OR EMPTY( tcFK_EMPRESA )
		tcFK_EMPRESA = ''
	ENDIF
		
	lcALIASOLD	= ALIAS()
	
	DO CASE
		CASE goCONEXAO.BANCO = 'MYS' &&&  LINHA ALTERADA  &&&
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					NOW() AS SYSDATE
			ENDTEXT

		CASE goCONEXAO.BANCO = 'POS'
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					NOW() AS SYSDATE
			ENDTEXT

		CASE goCONEXAO.BANCO = 'ORA'
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					SYSDATE
				FROM
					DUAL
			ENDTEXT
		
		CASE UPPER(ALLTRIM(goCONEXAO.BANCO)) == 'SQL' AND NOT EMPTY(tcFK_EMPRESA)
		* Roda apenas no SQL SERVER pois a função GETUTCDATE() só existe nele
			&& Pega o horário UTC zero para poder somar o UTC da empresa passada
			
			* Retorna o UTC do estado da empresa passada trazendo de uma propriedade do goAPLICATIVO que é armazenada no inicio do sistema trazendo da tabela TB_UTC e TB_UTCITEM
			lnUTCSOMA = RETORNA_UTCPORUF( BUSCACAMPO('SELECT DS_UF FROM TB_EMPRESAS WHERE PK_ID = ' + XX(tcFK_EMPRESA)) ) / 100 && Divide o UTC por 100 porque o UTC é salvo no banco multiplicado por 100, por exemplo quando o UTC é -3 no banco estará como -300
			
			IF NOT EMPTY(lnUTCSOMA)
				* Comando para retornar a data concatenando a hora e o minuto e somando o UTC do estado da empresa na hora
				&& Utiliza a função GETUTCDATE() que retorna a hora com o UTC zero, desconsiderando o UTC do servidor
				TEXT TO lcCOMANDO NOSHOW PRETEXT 7
					SELECT DATEADD(HOUR, [[UTC]], GETUTCDATE()) AS SYSDATE
				ENDTEXT
				lcCOMANDO	= STRTRAN( lcCOMANDO, '[[UTC]]', XX(lnUTCSOMA) )
			ELSE
				* QUANDO NÃO ENCONTRAR UTC CONFIGURADO BUSCA O GETDATE() NORMALMENTE
				TEXT TO lcCOMANDO NOSHOW PRETEXT 7
					SELECT
						GETDATE() AS SYSDATE
				ENDTEXT
			ENDIF
					
		OTHERWISE
			* MSSQL
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					GETDATE() AS SYSDATE
			ENDTEXT

	ENDCASE

	=PESQUISASQL(lcCOMANDO,'TMPDATSIS')
	ldDATAOUT	= TMPDATSIS.SYSDATE
	USE IN TMPDATSIS
	
	IF NOT EMPTY(lcALIASOLD)
		SELE &lcALIASOLD
	ENDIF

	RETURN ldDATAOUT
ENDFUNC

* ROTINAS DE DEFINICAO/CONFIGURAÇÃO DE INTERFACE
PROC DIMINUIR
*************
LPARAMETERS toCNT
* DIMINUIR FORMULARIO AJUSTANDO TODOS OS OBJETOS (SERVE TAMBÉM PARA CONTAINERS)
* PARA CASOS DE RESOLUÇÃO MENOR QUE 800X600
	IF SYSMETRIC(2) >= goAPLICATIVO.MINALTURA AND SYSMETRIC(1) >= goAPLICATIVO.MINLARGURA
		RETURN
	ENDIF
	LOCAL lnK AS Integer
	lnK = 800 / 1024

	* CORRIGINDO O TAMANHO DO FOMULARIO EM CASO DE AUTOAJUSTE
	* (ELE JÁ SE ENQUADROU NA RESOLUÇÃO DE TELA, "PERDENDO" AREA E OBJETOS)
	IF UPPER(toCNT.BASECLASS) = 'FORM'
		IF toCNT.WIDTH = _SCREEN.WIDTH
			LOCAL lnWID, lnHEI, lnLARG, lnALT
			lnWID = 10
			lnHEI = 10
			* teste: achando o tamanho da sccreen
			FOR EACH OBJETOFRM IN toCNT.objects
				lnLARG = OBJETOFRM.LEFT + OBJETOFRM.WIDTH
				lnALT  = OBJETOFRM.TOP  + OBJETOFRM.HEIGHT
				IF lnLARG>lnWID
					lnWID = lnLARG
				ENDIF
				IF lnALT>lnHEI
					lnHEI = lnALT
				ENDIF
			ENDFOR
			IF toCNT.WIDTH < lnWID
				toCNT.WIDTH = lnWID + 2
			ENDIF
			IF toCNT.HEIGHT < lnHEI
				toCNT.HEIGHT = lnHEI + 2
			ENDIF
		ENDIF
	ENDIF

	* AJUSTANDO TAMANHO DO CONTAINER
	IF TYPE('toCNT.WIDTH')='N'
		toCNT.WIDTH = INT( toCNT.WIDTH * lnK)
		toCNT.HEIGHT= INT( toCNT.HEIGHT * lnK)
		toCNT.TOP	= MAX( INT( toCNT.TOP * lnK) , 0)
		toCNT.LEFT	= MAX( INT( toCNT.LEFT * lnK) , 0)
	ENDIF
	* AJUSTANDO CADA OBJETO
	LOCAL OBJETO AS OBJECT
	FOR EACH OBJETO IN toCNT.Objects
		IF UPPER(OBJETO.BASECLASS) $ 'CONTAINER,PAGEFRAME,OPTIONGROUP'
			DO DIMINUIR WITH OBJETO
		ELSE
			IF TYPE('OBJETO.WIDTH')='N'
				IF UPPER(OBJETO.CLASS) <> 'LABELF4'
					OBJETO.WIDTH = INT( OBJETO.WIDTH * lnK)
					OBJETO.HEIGHT= INT( OBJETO.HEIGHT * lnK)
				ENDIF
				OBJETO.TOP   = INT( OBJETO.TOP * lnK)
				OBJETO.LEFT  = INT( OBJETO.LEFT * lnK)
			ENDIF
		ENDIF
		IF UPPER(OBJETO.BASECLASS) $ 'GRID'
			* SE FOR UM GRID, CALCULA TAMANHO DAS COLUNAS E GUARDA 
			FOR EACH COLUNAZ IN OBJETO.COLUMNS
				COLUNAZ.TAG = STR( INT( COLUNAZ.WIDTH * lnK ) )
			ENDFOR
		ENDIF
		IF TYPE('OBJETO.FONTSIZE')='N'
			IF UPPER(OBJETO.FONTNAME) = 'FIXEDSYS'
				OBJETO.FONTNAME = 'ARIAL'
			ENDIF
			OBJETO.FONTSIZE = MAX( OBJETO.FONTSIZE-2, 6)
		ENDIF
		IF UPPER(OBJETO.BASECLASS) $ 'GRID'
			* SE FOR UM GRID, ARRUMA TAMANHO DAS COLUNAS COMO ESTAVA ANTES DE MUDAR A FONTE
			FOR EACH COLUNAZ IN OBJETO.COLUMNS
				COLUNAZ.WIDTH = VAL(COLUNAZ.TAG)
			ENDFOR
		ENDIF
	ENDFOR

RETURN

PROC CONFIGFRM
**************
PARAMETERS toFORMATU
	
	LOCAL lcPATH AS String

	*#FLAT - NÃO TROCA COR DO FORM (HÁ MARCAÇÃO PRÓPRIA)
	IF goAPLICATIVO.FLAT = 0 
		TRY
			lcPATH= SYS(1271,toFORMATU)
			lcPATH= ALLTRIM(lcPATH)
			IF "\TEMP\"$UPPER(lcPATH)
				toFORMATU.BACKCOLOR = RGB(192,253,189)
			ENDIF
		CATCH
		ENDTRY
	ENDIF
	
	PRIVATE poFORM AS Object
	poFORM	= toFORMATU

	WITH toFORMATU

		* PROPRIEDADES DO FORM
		.AUTOCENTER = .T.
		IF TYPE('lcTITULO')='C'
			.CAPTION = lcTITULO
		ENDIF
		.SETALL('DISABLEDFORECOLOR',RGB(0,0,0))

		* PROPRIEDADES DOS OBJETOS DENTRO DO FORM
		DO CONFIGOBJETOS WITH poFORM

	ENDWITH
RETURN

PROC CONFIGOBJETOS
******************
LPARAMETERS toOBJETO AS Object

	LOCAL loSUB, loPAGINA AS Object
	LOCAL lcBASE, lcMODULO AS String
	STORE '' TO lcBASE, lcMODULO

	FOR EACH loSUB IN toOBJETO.CONTROLS

		lcBASE	= ALLTRIM( UPPER( loSUB.BASECLASS ) )

		DO CASE
			CASE lcBASE	= 'PAGEFRAME'
				FOR EACH loPAGINA IN loSUB.PAGES
					DO CONFIGOBJETOS WITH loPAGINA
					* NECESÁRIO VERIFICAR RESTRIÇÃO DE MODULO
					IF '<MODULO>' $ UPPER(loPAGINA.Comment)
						lcMODULO = STREXTRACT(UPPER(loPAGINA.Comment),'<MODULO>','</MODULO>')
						IF NOT VMODULO(lcMODULO)
							DO DESABILITARBOBJS WITH loPAGINA
						ENDIF
					ENDIF
				ENDFOR

			CASE lcBASE = 'CONTAINER'
				IF UPPER(loSUB.CLASS) == 'IMGPREVIEW'
					IF loSUB.myAUTOMATICO
						loSUB.myCARREGAR()
					ENDIF
				ENDIF
				DO CONFIGOBJETOS WITH loSUB
			
			CASE lcBASE = 'CONTROL'
				IF UPPER(loSUB.CLASS) == 'COMBONN'
					IF '*' $ loSUB.COMMENT
						loSUB.BACKCOLOR = goAPLICATIVO.COROBRIGATORIO
					ENDIF
				ENDIF

			
			OTHERWISE
				IF lcBASE = 'TEXTBOX'
					DO MODELARTEXT WITH loSUB, toOBJETO
				ENDIF
				IF lcBASE $ 'COMBOBOX,SPINNER'
					* FONTE ALTERNATIVA
					IF GOAPLICATIVO.FONTALTERNATIVA = 1
						loSUB.FONTNAME	= 'Consolas'
						loSUB.FONTBOLD	= .T.
						loSUB.FONTSIZE	= 10
					ELSE
						loSUB.FONTNAME	= 'FIXEDSYS'
					ENDIF
					loSUB.HEIGHT	= 23
				ENDIF
				IF lcBASE $ ',CHECKBOX,COMMANDBUTTON,'
					loSUB.DISABLEDFORECOLOR = RGB(128,128,128)
				ENDIF
				IF lcBASE $ ',TEXTBOX,EDITBOX,COMBOBOX,SPINNER,CHECKBOX,'
					IF '*' $ loSUB.COMMENT
						loSUB.BACKCOLOR = goAPLICATIVO.COROBRIGATORIO
					ENDIF
					IF '<ZW>' $ loSUB.COMMENT
						DO CARREGARZW WITH loSUB
					ENDIF
				ENDIF
				IF lcBASE $ 'EDITBOX'
					IF TYPE('loSUB.Value') = 'C'
						loSUB.Value = ALLTRIM(loSUB.Value)
						* REMOVER TABS DO FINAL
						lnLEN = LEN(loSUB.Value)
						FOR lnXEDIT = 1 TO LEN(loSUB.Value)
							IF RIGHT(loSUB.Value,1) = CHR(13)
								loSUB.Value = SUBSTR(loSUB.Value,1,LEN(loSUB)-1)
							ENDIF
						ENDFOR
					ENDIF
				ENDIF
		ENDCASE

	ENDFOR
RETURN

PROC MODELARTEXT
****************
* FORMATA CAIXA TEXTO
LPARAMETERS toTXT AS TextBox, toPAI AS Object

	LOCAL lcVARIAVEL, lcNOMESHAPE, lcNOMEBTN, lcPICTSEGTO, lcTIPOVAR AS String
	LOCAL lnTAMPIC AS Integer
	LOCAL llPREENC_EMP AS Logical
	LOCAL luGET
	STORE '' TO lcVARIAVEL, lcNOMESHAPE, lcNOMEBTN, lcPICTSEGTO
	STORE 0 TO lnTAMPIC

	* NÃO CONFIGURAR CAIXA DE TEXTO
	IF '<NOCONFIG>' $ toTXT.Comment
		RETURN
	ENDIF
	
	IF GOAPLICATIVO.FONTALTERNATIVA = 1
		toTXT.FONTNAME	= 'Consolas'
		toTXT.FONTBOLD	= .T.
		toTXT.FONTSIZE	= 10
	ELSE
		toTXT.FONTNAME	= 'FIXEDSYS'
	ENDIF
	toTXT.HEIGHT	= 23
	toTXT.MARGIN	= 1
	
	*DESABILITA MSG DE F4 INATIVO
	goAPLICATIVO.VALIDARINIT=1
	
	lcVARIAVEL = toTXT.CONTROLSOURCE
	IF NOT EMPTY(toTXT.MAXLENGTH)
		toTXT.WIDTH = TAMANHOTX(toTXT.MAXLENGTH)
	ENDIF
	
	IF EMPTY(toTXT.INPUTMASK) AND UPPER(toTXT.Tag)=='TB_CADUNICO'
		* SE NÃO TIVER PICTURE DE ID.CADUNICO, FORÇAR PICTURE
		toTXT.INPUTMASK = '99999999'
	ENDIF
	
	IF NOT EMPTY(toTXT.INPUTMASK) AND NOT '[]' $ toTXT.COMMENT
		lnTAMPIC = LEN(ALLTRIM(toTXT.INPUTMASK))
		IF lnTAMPIC >= 1
			toTXT.WIDTH = TAMANHOTX(lnTAMPIC)
		ENDIF
	ENDIF
	
	* ARRUMANDO PROGRAMAÇÃO INDEVIDA ANTIGA (COLOCÁVAMOS "!" MANUALMENTE NOS TEXTBOX DIRETO NA TELA)
	IF GOAPLICATIVO.LOWERCASE = 1 AND toTXT.FORMAT == '!'
		toTXT.FORMAT = ''
	ENDIF
	
	IF EMPTY(toTXT.FORMAT)  AND EMPTY(toTXT.INPUTMASK) 
		* VERIFICAR SE PARAMETRO DE DEIXAR TEXTBOX LOWERCASE ESTÁ HABILITADO
		IF GOAPLICATIVO.LOWERCASE = 1
			toTXT.FORMAT = 'X'
		ELSE
			toTXT.FORMAT = '!'
		ENDIF
	ENDIF

	IF NOT EMPTY(lcVARIAVEL)
		lcVARIAVEL	= STRTRAN(lcVARIAVEL,'THISFORM','toFORMATU')
		luGET		= EVALUATE( lcVARIAVEL )
		lcTIPOVAR	= TYPE( lcVARIAVEL )
	ELSE
		luGET		= toTXT.Value
		lcTIPOVAR	= VARTYPE(toTXT.Value)
	ENDIF
		
	* FAZ FORMATAÇÃO DE CAMPO 'C' SOMENTE PARA CAIXAS DE TEXTO QUE POSSUEM CONTROLSOURCE
	IF lcTIPOVAR = 'C' AND NOT EMPTY(lcVARIAVEL)
		IF NOT ISNULL(luGET)
			IF EMPTY(toTXT.MAXLENGTH)
				toTXT.MAXLENGTH = LEN(luGET)
			ENDIF
			IF NOT '<>' $ toTXT.Comment
				toTXT.WIDTH = TAMANHOTX(LEN(luGET))
			ELSE
				lcNOMESHAPE	= 'lbl'+toTXT.NAME
				toPAI.ADDOBJECT(lcNOMESHAPE,'LABEL')
				lcNOMESHAPE = 'toPAI.' + lcNOMESHAPE
				&lcNOMESHAPE. .CAPTION		= ''
				&lcNOMESHAPE. .BACKCOLOR	= RGB(192,0,0)
				&lcNOMESHAPE. .TOP			= toTXT.TOP + toTXT.HEIGHT - 2
				&lcNOMESHAPE. .LEFT			= toTXT.LEFT + toTXT.WIDTH
				&lcNOMESHAPE. .HEIGHT		= 2
				&lcNOMESHAPE. .WIDTH		= 2
				&lcNOMESHAPE. .VISIBLE		= .T.
			ENDIF
		ENDIF
	ENDIF
	
	IF lcTIPOVAR='D'
		IF NOT '<>' $ toTXT.Comment
			toTXT.WIDTH = TAMANHOTX(10)
		ENDIF
	ENDIF
	IF lcTIPOVAR='T'
		IF NOT '<>' $ toTXT.Comment
			toTXT.WIDTH = TAMANHOTX(20)
		ENDIF
	ENDIF
	IF lcTIPOVAR='N'
		* FORMATAÇÃO DA CAIXA DE TEXTO DE ACORDO COM CONTEÚDO DO COMMENT
		IF '<OP>' $ toTXT.Comment
			toTXT.InputMask	= goAPLICATIVO.OPNUMERO_PICT
		ENDIF
		IF '<QT>' $ toTXT.Comment
			toTXT.InputMask	= goAPLICATIVO.ESTOQUE_PICT
		ENDIF
		IF '<PU>' $ toTXT.Comment
			toTXT.InputMask	= goAPLICATIVO.PREUNI_PICT
		ENDIF
		IF NOT EMPTY(toTXT.InputMask) AND NOT '[]' $ toTXT.Comment
			lnTAMPIC = LEN(toTXT.InputMask)
			IF lnTAMPIC>1
				toTXT.WIDTH = TAMANHOTX(lnTAMPIC)
			ENDIF
		ENDIF
	ENDIF
	
	IF NOT EMPTY(toTXT.TAG)
		* TEXTBOX DE F4
		lcNOMEBTN = 'F4'+ALLTRIM(toTXT.NAME)
		toPAI.NEWOBJECT(lcNOMEBTN,'LABELF4','PWICLASS')
		lcNOMEBTN = 'toPAI.'+lcNOMEBTN
		&lcNOMEBTN. .LEFT		= toTXT.LEFT + toTXT.WIDTH
		&lcNOMEBTN. .TOP		= toTXT.TOP
		&lcNOMEBTN. .HEIGHT		= toTXT.HEIGHT
		&lcNOMEBTN. .ANCHOR		= toTXT.ANCHOR
		&lcNOMEBTN. .myTEXT		= toTXT
		IF toTXT.VISIBLE
			&lcNOMEBTN. .VISIBLE	= .T.
			IF TYPE('toFORMATU.MyACAO') = 'C'
				IF  toFORMATU.MyACAO= 'M'
					* NÃO RODA VALID QUANDO CAIXA TEXTO ESTÁ VAZIA PARA ECONOMIZAR TRÁFEGO NA REDE
					IF NOT EMPTY(toTXT.Value)
						toTXT.Valid()
					ENDIF
				ENDIF
			ENDIF
		ENDIF
		IF toTXT.TAG = 'TB_SEGMENTOS'
			lcPICTSEGTO			= goAPLICATIVO.SEGMENTO_PICT
			toTXT.FORMAT		= 'R'
			toTXT.INPUTMASK		= lcPICTSEGTO
			
			* ARRUMA TAMANHO DA TEXT DE ACORDO COM O NOVO INPUTMASK E REPOSICIONA LABEL DE F4
			lnTAMPIC = LEN(toTXT.InputMask)
			IF lnTAMPIC>1
				toTXT.WIDTH = TAMANHOTX(lnTAMPIC)
			ENDIF
			&lcNOMEBTN. .LEFT		= toTXT.LEFT + toTXT.WIDTH
			
		ENDIF
		IF toTXT.TAG = 'TB_EMPRESAS' AND EMPTY(toTXT.VALUE)
			llPREENC_EMP	= .T.
			IF TYPE('toFORMATU.MyACAO') = 'C'
				IF ALLTRIM(UPPER(toFORMATU.CLASS)) = 'FORMDIG'
					IF toFORMATU.myACAO = 'M'
						llPREENC_EMP	= .F.
					ENDIF
				ENDIF
			ENDIF
			IF llPREENC_EMP AND EMPTY(toTXT.VALUE)
				toTXT.VALUE	= goAPLICATIVO.EMPATUAL
			ENDIF
		ENDIF
		IF toTXT.TAG = 'ES_ESTOQUES' AND EMPTY(toTXT.VALUE)
			llPREENC_EMP	= .T.
			IF TYPE('toFORMATU.MyACAO') = 'C'
				IF ALLTRIM(UPPER(toFORMATU.CLASS)) = 'FORMDIG'
					IF toFORMATU.myACAO = 'M'
						llPREENC_EMP	= .F.
					ENDIF
				ENDIF
			ENDIF
			IF llPREENC_EMP AND EMPTY(toTXT.VALUE)
				toTXT.VALUE	= goAPLICATIVO.ESTATUAL
			ENDIF
		ENDIF
	ENDIF
	
	*RE-HABILITA MSG DE F4 INATIVO
	goAPLICATIVO.VALIDARINIT=0

RETURN

FUNC TAMANHOTX
**************
* CALCULA O TAMANHO DE UMA CAIXA TEXTO
LPARAMETERS tnQCARAC
	LOCAL lnSIZE AS Integer
	
	*#FLAT - CÁLCULO DE LARGURA 
	IF goAPLICATIVO.FLAT = 1 OR GOAPLICATIVO.FONTALTERNATIVA = 1
		lnSIZE = tnQCARAC * 7 + 14
	ELSE 
		lnSIZE = tnQCARAC * 8 + 14		
	ENDIF 

RETURN(lnSIZE)

PROC MODELARCOMBO
*****************
* AJUSTA CONTEUDO DO COMBO DE ACORDO COM O SEU CONTROLSOURCE X VALUE
LPARAMETERS toCOMBO AS Object
	LOCAL lcVARIAVEL, lcPROCURAR, lcVALCOMBO, lnPOSICAO  AS STRING
	IF EMPTY(toCOMBO.VALUE)
		RETURN
	ENDIF
	
	lnPOSICAO = AT('=', toCOMBO.VALUE)
	IF lnPOSICAO>0
		lcPROCURAR = LEFT(toCOMBO.VALUE,lnPOSICAO)
	ELSE
		lcPROCURAR = ALLTRIM(toCOMBO.VALUE)+'='
	ENDIF
	lcVALCOMBO = toCOMBO.VALUE
	lnPOSICAO = AT(lcPROCURAR, toCOMBO.ROWSOURCE)
	IF lnPOSICAO>0
		lcVALCOMBO = STREXTRACT(toCOMBO.ROWSOURCE,lcPROCURAR,',')
		IF EMPTY(lcVALCOMBO)
			lcVALCOMBO = STREXTRACT(toCOMBO.ROWSOURCE,lcPROCURAR,'')
		ENDIF
		IF NOT EMPTY(lcVALCOMBO)
			lcVALCOMBO = lcPROCURAR + lcVALCOMBO
		ENDIF
	ENDIF
	toCOMBO.VALUE = lcVALCOMBO
RETURN

PROC CARREGARZW
***************
LPARAMETERS toOBJ AS Object
	IF TYPE('toOBJ') <> 'O'
		RETURN
	ENDIF
	* ATRELANDO ZW A CAIXA TEXTO
	IF '<ZW>' $ toOBJ.Comment
		LOCAL lcZWNOME, lcCOMANDO, lcINPUTMASK AS String
		* NOME DO PARAMETRO
		lcZWNOME		= STREXTRACT( toOBJ.Comment, '<ZW>', '</ZW>' )
		IF EMPTY(lcZWNOME)
			RETURN
		ENDIF
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT
				DS_FORMATO,
				TG_INICIO
			FROM
				TS_PARAMETROS
			WHERE
				DS_PARAMETRO=[[DS_PARAMETRO]]
		ENDTEXT
		lcCOMANDO	= STRTRAN( lcCOMANDO, '[[DS_PARAMETRO]]', XX(lcZWNOME) )
		=PESQUISASQL(lcCOMANDO,'TMFPARAM')
		* CONTEÚDO DO PARAMETRO
		toOBJ.Value		= RETORNASET( lcZWNOME, TYPE('toOBJ.Value'), TMFPARAM.TG_INICIO )
		* MÁSCARA DE INPUT
		IF TYPE('toOBJ.InputMask') = 'C'
			lcINPUTMASK		= ALLTRIM(TMFPARAM.DS_FORMATO)
			IF NOT EMPTY(lcINPUTMASK)
				toOBJ.InputMask	= lcINPUTMASK
			ENDIF
		ENDIF
		USE IN TMFPARAM
	ENDIF
RETURN

PROC IMPRIMIR
*************
PARAMETERS toFORM, tcARQLIS, tcNOMLIS, tcCONDIC1, tlOCULTAR, tcIMPRESSORA, tcOUTROS
	* PARAMETROS
	* 1 = FORM QUE CHAMOU A IMPRESSAO (DEVIDO AO DATASESSION)
	* 2 = NOME DO REPORT (SEM O PATH, SEM A EXTENSAO)
	* 3 = TITULO DO RELATORIO
	* 4 = CONDICAO PARA IMPRIMIR (UMA FUNCAO OU UMA CONDICAO)
	* 5 = OCULTAR FORM PADRÃO DE IMPRESSÃO (OPCIONAL)
	* 6 = NOME DA IMPRESSORA A SER UTILIZADA, QUANDO FOR IMP. OCULTA (OPCIONAL)
	* 7 = XML PARA RECEBIMENTO DE OUTROS PARAMETROS (LOG DE ENVIO DE DOCUMENTOS E ETC) E ENVIADO COMO PARAMETRO PARA TELA DE IMPRESSAO
	
	LOCAL lcNOMREP AS String
	
	IF TYPE('tcOUTROS')<>'C'
		tcOUTROS = ''
	ENDIF
	
	IF TYPE('tlOCULTAR')<>'L'
		tlOCULTAR=.F.
	ENDIF
	lcA4VOLIMP	= ALIAS()
	lnR4VOLIMP	= IIF( EOF(),0,RECNO() )
*!*		IF NOT FILE(goAPLICATIVO.ARQSISTEMA)
*!*			DO MENS WITH 'Arquivo de instalação do sistema não foi encontrado.'
*!*			RETURN
*!*		ENDIF

	* CONFIGURAÇÕES DE LOGOTIPO
	IF goAPLICATIVO.LOGOMULTIEMPRESA
		LOCAL lcLOGOREP AS String
		lcLOGOREP = goAPLICATIVO.LOGOTIPO
		
		* VERIFICA SE EXISTE CONFIGURAÇÃO DE LOGOTIPO POR EMPRESA
		IF NOT EMPTY(goAPLICATIVO.EMPLOGO)
			* LOCALIZA ARQUIVO DA EMPRESA
			lcLOGOREP = goAPLICATIVO.LOGOCAMINHO(goAPLICATIVO.EMPLOGO)
		ENDIF
		
		* VERIFICA SE FILTRO DE EMPRESA UTILIZA APENAS UMA EMPRESA
		IF NOT EMPTY(goAPLICATIVO.EMPFILTRO)
			LOCAL lcSTATUS AS String
			lcSTATUS = STREXTRACT(goAPLICATIVO.EMPFILTRO,'(',')')
			lcSTATUS = STRTRAN(lcSTATUS,' ','')
			lcSTATUS = STRTRAN(lcSTATUS,"'",'')
			
			* APENAS UMA EMPRESA CONFIGURADA
			IF lcSTATUS<>'ZZZZ'
				IF GETWORDCOUNT(lcSTATUS,',')=1
					lcLOGOREP = goAPLICATIVO.LOGOCAMINHO(lcSTATUS)
				ENDIF
			ENDIF
		ENDIF
		
		* SE IMAGEM NÃO EXISTE, USA DEFAULT DO SISTEMA
		IF NOT FILE(lcLOGOREP)
			lcLOGOREP = goAPLICATIVO.LOGOTIPO
		ENDIF		
		goAPLICATIVO.LOGOREPORT = lcLOGOREP 
	ENDIF
	
	IF goAPLICATIVO.WAWATIVO = 1
		lcNOMREP	= WAW_COMPARAR(FORCEEXT(tcARQLIS,'FRT'))
		lcNOMREP	= WAW_COMPARAR(FORCEEXT(tcARQLIS,'FRX'))
		IF EMPTY(lcNOMREP)
			RETURN
		ENDIF
	ENDIF

	* MONTA CURSOR RELAT NO PADRÃO DE IMPRESSÃO
	DO MONTARRELAT WITH tcARQLIS, tcNOMLIS
	
	* LIMPA CONFIGURAÇÃO DE LOGOTIPO POR EMPRESA
	IF goAPLICATIVO.LOGOMULTIEMPRESA AND NOT EMPTY(goAPLICATIVO.EMPLOGO)
		goAPLICATIVO.EMPLOGO=''
	ENDIF
	
	IF NOT EMPTY(lcA4VOLIMP)
		SELE &lcA4VOLIMP
		IF lnR4VOLIMP > 0
			GO lnR4VOLIMP
		ENDIF
	ENDIF

	IF TYPE('tcCONDIC1')<>'C'
		tcCONDIC1 = ''
	ENDIF
	
	* IMPRESSÃO DIRETA (SEM EXIBIR TELA DE IMPRESSÃO DA PLATAFORMA (23/12/2009)
	IF tlOCULTAR
		* OPÇÃO DO SYSTEM_IMPRIMIR (NÃO ABRE TELA DE CONFIRMAÇÃO QUANDO poIMPRESSAO.DS_IMPRESSAODIRETA = 'S')
		IF TYPE('poIMPRESSAO') <> 'O'
			PRIVATE poIMPRESSAO AS Object
			poIMPRESSAO = CREATEOBJECT('EMPTY')
		ENDIF
		=ADDPROPERTY(poIMPRESSAO,'DS_IMPRESSAODIRETA','S')
		
		* IMPRESSORA QUE SERA UTILIZADA NA IMPRESSAO  (SOMENTE EM IMPRESSAO DIRETA)
		IF NOT EMPTY(ALLTRIM(tcIMPRESSORA))
			LOCAL llERROIMP AS Logical
			STORE .F. TO llERROIMP	
			TRY 
				SET PRINTER TO NAME (tcIMPRESSORA)
			CATCH
				llERROIMP = .T.
			ENDTRY
			IF llERROIMP
				DO MENS WITH 'Erro de conectividade com a impressora.'+CHR(13)+;
							'Certifique-se de que a impressora está disponível e tente novamente'+CHR(13)+;
							'Impressora : '+ ALLTRIM(UPPER(tcIMPRESSORA)),1
			ENDIF
		ENDIF
	ENDIF	
	
	* VERIFICA SE CONTÉM DADOS SIGILOS NA IMPRESSÃO ADD(31/08/2020)
	IF NOT tlOCULTAR AND goAPLICATIVO.LGPD > 0
		LOCAL lnSENSIVEL AS Integer
		LOCAL luRETURNLGPD AS Logical
		STORE 0 TO lnSENSIVEL
		
		* VERIFICANDO A ROTINA
		=PESQUISASQL('SELECT COALESCE(TG_LGPDSENSIVEL, 0) AS TG_LGPDSENSIVEL FROM TS_MODULOS WHERE DS_ROTINA = ' + XX(toFORM.Name), 'TMPROT')
		
		SELE TMPROT
		IF TMPROT.TG_LGPDSENSIVEL = 0
			IF NOT OCCURS('GERAL', tcARQLIS) = 0
				* VERIFICANDO SE O CURSOR POSSUI CAMPOS SIGILOSOS
				lnSENSIVEL = VERIFCAMPOSSIGILOSOS(goAPLICATIVO.REPORTALIAS)
			ELSE
				* VERIFICANDO SE O REPORTS ESTÁ CADASTRADO COMO SENSIVEL
				=PESQUISASQL('SELECT * FROM TS_REPORTSLGPD WHERE DS_FILENAME = ' + XX(tcARQLIS), 'TMPREP')
				SELE TMPREP
				IF NOT EOF()
					lnSENSIVEL = 2
				ENDIF
			ENDIF
		ELSE
			* CASO ESTEJA COMO 1, A ROTINA CONTEM DADOS SENSIVEIS.
			lnSENSIVEL = IIF(TMPROT.TG_LGPDSENSIVEL = 1, 2, 1)
		ENDIF
				
		IF lnSENSIVEL = 2
			* AVISO DE REPORTS SENSIVEL, O USUÁRIO ESCOLHE SE QUER PROSSEGUIR (SE TIVER PERMISSÃO)
			DO FORM SYSTEM_AVISOIMPRESSAO WITH tcARQLIS, tcNOMLIS TO luRETURNLGPD
			
			IF NOT luRETURNLGPD
				RETURN(.F.)
			ENDIF 
		ENDIF
		
		SELE &lcA4VOLIMP
	ENDIF
	
	DO FORM SYSTEM_IMPRIMIR WITH tcOUTROS, toFORM
	IF USED('RELAT') 
		USE IN RELAT
	ENDIF

	* RETORNA AS CONFIGURAÇÕES DE IMPRESSAO
	SET PRINTER TO DEFAULT
	
RETURN

PROC MONTARRELAT
****************
LPARAMETERS tcARQLIS, tcNOMLIS
	IF TYPE('tcARQLIS')<>'C'
		tcARQLIS=' '
	ENDIF

	IF TYPE('tcNOMLIS')<>'C'
		tcNOMLIS=' '
	ENDIF

*!*		IF NOT USED('SISTEMA')
*!*			USE (goAPLICATIVO.ARQSISTEMA) ALIAS SISTEMA IN 0
*!*		ENDIF
	
	LOCAL lcALIASREPORT AS String
	STORE '' TO lcALIASREPORT
	
	* ALIAS DO REPORT
	IF goAPLICATIVO.ALIASREPORT = 1
		=PESQUISASQL('SELECT DS_ALIASREPORT FROM TS_IMPRESSOES WHERE DS_REPORT='+XX(tcARQLIS),'TMPSYSALIASREPORT')
		SELE TMPSYSALIASREPORT
		GO TOP
		IF NOT EMPTY(TMPSYSALIASREPORT.DS_ALIASREPORT)
			lcALIASREPORT = ALLTRIM(TMPSYSALIASREPORT.DS_ALIASREPORT)+'  '
		ENDIF
		IF USED('TMPSYSALIASREPORT')
			USE IN TMPSYSALIASREPORT
		ENDIF
	ENDIF
	
	LOCAL lcTITULO, lcEMPRESA AS String
	STORE '' TO lcTITULO, lcEMPRESA

	CREATE CURSOR RELAT ;
		(SISTEMA C(60), EMPRESA C(60), RELATORIO C(60), NOMREPO C(30), OBSCAB1 C(220), OBSCAB2 C(220),;
		 OBSREL1  C(220), OBSREL2  C(220), OBSREL3  C(220), OBSREL4  C(220), OBSREL5  C(220), ;
		 OBSREL6  C(220), OBSREL7  C(220), OBSREL8  C(220), OBSREL9  C(220), OBSREL10 C(220), ;
		 OBSREL11 C(220), OBSREL12 C(220), OBSREL13 C(220), OBSREL14 C(220), OBSREL15 C(220), ;
		 RODAPE M(10))
	SELECT RELAT
	APPEND BLANK
	M.NOMREPO	= lcALIASREPORT+tcARQLIS
	M.RELATORIO	= tcNOMLIS
	M.SISTEMA	= goAPLICATIVO.NOMEPROGRAMA + ' - ' + goAPLICATIVO.SISTEMA
	M.EMPRESA	= goAPLICATIVO.EMPRESA
		 
	* NOME DA EMPRESA CONFORME LOGO MULTIEMPRESA
	IF NOT EMPTY(goAPLICATIVO.EMPLOGO)
		* BUSCA EMPRESA
		lcCOMANDO = 'SELECT * FROM TB_EMPRESAS WHERE PK_ID = ' + XX(goAPLICATIVO.EMPLOGO)
		=PESQUISASQL(lcCOMANDO,'TMPMONTAEMP')
		SELE TMPMONTAEMP
		IF NOT EOF() AND TYPE('TMPMONTAEMP.DS_NOME') = 'C' AND NOT EMPTY(ALLTRIM(TMPMONTAEMP.DS_NOME))
			M.EMPRESA = ALLTRIM(TMPMONTAEMP.DS_NOME)
		ENDIF
		IF USED('TMPMONTAEMP')
			USE IN TMPMONTAEMP
		ENDIF
	ENDIF
	
	M.RODAPE	= RETORNASET('IMPRESSAO.RODAPE','C',1)
	SELE RELAT
	GATHER MEMVAR MEMO

RETURN

PROC SALVARCOMO
***************
PARAMETERS tcNOMEREPO, tcEXTENSAO, tcCONDICAO, tcNOMERESU, tcROTINA, tcSENHA
	* 1 = NOME DO REPORT (OBRIGATÓRIO)
	* 2 = EXTENSÃO DO ARQUIVO (OBRIGATÓRIO)
	* 3 = CONDICÕES DE IMPRESSÃO FOR/NEXT/WHILE/SUMARY/ETC.. (OPCIONAL)
	* 4 = PATH + NOME DO ARQUIVO DE RESULTADO (OPCIONAL)
	* 5 = RECEBE O NOME DA ROTINA (UTILIZADO SOMENTE PARA GRAVAÇÃO DE LOG)

	IF TYPE('tcNOMEREPO') <> 'C'
		DO MENS WITH 'Nenhum relatório escolhido!'
		RETURN
	ENDIF
	IF TYPE('tcEXTENSAO') <> 'C'
		DO MENS WITH 'Tipo de arquivo não especificado'
		RETURN
	ENDIF
	IF NOT tcEXTENSAO $ ',DOC,XLS,PDF,HTML,MHT,TXT,RTF,JPG,GIF,PNG,BMP,TIFF,'
		DO MENS WITH 'Tipo de arquivo desconhecido: ' + tcEXTENSAO
		RETURN
	ENDIF
	IF TYPE('tcCONDICAO') <> 'C'
		tcCONDICAO = ''
	ENDIF
	IF TYPE('tcNOMEARQ') <> 'C'
		tcNOMEARQ = ''
	ENDIF
	IF TYPE('tcROTINA') <> 'C'
		tcROTINA = ''
	ENDIF
	IF TYPE('tcSENHA') <> 'C'
		tcSENHA = ''
	ENDIF
	LOCAL llINIBIR AS Logical
	llINIBIR = .F.
	IF TYPE('pcMOSTRA') = 'C'
		IF pcMOSTRA = 'N'
			llINIBIR = .T.
		ENDIF
	ENDIF
	
	LOCAL lcA4VOLIMP AS String
	lcA4VOLIMP = ALIAS()
	* CARREGAR CURSOR DE IMPRESSÃO, SE O MESMO NÃO FOI CARREGADO
	IF NOT USED('RELAT')
		DO MONTARRELAT WITH tcNOMEREPO
	ENDIF
	IF NOT EMPTY(lcA4VOLIMP)
		SELE (lcA4VOLIMP)
	ENDIF
	
	* PARAMETRIZAÇÃO DA LIVRARIA PARA SALVAR ARQUIVO
	* 1 (c) - ARQUIVO DESTINO
	* 2 (c) - DIRETÓRIO TEMPORÁRIO
	* 3 (l) - ABRE DOCUMENTO APÓS GERADO
	* 4 (c) - CODEPAGE
	* 5 (l) - SILENCIO (SE .T. NÃO MOSTRA ANDAMENTO [EM INGLÊS])
	* 6 (l) - NOVA SESSÃO DO PROGRAMA DESTINO (EX. WORD)
	* 7 (c) - EXTENSÕES POSSÍVEIS DA LIVRARIA (DOC, PDF, HTML, MHT, RTF, XLS, CNT, XML)
	IF NOT EMPTY(tcNOMERESU)
	
		* VERIFICA SE O ARQUIVO JÁ EXISTE
		IF FILE(tcNOMERESU)
			* TENTA DELETAR O ARQUIVO SE JÁ EXISTIR
			DELETE FILE (tcNOMERESU)
			
			* SE MESMO APÓS TENTAR DELETAR ELE AINDA EXITIR, ADICIONA UM COMPLEMENTO RANDÔMICO AO NOME PARA EVITAR PROBLEMAS
			IF FILE(tcNOMERESU)
				tcNOMERESU = ADDBS(ALLTRIM(JUSTPATH(tcNOMERESU))) + ALLTRIM(JUSTSTEM(tcNOMERESU)) + '_' + SYS(3) + '.' + ALLTRIM(JUSTEXT(tcNOMERESU))
			ENDIF
		ENDIF
		
		lcNOMEARQUIVO = tcNOMERESU
	ELSE
		IF DIRECTORY(goAPLICATIVO.PATHTEMP)
			lcNOMEARQUIVO = goAPLICATIVO.PATHTEMP+'RPT'+SYS(3)+'.'+tcEXTENSAO
		ELSE
			lcNOMEARQUIVO = PUTFILE('Salvar Como:',SYS(3),tcEXTENSAO)
		ENDIF
	ENDIF
	IF EMPTY(lcNOMEARQUIVO)
		DO MENS WITH 'Nenhum nome escolhido!'
		RETURN
	ENDIF
	* CASO ESTEJA PASSANDO O CAMINHO COMPLETO
	IF NOT EMPTY(JUSTPATH(lcNOMEARQUIVO))
		lcNOMEARQUIVO = ALLTRIM(JUSTPATH(lcNOMEARQUIVO)  + '\' + CHRTRAN(JUSTSTEM(lcNOMEARQUIVO),'\/:*?"<>|','') + '.' + JUSTEXT(lcNOMEARQUIVO))
	ELSE
		lcNOMEARQUIVO = CHRTRAN(ALLTRIM(lcNOMEARQUIVO),'\/:*?"<>|','')
	ENDIF

	* CONVERTENDO REPORT
	* 1 (c) - NOME DO REPORT
	* 2 (c) - CLAUSULA [FOR]
	* 3 (l) - CLAUSULA [SUMMARY]
	* 4 (c) - SCOPO [NEXT, ETC....]
	* 5 (c) - CLAUSULA [WHILE]
	* 6 (l) - PLAIN (NÃO USUAL)
	LOCAL lcFOR, lcWHILE, lcNEXT, lcAUXCONDI AS String
	STORE '' TO lcFOR, lcWHILE, lcNEXT, lcAUXCONDI
	LOCAL llSUMMARY
	STORE .F. TO llSUMMARY

	IF NOT EMPTY(tcCONDICAO)
		lcAUXCONDI = tcCONDICAO
		IF 'SUMMARY' $ UPPER(lcAUXCONDI)
			llSUMMARY	= .T.
			lcAUXCONDI	= STRTRAN(lcAUXCONDI,'SUMMARY','')
		ENDIF
		IF 'FOR' $ UPPER(lcAUXCONDI)
			lcAUXCONDI	= STRTRAN(lcAUXCONDI,'FOR','')
			lcFOR		= ALLTRIM(lcAUXCONDI)
		ENDIF
		IF 'NEXT' $ UPPER(lcAUXCONDI)
			lcAUXCONDI	= STRTRAN(lcAUXCONDI,'NEXT','')
			lcNEXT		= ALLTRIM(lcAUXCONDI)
		ENDIF
		IF 'WHILE' $ UPPER(lcAUXCONDI)
			lcAUXCONDI	= STRTRAN(lcAUXCONDI,'WHILE','')
			lcWHILE		= ALLTRIM(lcAUXCONDI)
		ENDIF
	ENDIF

	lcREPORT = 'REPORTS\'+ALLTRIM(tcNOMEREPO)

	* É BASEADO NO VOLPE PADRÃO E NÃO EXISTE REPORT ENTÃO É NECESSÁRIO PEGAR DA PASTA DO VOLPE PADRÃO
	IF goAPLICATIVO.TESTE AND goAPLICATIVO.VOLPEPADRAO = 1 AND NOT FILE(lcREPORT+'.FRX')
		lcREPORT = goAPLICATIVO.PATHVOLPEPADRAO + 'REPORTS\'+ALLTRIM(tcNOMEREPO)
	ENDIF

	* VOLPEWAW É NECESSÁRIO BAIXAR O REPORT CASO SEJA DIFERENTE
	IF goAPLICATIVO.WAWATIVO = 1
		=WAW_COMPARAR(FORCEEXT(tcNOMEREPO,'FRT'))
	ENDIF

	IF NOT FILE(lcREPORT+'.FRX')
		DO MENS WITH 'Arquivo de impressão não encontrado!'
		RETURN
	ENDIF

	DO ESPERANDO WITH 'Gerando arquivo...'
	
	* GRAVA LOG DE GERAÇÃO DE ARQUIVO	 
	DO GRAVALOG WITH 'I', '','SYSTEM', 'ARQ: ' + tcEXTENSAO, tcROTINA
	
	* VERIFICA SE É PARA IDENTIFICAR O PK_ID (4 ÚLTIMO DÍGITOS SOMENTE) DO LOG NO RODAPÉ DO REPORT
	IF RETORNASET('AUDITORIA.LOGARQUERYS','C',1) = 'ON' AND USED('RELAT')
		* BUSCA ÚLTIMO ID GRAVADO NA TS_LOGS
		PRIVATE lnIDENTITY AS Integer
		STORE 0 TO lnIDENTITY
		DO PEGAULTINC WITH 'TS_LOGS'
		
		SELE RELAT
		* PROTEÇÃO PARA 2ª VEZ QUE VISUALA OU IMPRIME	
		* VERFICA SE JÁ EXISTE UM ID NOS ÚLTIMOS 4 DIGITOS E REMOVE ANTES DE ADICIONAR NOVAMENTE
		IF VAL(RIGHT(ALLTRIM(NOMREPO),4)) > 0
			REPLACE NOMREPO WITH LEFT(ALLTRIM(NOMREPO),LEN(ALLTRIM(NOMREPO))-4)
		ENDIF
		
		* ATUALIZA CAMPO DO RODAPÉ DO REPORT
		REPLACE NOMREPO	WITH ALLTRIM(ALLTRIM(NOMREPO) + PADL(RIGHT(TRANSFORM(lnIDENTITY),4),4,'0'))
	ENDIF
	
	SELE &lcA4VOLIMP
	
	IF tcEXTENSAO $ ',JPG,GIF,PNG,BMP,TIFF,'

		LOCAL loXFF AS Object
		LOCAL lnXI AS Integer
		LOCAL lcAUX AS String
		STORE 0 TO lnXI
		STORE '' TO lcAUX

		* TRATAMENTO PARA SALVAR REPORT EM IMAGEM
		loXFRX		= EVALUATE('XFRX("XFRX#INIT")')
		lnXFRXOK	= loXFRX.SetParams(,,,,,,'XFF')
		IF lnXFRXOK = 0
			loXFRX.ProcessReport(lcREPORT, lcFOR, llSUMMARY, lcNEXT, lcWHILE)

			loXFF	= loXFRX.FINALIZE()
			FOR lnXI = 1 TO loXFF.PAGECOUNT
				lcAUX	= STRTRAN( lcNOMEARQUIVO,'.'+tcEXTENSAO,'' ) + STRZERO(lnXI,4) + '.' + tcEXTENSAO
				IF lnXI = loXFF.PAGECOUNT
					lcAUX	= lcNOMEARQUIVO
				ENDIF
				loXFF.SavePicture(lcAUX, tcEXTENSAO, lnXI, lnXI, 24, 80)
			ENDFOR

			IF NOT EMPTY(lcAUX) AND NOT llINIBIR
				DO STARTAFILE WITH lcAUX
			ENDIF
		ENDIF
	ELSE
		* SALVANDO NOS DEMAIS FORMATOS
		loXFRX		= EVALUATE('XFRX("XFRX#LISTENER")')
		* CRIANDO PDF COM SENHA
		IF tcEXTENSAO == 'PDF'
			lnXFRXOK    = loXFRX.setPermissions(.t.,.f.,.t.,.t.,.t.,.t.,.f.,.f.)
			*setPermissions(m.tlPrintDocument, m.tlModifyDocument, ;
			*               m.tlCopyTextAndGraphics, m.tlAddOrModifyAnnotations,;
			*               m.tlFillFormFields, m.tlExtractTextAndGraphics, ;
			*               m.tlAssembleDocument, m.tlPrintDocumentInLow)
		ENDIF
		IF NOT EMPTY(tcSENHA) AND tcEXTENSAO == 'PDF'
			lnXFRXOK    = loXFRX.setPasswords(,tcSENHA)
        ENDIF
		lnXFRXOK	= loXFRX.SetParams(lcNOMEARQUIVO,goAPLICATIVO.PATHTEMP,llINIBIR,,.T.,.T.,IIF(tcEXTENSAO='TXT','PLAIN',tcEXTENSAO))
		IF lnXFRXOK < 0
			DO MENS WITH 'Problemas ao salvar arquivo na pasta: '+goAPLICATIVO.PATHTEMP + CHR(13) + '(XFRX-ERRO No.:' + XX(lnXFRXOK) + ').' + CHR(13) + CHR(10) + loXFRX.ErrorMessage(lnXFRXOK)
			RETURN
		ENDIF
		IF tcEXTENSAO = 'PDF'
			loXFRX.setEmbeddingType(3)
		ENDIF

		REPORT FORM &lcREPORT &tcCONDICAO OBJECT loXFRX
		WAIT CLEAR
		
		DO ESPERANDO WITH 'Abrindo arquivo...'
		loXFRX.FINALIZE()
	ENDIF
	DO LIMPARANTIGOS
	WAIT CLEAR

RETURN

PROC LIMPARANTIGOS
******************
	LOCAL ARRAY laARQS[1]
	LOCAL lnQTDARQS, lnXI AS Integer
	LOCAL lcARQUIVO AS String
	LOCAL ldDT_ARQUIVO AS Date
	STORE 0 TO lnQTDARQS, laARQS
	STORE '' TO lcARQUIVO
	STORE {} TO ldDT_ARQUIVO

	lnQTDARQS	= ADIR(laARQS,goAPLICATIVO.PATHTEMP+'RPT*.*')
	FOR lnXI = 1 TO lnQTDARQS
		lcARQUIVO		= laARQS[lnXI,1]
		ldDT_ARQUIVO	= laARQS[lnXI,3]

		IF ldDT_ARQUIVO < DATE()
			IF FILE(lcARQUIVO)
				DELETE FILE (lcARQUIVO)
				IF FILE(lcARQUIVO)
					DELETE FILE (lcARQUIVO)
				ENDIF
			ENDIF
		ENDIF
	ENDFOR
RETURN

FUNC D2SQL
**********
LPARAMETERS tdENTRA, tcMODO
* PARAMETRO1= DATA A SER TRANSFORMADA (OU STRING)
* PARAMETRO2= MODO (DATA/STRING)
* ONDE: DATA=MONTA A STRING COM A DATA JA CONVERTIDA, EX: CONVERT(DATETIME,20/11/2004,103)
*       STRING=MONTA UMA STRING A SER TRATADA PELO SERVIDOR SQL, EX: CONVERT(DATETIME,CAMPO,103)
*              (ENVIAR O NOME DO CAMPO PARA A CONDIÇÃO)
	IF TYPE('tcMODO') <> 'C'
		tcMODO = 'DATA'
	ENDIF
	IF tcMODO = 'STRING'
		IF TYPE('tdENTRA') <> 'C'
			RETURN('')
		ENDIF
	ELSE
		IF NOT TYPE('tdENTRA') $ 'DT'
			tdENTRA = {}
		ENDIF
	ENDIF
	LOCAL luSAI
	luSAI = 'null'
	IF !EMPTY(tdENTRA)
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS' &&&  LINHA ALTERADA  &&&
				*data entre aspas no formato aaaammdd
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= 'NOW()'
*!*						CASE tcMODO = 'STRING'
*!*							luSAI	= "DATE_FORMAT("+tdENTRA+",'%M/%D/%Y')"
					OTHERWISE
						LOCAL lcHHMMSS AS STRING
						lcHHMMSS = TTOC(tdENTRA,2)
						*datahora entre aspas no formato aaaammdd
						lcHHMMSS = SUBSTR(lcHHMMSS,1,2)+':'+SUBSTR(lcHHMMSS,4,2)+':'+SUBSTR(lcHHMMSS,7,2)
						luSAI = "STR_TO_DATE('"+DTOS(tdENTRA)+' ' +lcHHMMSS+"','%Y%m%d %T')"
				ENDCASE
			CASE goCONEXAO.BANCO = 'POS'
				*data entre aspas no formato aaaammdd
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= "NOW()"
					CASE tcMODO = 'STRING'
						luSAI	= "TO_CHAR("+tdENTRA+",'MM/DD/YYYY')"
					OTHERWISE
						LOCAL lcHHMMSS AS STRING
						lcHHMMSS = TTOC(tdENTRA,2)
						IF TYPE('tdENTRA')='D'
							*data entre aspas no formato aaaammdd
							luSAI = "TO_DATE('"+DTOS(tdENTRA)+"','YYYYMMDD')"
						ELSE
							*datahora entre aspas no formato aaaammdd
							lcHHMMSS = SUBSTR(lcHHMMSS,1,2)+':'+SUBSTR(lcHHMMSS,4,2)+':'+SUBSTR(lcHHMMSS,7,2)
							luSAI = "TO_TIMESTAMP('"+DTOS(tdENTRA)+lcHHMMSS+"','YYYYMMDDHH24:MI:SS')"
						ENDIF

				ENDCASE
			CASE goCONEXAO.BANCO = 'ORA'
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= 'SYSDATE'
					CASE tcMODO = 'STRING'
						luSAI = "TO_CHAR("+tdENTRA+",'DD/MM/YYYY')"
					OTHERWISE
						LOCAL lcHHMMSS AS STRING
						lcHHMMSS = TTOC(tdENTRA,2)
						IF TYPE('tdENTRA')='D'
							*data entre aspas no formato aaaammdd
							luSAI = "TO_DATE('"+DTOS(tdENTRA)+"','YYYYMMDD')"
						ELSE
							*datahora entre aspas no formato aaaammdd
							lcHHMMSS = SUBSTR(lcHHMMSS,1,2)+SUBSTR(lcHHMMSS,4,2)+SUBSTR(lcHHMMSS,7,2)
							luSAI = "TO_DATE('"+DTOS(tdENTRA)+lcHHMMSS+"','YYYYMMDDHH24MISS')"
						ENDIF
				ENDCASE
			CASE goCONEXAO.BANCO = 'DBC'
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= "DATETIME()"
					CASE tcMODO = 'STRING'
						luSAI	= "DTOC(DATE())"
					OTHERWISE
						luSAI	= "'"+DTOS(tdENTRA)+"'"
				ENDCASE
			OTHERWISE
				*SQL SERVER
				*onde: convert(formato,conteudo,nro)
				*ex: convert(datetime,'25/08/2003',103)
				DO CASE
					CASE tcMODO = 'HOJE'
						IF GOAPLICATIVO.TIMEZONE == 'ON'
							luSAI	= 'DBO.GETDATEZONE()'
						ELSE
							luSAI	= 'GETDATE()'
						ENDIF
					CASE tcMODO = 'STRING'
						luSAI	= "convert(varchar,"+tdENTRA+",103)"
					OTHERWISE
						* MARTELANDO A DATA APENAS ACIMA DE 1800 E MENOR QUE 2079
						LOCAL lnANO, lnMES, lnDIA, lnHORA, lnMINUTO, lnSEGUNDO AS Integer
						LOCAL ldDATA AS Date
						lnANO	= YEAR(tdENTRA)
						lnMES	= MONTH(tdENTRA)
						lnDIA	= DAY(tdENTRA)
						IF lnANO < 1900
							lnANO	= 1900
						ENDIF
						
						* TRATAMENTO PARA DATA LIMITE DO DATETIME = 06/06/2079
						IF lnANO => 2079
							lnANO	= 2079					
							IF lnMES => 6
								lnMES = 6
								IF lnDIA > 6
									lnDIA = 6
								ENDIF
							ENDIF
						ENDIF
						
						IF TYPE('tdENTRA') = 'T'
							lnHORA		= HOUR(tdENTRA)
							lnMINUTO	= MINUTE(tdENTRA)
							lnSEGUNDO	= SEC(tdENTRA)
						ELSE
							STORE 0 TO lnHORA, lnMINUTO, lnSEGUNDO
						ENDIF
						ldDATA	= STRZERO(lnANO,4) + ;
									STRZERO(lnMES,2) + ;
									STRZERO(lnDIA,2) + ' ' + ;
									STRZERO(lnHORA,2) + ':' +;
									STRZERO(lnMINUTO,2) + ':' +;
									STRZERO(lnSEGUNDO,2)
						luSAI	= "convert(datetime,'"+ ldDATA +"',103)"
				ENDCASE
		ENDCASE
	ENDIF
RETURN(luSAI)

PROC GRAVALOG
*************
PARAMETERS tcACAOLOG, tuPK, tcTABELALOG, tcOBS, tcROTINA, tnSENSIVEL
	LOCAL lcCAMPOS, lcCONTEUDO, lcCOMANDO AS STRING
	LOCAL lnRESPSQL AS Integer
	
	IF TYPE('tnSENSIVEL')<>'N'
		tnSENSIVEL = 0
	ENDIF 
	
	lnRESPSQL = -1
	IF TYPE('tuPK')='N'
		tuPK = ALLTRIM(STR(tuPK))
	ENDIF
	*MONTA COMANDO DE INSERT NO LOG
	lcCAMPOS = "FK_USUARIO," + ;
				" DH_LOG,"+;
				" DS_ROTINA," + ;
				" TG_ACAO," + ;
				" DS_OBJETOPK," + ;
				" DS_TABELA," + ;
				" DS_OBS"
	lcCONTEUDO = XX(goCONEXAO.FK_USUARIO)+;
				", "+D2SQL(DATE(),'HOJE')+;
				", "+XX(UPPER(tcROTINA))+;
				", "+XX(tcACAOLOG) + ;
				", "+XX(tuPK) + ;
				", "+XX(tcTABELALOG) + ;
				", "+XX(tcOBS)
	
	IF goAPLICATIVO.LGPD > 0
		lcCAMPOS   = lcCAMPOS + ", TG_SENSIVEL"
		lcCONTEUDO = lcCONTEUDO  + ", " + XX(tnSENSIVEL)
	ENDIF 
	lcCOMANDO = 'INSERT INTO TS_LOGS ('+lcCAMPOS+') VALUES ('+lcCONTEUDO+')'

	lnRESPSQL = SQLEXEC(goCONEXAO.ALCA,lcCOMANDO)
	IF lnRESPSQL<0 
		*COMANDO NÃO FOI BEM SUCEDIDO (ERRO DE SINTAXE SQL)
		_CLIPTEXT = lcCOMANDO
		 DO MENS WITH 'Erro para incluir registro de log.'
		RETURN
	ENDIF
RETURN

PROC GRAVALOGPLUS
*************
PARAMETERS tcACAOLOG, tuPK, tcTABELALOG, tcOBS, tcROTINA, tcLOGPLUS, tcCLASSE, tcTIPO, tnSENSIVEL
	LOCAL lcCAMPOS, lcCONTEUDO, lcCOMANDO AS STRING
	LOCAL lnRESPSQL AS Integer

	lnRESPSQL = -1
	IF TYPE('tuPK')='N'
		tuPK = ALLTRIM(STR(tuPK))
	ENDIF
	IF TYPE('tnSENSIVEL')<>'N'
		tnSENSIVEL = 0
	ENDIF 
	
	*MONTA COMANDO DE INSERT NO LOG
	lcCAMPOS = "FK_USUARIO," + ;
				" DH_LOG,"+;
				" DS_ROTINA," + ;
				" TG_ACAO," + ;
				" DS_OBJETOPK," + ;
				" DS_TABELA," + ;
				" DS_OBS"
	lcCONTEUDO = XX(goCONEXAO.FK_USUARIO)+;
				", "+D2SQL(DATE(),'HOJE')+;
				", "+XX(UPPER(tcROTINA))+;
				", "+XX(tcACAOLOG) + ;
				", "+XX(tuPK) + ;
				", "+XX(tcTABELALOG) + ;
				", "+XX(tcOBS)

	IF goAPLICATIVO.LGPD > 0
		lcCAMPOS   = lcCAMPOS + ", TG_SENSIVEL"
		lcCONTEUDO = lcCONTEUDO  + ", " + XX(tnSENSIVEL)
	ENDIF 
	lcCOMANDO = 'INSERT INTO TS_LOGS ('+lcCAMPOS+') VALUES ('+lcCONTEUDO+')'
	lnRESPSQL = SQLEXEC(goCONEXAO.ALCA,lcCOMANDO)
	IF lnRESPSQL<0 
		*COMANDO NÃO FOI BEM SUCEDIDO (ERRO DE SINTAXE SQL)
		*_CLIPTEXT = lcCOMANDO
		 DO MENS WITH 'Erro para incluir registro de log.'
		RETURN
	ENDIF
	
	* PEGA ÚLTIMA ID PARA INCLUIR LOG PLUS
	PRIVATE lnIDENTITY AS Integer
	STORE 0 TO lnIDENTITY
	DO PEGAULTINC WITH 'TS_LOGS'
	
	IF lnIDENTITY > 0 
		*MONTA COMANDO DE INSERT NO LOGPLUS
		lcCAMPOS = "PK_ID," + ;
					" DS_LOG,"+;
					" TG_CLASSE," + ;
					" TG_TIPO"
		lcCONTEUDO = XX(lnIDENTITY)+;
					", "+XX(ALLTRIM(tcLOGPLUS))+;
					", "+XX(tcCLASSE) + ;
					", "+XX(tcTIPO)
		lcCOMANDO = 'INSERT INTO TS_LOGSPLUS ('+lcCAMPOS+') VALUES ('+lcCONTEUDO+')'
		lnRESPSQL = SQLEXEC(goCONEXAO.ALCA,lcCOMANDO)
		
		IF lnRESPSQL<0 
			*COMANDO NÃO FOI BEM SUCEDIDO (ERRO DE SINTAXE SQL)
			*_CLIPTEXT = lcCOMANDO
			DO MENS WITH 'Erro para incluir registro de log.'
			RETURN
		ENDIF
	ENDIF
	
RETURN

PROC LOGEXPORT_CLASSIFICAR
**************************
PARAMETERS tcCURSOR
	* A DESENVOLVER
	* FUNÇÃO QUE SERÁ RESPONSÁVEL POR RETORNAR O TIPO 
	RETURN('G')

ENDPROC


PROC LOGEXPORT_GRAVAR
*********************
PARAMETERS tcTABELALOG, tuPK, tcROTINA, tcTIPO, tnLINHAS, tnUSUAUTORIZOU, tcCLASSIFICACAO, tnGRAVARPLUS, tcLOGPLUS, tcCLASSEPLUS, tcTIPOPLUS, tnSENSIVEL
	LOCAL lcCAMPOS, lcCONTEUDO, lcCOMANDO, lcACAOLOG AS STRING
	LOCAL lnRESPSQL AS Integer

	IF TYPE('tcTABELALOG') <> 'C'
		tcTABELALOG = ''
	ENDIF

	IF TYPE('tcROTINA') <> 'C'
		tcROTINA = ''
	ENDIF
	
	IF TYPE('tcTIPO') <> 'C'
		tcTIPO = ''
	ENDIF
	
	IF TYPE('tnLINHAS') <> 'N'
		tnLINHAS = 0
	ENDIF
	
	IF TYPE('tcTIPO') <> 'C'
		tcTIPO = ''
	ENDIF
	
	IF TYPE('tcCLASSIFICACAO') <> 'C'
		tcCLASSIFICACAO = ''
	ENDIF
	
	IF TYPE('tnGRAVARPLUS') <> 'N'
		tnGRAVARPLUS = 0
	ENDIF 
	
	IF TYPE('tcLOGPLUS') <> 'C'
		tcLOGPLUS = ''
	ENDIF
	
	IF TYPE('tcCLASSEPLUS') <> 'C'
		tcCLASSEPLUS = ''
	ENDIF
	
	IF TYPE('tcTIPOPLUS') <> 'C'
		tcTIPOPLUS = ''
	ENDIF
	IF TYPE('tnSENSIVEL')<>'N'
		tnSENSIVEL = 0
	ENDIF 
	
	* PROTEÇÃO PARA CAMPO NUNCA ENTRAR VAZIO, CASO NÃO INFORMADO A EXPORTAÇÃO É DEFINIDA COMO "GERAL"
	IF EMPTY(tcCLASSIFICACAO)
		tcCLASSIFICACAO = 'G'
	ENDIF
		
	* TIPO DE EXPORTAÇÃO  - NÚMERO DE LINHAS
	LOCAL lcOBS AS String
	lcOBS = tcTIPO + ' - ' + ALLTRIM(TRANSFORM(tnLINHAS))
	
	* LOG SERA SEMPRE "E" - EXPORTAÇÃO
	lcACAOLOG = 'E'
	
	lnRESPSQL = -1
	IF TYPE('tuPK')='N'
		tuPK = ALLTRIM(STR(tuPK))
	ENDIF
	IF TYPE('tuPK') <> 'C'
		tuPK = ''
	ENDIF
	*MONTA COMANDO DE INSERT NO LOG
	lcCAMPOS = "FK_USUARIO," + ;
				" DH_LOG,"+;
				" DS_ROTINA," + ;
				" TG_ACAO," + ;
				" DS_OBJETOPK," + ;
				" DS_TABELA," + ; 
				" DS_OBS"
	lcCONTEUDO = XX(goCONEXAO.FK_USUARIO)+;
				", "+D2SQL(DATE(),'HOJE')+;
				", "+XX(UPPER(tcROTINA))+;
				", "+XX(lcACAOLOG) + ;
				", "+XX(tuPK) + ;
				", "+XX(tcTABELALOG) + ;
				", "+XX(lcOBS)
	
	IF goAPLICATIVO.LGPD > 0
		lcCAMPOS   = lcCAMPOS + ", TG_SENSIVEL"
		lcCONTEUDO = lcCONTEUDO  + ", " + XX(tnSENSIVEL)
	ENDIF 
	lcCOMANDO = 'INSERT INTO TS_LOGS ('+lcCAMPOS+') VALUES ('+lcCONTEUDO+')'
	
	lnRESPSQL = SQLEXEC(goCONEXAO.ALCA,lcCOMANDO)
	IF lnRESPSQL<0 
		*COMANDO NÃO FOI BEM SUCEDIDO (ERRO DE SINTAXE SQL)
		*_CLIPTEXT = lcCOMANDO
		 DO MENS WITH 'Erro para incluir registro de log de exportação.'
		RETURN
	ENDIF
	
	* PEGA ÚLTIMA ID PARA INCLUIR LOG DE EXPORTAÇÃO
	PRIVATE lnIDENTITY AS Integer
	STORE 0 TO lnIDENTITY
	DO PEGAULTINC WITH 'TS_LOGS'

	IF lnIDENTITY > 0 
		*MONTA COMANDO DE INSERT NA LOGEXPORT
		lcCAMPOS = "PK_ID," + ;
					" DS_ROTINA,"+;
					" DS_OPCAO,"+;
					" QT_LINHAS,"+;
					" TG_CLASSIFICACAO," + ;
					" FK_USUAUTORIZOU," + ;
					" FK_USUREVISAO," + ;
					" HX_ARQUIVO," + ;
					" TG_INATIVO," + ;
					" FK_OWNER," + ;
					" DH_INCLUSAO"
		lcCONTEUDO = XX(lnIDENTITY)+;
					", "+XX(UPPER(tcROTINA))+;
					", "+XX(ALLTRIM(tcTIPO))+;
					", "+XX(tnLINHAS) + ;
					", "+XX(tcCLASSIFICACAO) + ;
					", "+XX(tnUSUAUTORIZOU) + ;
					", "+XX(0) + ;
					", "+XX('') + ;
					", "+XX(0) + ;
					", "+XX(goCONEXAO.FK_USUARIO) + ;
					", "+D2SQL(DATE(),'HOJE')
		lcCOMANDO = 'INSERT INTO TS_LOGEXPORT ('+lcCAMPOS+') VALUES ('+lcCONTEUDO+')'
		lnRESPSQL = SQLEXEC(goCONEXAO.ALCA,lcCOMANDO)
		
		IF lnRESPSQL<0 
			*COMANDO NÃO FOI BEM SUCEDIDO (ERRO DE SINTAXE SQL)
			_CLIPTEXT = lcCOMANDO
			DO MENS WITH 'Erro para incluir registro de log detalhado de exportação.'
			RETURN
		ENDIF
	ENDIF
	
	IF tnGRAVARPLUS = 0
		RETURN 
	ENDIF 
	
	IF EMPTY(tcLOGPLUS) AND EMPTY(tcCLASSEPLUS) AND EMPTY(tcTIPO)
		RETURN
	ENDIF 	

	IF lnIDENTITY > 0  
		*MONTA COMANDO DE INSERT NO LOGPLUS
		lcCAMPOS = "PK_ID," + ;
					" DS_LOG,"+;
					" TG_CLASSE," + ;
					" TG_TIPO"
		lcCONTEUDO = XX(lnIDENTITY)+;
					", "+XX(ALLTRIM(tcLOGPLUS))+;
					", "+XX(tcCLASSEPLUS) + ;
					", "+XX(tcTIPOPLUS)
		lcCOMANDO = 'INSERT INTO TS_LOGSPLUS ('+lcCAMPOS+') VALUES ('+lcCONTEUDO+')'
		lnRESPSQL = SQLEXEC(goCONEXAO.ALCA,lcCOMANDO)
		
		IF lnRESPSQL<0 
			*COMANDO NÃO FOI BEM SUCEDIDO (ERRO DE SINTAXE SQL)
			*_CLIPTEXT = lcCOMANDO
			DO MENS WITH 'Erro para incluir registro de log.'
			RETURN
		ENDIF
	ENDIF
RETURN

FUNC STRZERO
************
LPARAMETERS tnVALOR,tnTAM
	LOCAL lcOUT AS STRING
	lcOUT = STR(tnVALOR,tnTAM)
	lcOUT = STRTRAN(lcOUT," ","0")
RETU(lcOUT)

FUNC XX
*******
*RETORNA STRING PRONTA PARA CONCATENAR C/ COMANDO-SQL
PARAMETERS tnENTRA, tcPICTURE
	IF TYPE('tcPICTURE') <> 'C'
		tcPICTURE	= ''
	ENDIF
	LOCAL lcSAI AS String
	lcSAI = 'NULL'
	IF NOT ISNULL(tnENTRA)
		IF TYPE('tnENTRA')='N'
			IF EMPTY(tcPICTURE)
				DO CASE
					CASE tnENTRA = INT(tnENTRA)
						tcPICTURE	= REPLICATE('9',20)
					CASE tnENTRA = ROUND(tnENTRA,2)
						tcPICTURE	= REPLICATE('9',20) + '.' + REPLICATE('9',2)
					OTHERWISE
						tcPICTURE	= REPLICATE('9',20) + '.' + REPLICATE('9',8)
				ENDCASE
			ENDIF
			*lcSAI = TRANSFORM(tnENTRA,tcPICTURE) &&DESABILITADO EM 16/02/2012 POR SOLICITAÇÃO DO ROGÉRIO
			lcSAI = TRANSFORM(tnENTRA)
			lcSAI = STRTRAN(lcSAI,',','.')
			lcSAI = ALLTRIM(lcSAI)
		ENDIF
		IF TYPE('tnENTRA')='C'
			tnENTRA = STRTRAN(tnENTRA,"'","")
			lcSAI	= ALLTRIM(tnENTRA)
			IF EMPTY(lcSAI)
				lcSAI = " "
			ENDIF
			IF 'LIKE' $ tcPICTURE
				DO CASE
					CASE tcPICTURE = '%LIKE%'
						lcSAI = "%"+ALLTRIM(lcSAI)+"%"
					CASE tcPICTURE = 'LIKE%'
						lcSAI = ALLTRIM(lcSAI)+"%"
					CASE tcPICTURE = '%LIKE'
						lcSAI = "%"+ALLTRIM(lcSAI)
				ENDCASE
			ENDIF
			lcSAI = "'"+lcSAI+"'"
		ENDIF
		IF TYPE('tnENTRA')='D' OR TYPE('tnENTRA')='T'
			lcSAI = D2SQL(tnENTRA)
		ENDIF
		IF TYPE('tnENTRA')='L'
			IF tnENTRA
				lcSAI = '1'
			ELSE
				lcSAI = '0'
			ENDIF
		ENDIF
	ENDIF
RETURN(lcSAI)

FUNC EXECUTASQL
****************
PARAMETERS tcSINTAXE
	LOCAL lnSQLOK, lnRESP AS Integer
	LOCAL lcRESP AS String
	LOCAL ARRAY laERRO[1]
	IF goCONEXAO.ALCA<=0
		RETURN
	ENDIF
	* TRATAMENTOS ESPECIAIS DE SINTAXE
	DO CASE
		CASE goCONEXAO.BANCO = 'DBC'
			tcSINTAXE = TRATASQLFOX(tcSINTAXE)
		CASE goCONEXAO.BANCO = 'POS'
			tcSINTAXE = TRTSINPGSQL(tcSINTAXE)
			tcSINTAXE = TRTFUNPGSQL(tcSINTAXE)
		CASE goCONEXAO.BANCO = 'ORA'
			tcSINTAXE = TRATASQLORACLE(tcSINTAXE)
		CASE goCONEXAO.BANCO = 'MYS'
			tcSINTAXE = TRATASQLMYSQL(tcSINTAXE)
		OTHERWISE
			tcSINTAXE = TRATASQLMSSQL(tcSINTAXE)
	ENDCASE

	goCONEXAO.LASTCOMMAND   = tcSINTAXE
	goCONEXAO.LASTCURSOR    = ''
	
	* EXECUTA COMANDO NA BASE
	LOCAL lnSECINI, lnSECFIM AS Integer
	LOCAL ldDATETIME AS Datetime
	
	ldDATETIME 	= DATETIME()
	lnSECINI	= SECONDS()
	lnSQLOK		= SQLEXEC(goCONEXAO.ALCA,tcSINTAXE)
	lnSECFIM	= SECONDS()
	
	* LOG DE PEFORMANCE
	IF GOAPLICATIVO.LOGPERF = 1 AND lnSQLOK > 0
		* PROTEÇÃO PARA INSERT NAS TABELAS DE LOG
		IF tcSINTAXE = 'INSERT INTO LG_'
			LOGPERF_GRAVAR(ldDATETIME,lnSECFIM-lnSECINI,1,'EXEC',SUBSTR(tcSINTAXE,1,AT(' ',tcSINTAXE,3)-3))
		ELSE
			LOGPERF_GRAVAR(ldDATETIME,lnSECFIM-lnSECINI,1,'EXEC',tcSINTAXE)
		ENDIF
	ENDIF
	
	IF NOT goAPLICATIVO.TESTE AND lnSQLOK<0
		=AERROR(laERRO)
		* CASO SEJA ERRO DE CONEXÃO
		IF VERERROCONEXAO(laERRO[4], laERRO[5], laERRO[3])
			DO FORM SYSTEM_ERROCONEXAO
			* SE OPTOU POR RECONECTAR, TENTA REPETIR A QUERY
			lnSQLOK = REPETIRQUERY()
		ENDIF
	ENDIF
	goCONEXAO.LASTCOMMAND   = ''
	goCONEXAO.LASTCURSOR    = ''

	IF lnSQLOK<0
		=AERROR(laERRO)
		lcNUMERRO		= ALLTRIM(STR(laERRO(1)))
		lcERRO			= laERRO(3)
		lcODBCSTATE 	= NVL(laERRO[4],' ')
		lcNUMODBCSTATE	= ALLTRIM(STR(NVL(laERRO[5],0)))
		
		goCONEXAO.LASTERRORSQL = lcNUMERRO + ' - ' + lcERRO + ' (ODBC NUM: ' + lcNUMODBCSTATE + ' - ODBC STATE: ' + lcODBCSTATE + ')'

		IF NOT goAPLICATIVO.TESTE
			DO ROTERRO WITH 0-laERRO(1), lcERRO, SYS(16), 0
		ELSE
			lnRESP	= MESSAGEBOX('ERRO NO ACESSO À BASE DE DADOS: ' + CHR(13)+CHR(10)+;
									SYS(16)+CHR(13)+CHR(10)+;
									lcNUMERRO+CHR(13)+CHR(10)+;
									lcERRO,'AVISO: SQL-ERRO',48+2+256)
			IF lnRESP = 3
				_CLIPTEXT	= tcSINTAXE
				DEBUG
				SUSP
			ENDIF
			IF lnRESP = 4
				_CLIPTEXT = tcSINTAXE
			ENDIF
		ENDIF
	ELSE
		* MEDIDORES DE TRAFEGO
		LOCAL 		lnTRAFEGOVAI, lnTRAFEGOVEM AS Double
		STORE 0 TO	lnTRAFEGOVAI, lnTRAFEGOVEM 

		lnTRAFEGOVAI = LEN(tcSINTAXE)
		lnTRAFEGOVEM = 1
		
		goCONEXAO.QT_QUERYS 	= goCONEXAO.QT_QUERYS + 1 
		goCONEXAO.QT_TEMPO		= goCONEXAO.QT_TEMPO + lnSECFIM-lnSECINI
		goCONEXAO.QT_TRAFEGOVAI = goCONEXAO.QT_TRAFEGOVAI + lnTRAFEGOVAI
		goCONEXAO.QT_TRAFEGOVEM = goCONEXAO.QT_TRAFEGOVEM + lnTRAFEGOVEM

	
	ENDIF
RETURN(lnSQLOK)

PROC VALIDAR
************
	LPARAMETERS toCUROBJ, tcCOMANDO, tcPARAMETROS
	* PARAMETRO1 = OBJETO CORRENTE (USA VALUE, TAG)
	* PARAMETRO2 = COMANDO SELECT DE PESQUISA (OPCIONAL)
	* PARAMETRO3 = STRING (,NAOMENSAGEM,NAOEMPRESA,SIMINATIVO,)
	IF LASTKEY()=27
*!*			toCUROBJ.ResetToDefault('Value')
*!*			
*!*			* Necessário para forçar valor para branco devido ao ResetToDefault
*!*			toCUROBJ.Value = toCUROBJ.Value
		
		KEYBOARD "{END}"
		INKEY()
		RETURN(-1)
	ENDIF 
	IF TYPE('tcCOMANDO')<>'C'
		tcCOMANDO = ''
	ENDIF
	IF TYPE('tcPARAMETROS')<>'C'
		tcPARAMETROS = ''
	ENDIF
	tcPARAMETROS = UPPER(tcPARAMETROS)

	LOCAL lcCONDIEMP, lcEMPEXTRA AS String
	LOCAL lnFILTROEMP AS Integer
	STORE '' TO lcCONDIEMP
	STORE -1 TO lnFILTROEMP
	
	IF NOT 'NAOEMPRESA' $ tcPARAMETROS
		* FILTRO DE EMPRESA DO USUARIO
		lnFILTROEMP	= goAPLICATIVO.VFKEMPRESA(toCUROBJ.TAG)
		IF lnFILTROEMP > 0
			*lcCONDIEMP = goAPLICATIVO.EMPFILTRO
			lcEMPEXTRA = ALLTRIM(toCUROBJ.TAG)
			lcCONDIEMP = goAPLICATIVO.EMPFILTRO_COMEXTRA(lcEMPEXTRA)
			IF lnFILTROEMP=2
				* TEM FILTRO E É PELO PK_ID (TB_EMPRESAS)
				lcCONDIEMP = STRT(lcCONDIEMP,'FK_EMPRESA','PK_ID')
			ENDIF
			lcCONDIEMP	= ALLTRIM(toCUROBJ.TAG) + '.' + lcCONDIEMP
			lcCONDIEMP	= ' AND (' + lcCONDIEMP + ')'
		ENDIF
	ENDIF

	IF EMPTY(tcCOMANDO)
		IF EMPTY(toCUROBJ.TAG)
			DO MENS WITH 'Nenhuma tabela definida para pesquisa.'
			RETURN(-1)
		ENDIF
		tcCOMANDO = 'SELECT * '+;
					' FROM '+ALLTRIM(toCUROBJ.TAG)+;
					' WHERE PK_ID='+XX(toCUROBJ.VALUE) + lcCONDIEMP

	ENDIF
	=PESQUISASQL(tcCOMANDO,'TMPVALIDAR')
	LOCAL lcCUROBJ AS String 
	IF VARTYPE(toCUROBJ.VALUE) = 'D'
		lcCUROBJ = ALLTRIM(DTOC(toCUROBJ.VALUE))
	ELSE
		lcCUROBJ = XX(toCUROBJ.VALUE)
	ENDIF
	IF 'NAODUPLICAR' $ tcPARAMETROS
		IF RECCOUNT('TMPVALIDAR') > 0
			DO MENS WITH  lcCUROBJ + ' já cadastrado no registro '+;
								XX(TMPVALIDAR.PK_ID)			
			RETURN(0)
		ENDIF
		RETURN(1)
	ENDIF
	* DEIXAR PASSAR CAMPO VAZIO
	IF EMPTY(toCUROBJ.VALUE)
		RETURN(1)
	ENDIF
	SELE TMPVALIDAR
	IF EOF()
		IF 'NAOMENSAGEM' $ tcPARAMETROS
			* NÃO EXIBIR NENHUMA MENSAGEM
		ELSE
			* MENSAGEM PADRÃO
			DO MENS WITH 'Código inválido: '+lcCUROBJ
		ENDIF
		RETURN(0)
	ELSE
		IF TYPE('_SCREEN.ACTIVEFORM.myPERMITIRINATIVOS')='L' AND NOT _SCREEN.ACTIVEFORM.myPERMITIRINATIVOS
			IF TYPE('TMPVALIDAR.TG_INATIVO')='N'
				IF TMPVALIDAR.TG_INATIVO=1
					IF 'NAOMENSAGEM' $ tcPARAMETROS
						* NÃO EXIBIR NENHUMA MENSAGEM
					ELSE
						* MENSAGEM PADRÃO
						IF goAPLICATIVO.VALIDARINIT=0
							DO MENS WITH 'Este código não está mais ativo no sistema: '+lcCUROBJ
						ENDIF 
					ENDIF
					
					* PARAMETRO PARA PERMITIR COD. INATIVO
					IF NOT 'SIMINATIVO' $ tcPARAMETROS
						RETURN(0)
					ENDIF
				ENDIF
			ENDIF
		ENDIF
	ENDIF
RETURN(1)

PROC DELETAR
************
LPARAMETERS tcTABELA, tcALIAS

	IF TYPE('tcTABELA') <> 'C'
		DO MENS WITH 'Exclusão negada-(Tabela não informada)'
		RETURN(.F.)
	ENDIF
	IF EMPTY(tcTABELA)
		DO MENS WITH 'Exclusão negada-(Tabela não informada)'
		RETURN(.F.)
	ENDIF
	IF TYPE('tcALIAS') <> 'C'
		DO MENS WITH 'Exclusão negada-(Tabela não informada)'
		RETURN(.F.)
	ENDIF
	IF EMPTY(tcALIAS)
		DO MENS WITH 'Exclusão negada-(Tabela não informada)'
		RETURN(.F.)
	ENDIF
	SELE (tcALIAS)
	IF NOT TYPE('PK_ID') $ 'CN'
		DO MENS WITH 'Exclusão negada-(Pk ausente)'
		RETURN(.F.)
	ENDIF
	IF EMPTY(PK_ID)
		DO MENS WITH 'Exclusão negada-(Pk sem informação)'
		RETURN(.F.)
	ENDIF
	
	LOCAL lcCOMANDO, lcTABSQL, lcLETRA, lcLIXEIRA AS String
	LOCAL lnDELETOU, lnXI AS Integer
	LOCAL luPK
	
	STORE '' TO lcCOMANDO, lcTABSQL, lcLETRA

	FOR lnXI = 1 TO LEN(tcTABELA)
		lcLETRA = SUBSTR(tcTABELA,lnXI,1)
		IF EMPTY(lcLETRA)
			EXIT
		ENDIF
		lcTABSQL = lcTABSQL + lcLETRA
	ENDFOR

	luPK = PK_ID
	* LIXEIRA
	lcCOMANDO = "SELECT * FROM " + ALLTRIM(lcTABSQL) + ;
				" WHERE PK_ID="+XX(PK_ID)
	=PESQUISASQL(lcCOMANDO,'TMPSISDELETAR')

	* VERIFICA FECHAMENTO ANTES DE DELETAR
	lcCOMANDO = "VDELETAR("+XX(PK_ID)+", "+XX(lcTABSQL)+")"
	IF NOT EVALUATE(lcCOMANDO)
		DO MENS WITH goAPLICATIVO.MENSFECHADO
		RETURN(.F.)	
	ENDIF

	SELE TMPSISDELETAR
	lnDELETOU = ATUSQL( 'D', lcTABSQL )
	SELE TMPSISDELETAR
	IF TYPE('lnDELETOU') = TYPE('PK_ID')
		IF NOT EMPTY( lnDELETOU )
			* GRAVANDO LOG DA OPERAÇÃO
			* NO CASO DE FUNÇÕES QUE ESTÃO NO MENURAIZ A STACK DE PROCESSOS NÃO AS ARMAZENA
			LOCAL ARRAY laPROGRAMAS[1]
			LOCAL lnQTDPROGRAMAS, lnXI AS Integer
			LOCAL lcNOMEROTINA, lcLETRA AS String
			STORE '' TO lcNOMEROTINA, lcLETRA
			lnQTDPROGRAMAS = ASTACKINFO(laPROGRAMAS)
			FOR lnXI = 1 TO LEN(laPROGRAMAS[lnQTDPROGRAMAS-1,3])
				lcLETRA = SUBSTR(laPROGRAMAS[lnQTDPROGRAMAS-1,3],lnXI,1)
				IF lcLETRA = '.'
					EXIT
				ENDIF
				lcNOMEROTINA = lcNOMEROTINA + lcLETRA
			ENDFOR
			DO GRAVALOG WITH 'D', TMPSISDELETAR.PK_ID, lcTABSQL, '', lcNOMEROTINA
			DELETE

			* APAGANDO TEXTO ANEXO, SE TIVER
			IF TYPE('luPK') = 'C'
				luPK	= XX(luPK)
			ELSE
				luPK	= XX(STR(luPK),20)
			ENDIF
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				DELETE FROM TS_TEXTOS
				WHERE
					FK_ORIGEM = <<PK_ID>>
					AND DS_TABELA = <<TABELA>>
			ENDTEXT
			lcCOMANDO = STRTRAN(lcCOMANDO,'<<TABELA>>',XX(lcTABSQL))
			lcCOMANDO = STRTRAN(lcCOMANDO,'<<PK_ID>>',luPK)
			=EXECUTASQL(lcCOMANDO)

			* DELETANDO IMAGEM, SE TIVER
			LOCAL lcIMAGEMBD, lcSQL, lcARQUIVO, lcPK_ID AS String
			LOCAL llERRO AS Logical
			STORE .F. TO llERRO
			
			lcIMAGEMBD = ALLTRIM(RETORNASET('IMAGEM.BD','C',1))

			IF VARTYPE(lcIMAGEMBD) <> 'C'
				lcIMAGEMBD = 'OFF'
			ENDIF

			IF VARTYPE(PK_ID) = 'N'
				lcPK_ID = ALLTRIM(STR(PK_ID))
			ELSE
				lcPK_ID = ALLTRIM(PK_ID)
			ENDIF
			
			IF lcIMAGEMBD == 'ON'
			* IMAGEM GRAVADA DENTRO DO BANCO DE DADOS
				TEXT TO lcSQL NOSHOW PRETEXT 7
					SELECT
						PK_ID,
						DS_TABELA,
						FK_ORIGEM
					FROM
						TS_IMAGENS
					WHERE
						FK_ORIGEM = '[[FK_ORIGEM]]'
					AND
						DS_TABELA = '[[DS_TABELA]]'
				ENDTEXT
				lcSQL = STRTRAN(lcSQL,'[[FK_ORIGEM]]',lcPK_ID)
				lcSQL = STRTRAN(lcSQL,'[[DS_TABELA]]',lcTABSQL)
				PESQUISASQL(lcSQL,'TMPIMG')
				
				SELE TMPIMG
				GO TOP
				
				IF RECCOUNT() > 0
					SCAN WHILE NOT EOF()
						DO ATUSQL WITH 'D', 'TS_IMAGENS'
					ENDSCAN
				ENDIF
			ELSE
			* IMAGEM DENTRO DA PASTA DOCVIEW
				LOCAL ARRAY laDIR[1]
				LOCAL lnXI AS Integer
						
				=ADIR(laDIR, goAPLICATIVO.PATHDOCVIEW + 'GDI_' + ALLTRIM(lcTABSQL) + '_' + lcPK_ID + '_*')
				FOR	lnXI = 1 TO ALEN(laDIR,1)
					IF EMPTY(laDIR[lnXI,1])
						LOOP
					ENDIF
					lcARQUIVO = goAPLICATIVO.PATHDOCVIEW + laDIR[lnXI,1]
					IF FILE(lcARQUIVO)
						TRY 
							DELETE FILE(lcARQUIVO)
						CATCH
							llERRO = .T.
						ENDTRY
						
						IF llERRO
							DO MENS WITH 'Imagem do registro: ' + lcPK_ID + ' não pode ser deletada.'
						ENDIF
					ENDIF
				ENDFOR
			ENDIF
		ENDIF
	ELSE
		DO MENS  WITH 'Problemas ao deletar registro!'
		RETURN(.F.)
	ENDIF
RETURN(.T.)

PROC DESATIVAR
**************
LPARAMETERS tcTABELA, tuPK_ID
	IF TYPE('tcTABELA') <> 'C'
		DO MENS WITH 'Desativação negada-(Tabela não informada)'
		RETURN(.F.)
	ENDIF
	IF EMPTY(tcTABELA)
		DO MENS WITH 'Desativação negada-(Tabela não informada)'
		RETURN(.F.)
	ENDIF
	IF NOT TYPE('tuPK_ID') $ 'CN'
		DO MENS WITH 'Desativação negada-(Chave-id não informada)'
		RETURN(.F.)
	ENDIF
	IF EMPTY(tuPK_ID)
		DO MENS WITH 'Desativação negada-(Chaveid não informada)'
		RETURN(.F.)
	ENDIF
	
	LOCAL lcCOMANDO, lcTABSQL, lcLETRA, lcCPO AS String
	LOCAL lnXI, lnQTDFIL, lnTEMCPO, lnOPERACAO AS Integer
	LOCAL ARRAY laFIELDS[1]
	STORE '' TO lcCOMANDO, lcTABSQL, lcLETRA
	STORE 0  TO lnTEMCPO, lnXI, lnQTDFIL
	FOR lnXI = 1 TO LEN(tcTABELA)
		lcLETRA = SUBSTR(tcTABELA,lnXI,1)
		IF EMPTY(lcLETRA)
			EXIT
		ENDIF
		lcTABSQL = lcTABSQL + lcLETRA
	ENDFOR
	lcTABSQL	= ALLTRIM(lcTABSQL)

	* VERIFICANDO SE TEM O CAMPO DE [TG_INATIVO]
	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		SELECT
			*
		FROM
			[[TABELA]]
		WHERE
			PK_ID=[[PK_ID]]
	ENDTEXT
	lcCOMANDO	= STRTRAN( lcCOMANDO, '[[TABELA]]', lcTABSQL )
	lcCOMANDO	= STRTRAN( lcCOMANDO, '[[PK_ID]]', XX(tuPK_ID) )
	=PESQUISASQL(LCCOMANDO,'TMPDESATIVAR')
	lnTEMCPO = 0
	IF TYPE('TMPDESATIVAR.TG_INATIVO')='N' AND ;
		TYPE('TMPDESATIVAR.DH_ALTERACAO')='T'
		lnTEMCPO = 2
	ENDIF

	IF lnTEMCPO<>2
		DO MENS  WITH 'OPERAÇÃO NEGADA!'+CHR(13)+;
			'Esta informação não pode ser desativada no sistema.'+CHR(13)+;
			'(A funcionalidade ativar/desativar não está disponível nesta tabela)'
		RETURN(.F.)
	ENDIF

	* CONFIRMA DESATIVAÇÃO DO REGISTRO COM USUÁRIO
	LOCAL lnOPERACAO as Integer
	lnOPERACAO	= TMPDESATIVAR.TG_INATIVO
	IF NOT SIMOUNAO('Confirma '+IIF(lnOPERACAO=0,'des','')+'ativação do registro: '+XX(tuPK_ID)+'?','Desativar/ativar',2)
		RETURN(.F.)
	ENDIF

*!* o correto seria apenas verificar se o módulo ref.tabela está fechado na respectiva data	
*!*		* VERIFICA FECHAMENTO ANTES DE DESATIVAR
*!*		lcCOMANDO = "VDELETAR("+XX(tuPK_ID)+", "+XX(lcTABSQL)+")"
*!*		IF NOT EVALUATE(lcCOMANDO)
*!*			DO MENS WITH goAPLICATIVO.MENSFECHADO
*!*			RETURN(.F.)	
*!*		ENDIF

	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		UPDATE
			[[TABELA]]
		SET
			TG_INATIVO=[[TG_OPERACAO]],
			DH_ALTERACAO=[[DH_ALTERACAO]]
		WHERE
			PK_ID=[[PK_ID]]
	ENDTEXT
	lcCOMANDO	= STRTRAN( lcCOMANDO, '[[TABELA]]', lcTABSQL )
	lcCOMANDO	= STRTRAN( lcCOMANDO, '[[TG_OPERACAO]]', XX(IIF(lnOPERACAO=1,0,1)) )
	lcCOMANDO	= STRTRAN( lcCOMANDO, '[[DH_ALTERACAO]]', XX(DATASERVER()) )
	lcCOMANDO	= STRTRAN( lcCOMANDO, '[[PK_ID]]', XX(tuPK_ID) )
	=EXECUTASQL(lcCOMANDO)

	* GRAVANDO LOG DA OPERAÇÃO
	* NO CASO DE FUNÇÕES QUE ESTÃO NO MENURAIZ A STACK DE PROCESSOS NÃO AS ARMAZENA
	LOCAL ARRAY laPROGRAMAS[1]
	LOCAL lnQTDPROGRAMAS, lnXI AS Integer
	LOCAL lcNOMEROTINA, lcLETRA AS String
	STORE '' TO lcNOMEROTINA, lcLETRA
	lnQTDPROGRAMAS = ASTACKINFO(laPROGRAMAS)
	FOR lnXI = 1 TO LEN(laPROGRAMAS[lnQTDPROGRAMAS-1,3])
		lcLETRA = SUBSTR(laPROGRAMAS[lnQTDPROGRAMAS-1,3],lnXI,1)
		IF lcLETRA = '.'
			EXIT
		ENDIF
		lcNOMEROTINA = lcNOMEROTINA + lcLETRA
	ENDFOR
	DO GRAVALOG WITH 'I', tuPK_ID, lcTABSQL, IIF(lnOPERACAO=0,'DES','')+'ATIVOU', lcNOMEROTINA
RETURN(.T.)

FUNC VIRGULAR
*************
PARAMETERS tcVIRGULAR
	IF TYPE('tcVIRGULAR')='N'
		tcVIRGULAR = ALLTRIM(STR(tcVIRGULAR))
	ENDIF
	LOCAL lcVIRGULAR as String
	lcVIRGULAR = ','+tcVIRGULAR+','
RETURN(lcvirgular)

FUNC FNOMDIA
************
LPARAMETERS tdDAY AS Date
	IF NOT TYPE('tdDAY') $ 'DTN'
		tdDAY	= DATE()
	ENDIF
	LOCAL lnDAY AS Integer
	STORE 0 TO lnDAY
	DO CASE
		CASE TYPE('tdDAY') = 'N'
			IF tdDAY>=1 AND tdDAY <=7
				lnDAY	= tdDAY
			ELSE
				lnDAY	= DOW(DATE())
			ENDIF

		OTHERWISE
			lnDAY	= DOW(tdDAY)
	ENDCASE
RETURN SUBS('DomingoSegundaTerça  Quarta Quinta Sexta  Sábado ',( lnDAY-1 )*7+1,7)

FUNC FNOMMES
************
LPARAMETERS tdMES AS Date
	IF NOT TYPE('tdMES') $ 'DTN'
		tdMES	= DATE()
	ENDIF
	LOCAL lnMES AS Integer
	STORE 0 TO lnMES
	DO CASE
		CASE TYPE('tdMES') = 'N'
			IF tdMES>=1 AND tdMES<=12
				lnMES	= tdMES
			ELSE
				lnMES	= MONTH(DATE())
			ENDIF

		OTHERWISE
			lnMES	= MONTH( tdMES )
	ENDCASE
RETURN( SUBS('Janeiro  FevereiroMarço    Abril    Maio     Junho    Julho    Agosto   Setembro Outubro  Novembro Dezembro ',(lnMES-1)*9+1, 9) )

FUNC ROTEX
********** 
* FUNÇÃO QUE COLOCA VALOR POR EXTENSO        
* AUTOR: ROGERIO OLIVEIRA F GASPAR   
* tnVALEXT = valor                    
* tnTAMEXT = tamanho                  
* tnCOMEXT = complemento de espaco    
* sintaxe: ROTEX(valor,tamlinha,'*') 
* retorna: 2 linhas do valor extenso 
LPARAMETERS tnVALEXT,tnTAMEXT,tcCOMEXT
	MRE100S     ="cem"
	MREMOEDA    ="real"
	MREMOEDAS   ="reais"
	MRE1        ="um"
	MRE2        ="dois"
	MRE3        ="tres"
	MRE4        ="quatro"
	MRE5        ="cinco"
	MRE6        ="seis"
	MRE7        ="sete"
	MRE8        ="oito"
	MRE9        ="nove"
	MRE10       ="dez"
	MRE11       ="onze"
	MRE12       ="doze"
	MRE13       ="treze"
	MRE14       ="quatorze"
	MRE15       ="quinze"
	MRE16       ="dezesseis"
	MRE17       ="dezessete"
	MRE18       ="dezoito"
	MRE19       ="dezenove"
	MRE20       ="vinte"
	MRE30       ="trinta"
	MRE40       ="quarenta"
	MREMOEC     ="centavo"
	MREMOECS    ="centavos"
	MRE50       ="cinquenta"
	MRE60       ="sessenta"
	MRE70       ="setenta"
	MRE80       ="oitenta"
	MRE90       ="noventa"
	MRE100      ="cento"
	MRE200      ="duzentos"
	MRE300      ="trezentos"
	MRE400      ="quatrocentos"
	MRE500      ="quinhentos"
	MRE600      ="seiscentos"
	MRE700      ="setecentos"
	MRE800      ="oitocentos"
	MRE900      ="novecentos"
	MREMILHAR   ="mil"
	MREMILHARS  ="mil"
	MREMILHAOS  ="milhoes"
	MREMILHAO   ="milhao"
	MREBILHAO   ="bilhao"
	MREBILHAOS  ="bilhoes"
	MRETRILAO   ="trilhao"
	MRETRILAOS  ="trilhoes"

	lcADIC1 = "MREMOEC"
	lcADIC2 = "MREMOEDA"
	lcADIC3 = "MREMILHAR"
	lcADIC4 = "MREMILHAO"
	lcADIC5 = "MREBILHAO"
	lcADIC6 = "MRETRILAO"

	IF TYPE('tcCOMEXT') <> 'C'
		tcCOMEXT = '*'
	ENDIF
	lcBLOEX	= ALLTRIM(TRAN(tnVALEXT,"999999999999999"))
	IF tnVALEXT > INT(tnVALEXT)
		lcVALS = RIGHT('00'+ALLTRIM(STR((tnVALEXT - INT(tnVALEXT))*100)),3)
		lnINDSTR = 3
		lnINDUDC = 1
		lnINDPRIN = 1
		lnPLBLOEX = LEN(lcBLOEX)
	ELSE
		lcVALS = RIGHT('00'+lcBLOEX,3)
		lnINDSTR = 3
		lnINDUDC = 1
		lnINDPRIN = 2
		IF LEN(lcBLOEX) > 3
			lnPLBLOEX = LEN(lcBLOEX)-3
		ELSE
			lnPLBLOEX = 0
		ENDIF
	ENDIF
	lcLETEX = RIGHT(lcVALS,1)
	lcEXTENSO = ""
	lcRESP = " "
	lcEXTPARC = ""
	lnSKIPEX = 1
	lnNVIRGEX = 0
	lcVIRGEX = ', '
	lcANDEX = ' e '
	lcNADEX = ''
	lcDEEX = ' de'
	lcFLAGEX = ' '
	lnMOEUSEX = MREMOEDAS
	DO wHILE lcFLAGEX = ' '
		DO wHILE lnINDSTR > 0
		 IF VAL(lcVALS) > 0
			lcLETEX = SUBS(lcVALS,lnINDSTR,1)
			IF lnINDUDC = 1 AND LEFT(RIGHT(lcVALS,2),1) = '1'
				lnSKIPEX = 2
				lcNUMEX = 'MRE' + '1' + lcLETEX
				lcEXTPARC = &lcNUMEX + lcEXTPARC
			ELSE
				IF lcLETEX <> '0'
					IF lnINDUDC = 1
						lcZEREX = ''
					ELSE
						lcZEREX = IIF(lnINDUDC = 2,'0','00')
					ENDIF
					lcNUMEX = 'MRE' + lcLETEX + lcZEREX
					lcANDEX2 = IIF(EMPTY(lcEXTPARC),lcNADEX,lcANDEX)
					lcEXTPARC = &lcNUMEX + lcANDEX2 + lcEXTPARC
				ENDIF
			ENDIF
		 ENDIF
		 lnINDSTR = lnINDSTR - lnSKIPEX
		 lnINDUDC = lnINDUDC + lnSKIPEX
		 lnSKIPEX = 1
		ENDDO
		lcADICEX = 'lcADIC' + ALLTRIM(STR(lnINDPRIN))
		lcADICEXB = &lcADICEX
		lcADEX = &lcADICEXB
		IF VAL(lcVALS) = 0
			IF lnINDPRIN <> 2
				lcADEX = lcNADEX
			ELSE
				lcADICEXB = lcADICEXB + 'S'
				lcADEX = &lcADICEXB
			ENDIF
		ELSE
			IF VAL(lcVALS) = 1
				lcADEX = &lcADICEXB
			ELSE
				lcADICEXB = lcADICEXB + 'S'
				lcADEX = &lcADICEXB
				IF VAL(lcVALS) = 100
					lcEXTPARC = MRE100S
				ENDIF
			ENDIF
		ENDIF
		IF ! EMPTY(lcADEX)
			lcADEX = ' ' + lcADEX
		ENDIF
		lcVIRGEX2 = IIF(EMPTY(lcEXTENSO),lcNADEX,lcVIRGEX)
		IF lcVIRGEX2 = lcVIRGEX AND ALLTRIM(lcEXTENSO) = lnMOEUSEX
			IF lnINDPRIN > 3
				lcVIRGEX2 = lcDEEX
			ELSE
				lcVIRGEX2 = lcNADEX
			ENDIF
		ENDIF
		IF lnNVIRGEX = 0 AND lcVIRGEX2 = lcVIRGEX
			lnNVIRGEX = lnNVIRGEX + 1
			lcVIRGEX2 = lcANDEX
		ENDIF
		IF ! EMPTY(lcEXTPARC) OR (lnINDPRIN = 2 AND INT(tnVALEXT)>0)
			lcEXTENSO = lcEXTPARC + lcADEX + lcVIRGEX2 + lcEXTENSO
			IF lnINDPRIN = 2
				lnMOEUSEX = lnMOEUSEX
			ENDIF
		ENDIF
		lcEXTPARC = ''
		lnINDPRIN = lnINDPRIN + 1
		IF lnPLBLOEX = 0
			lcFLAGEX = 'F'
		ELSE
			IF lnPLBLOEX >= 3
				lcVALS = SUBS(lcBLOEX,lnPLBLOEX-2,3)
				lnPLBLOEX = lnPLBLOEX - 3
			ELSE
				lcVALS = RIGHT('00'+LEFT(lcBLOEX,lnPLBLOEX),3)
				lnPLBLOEX = 0
			ENDIF
		ENDIF
		lnINDSTR=IIF(LEN(lcVALS)>3,3,LEN(lcVALS))
		lnINDUDC = 1
	ENDDO
	IF lcEXTENSO = 'um '
		lcEXTENSO = 'h' + lcEXTENSO
	ENDIF
	RELE ALL LIKE MRE*
	lcRESTEX = LEFT(REPLICATE(tcCOMEXT,tnTAMEXT),tnTAMEXT)
	lcEXTENSO = UPPER(LEFT(lcEXTENSO,1)) + RIGHT(lcEXTENSO,LEN(lcEXTENSO)-1)
	IF LEN(lcEXTENSO) <= tnTAMEXT
		lcLINEXT2 = lcRESTEX 
		lcLINEXT1 = LEFT(lcEXTENSO+lcRESTEX ,tnTAMEXT)
	ELSE
		lnPOSEX = tnTAMEXT
		FOR lnCONTEX = 1 TO tnTAMEXT+1
			lcBYTEX = SUBS(lcEXTENSO,lnCONTEX,1)
			IF lcBYTEX = ' '
				lnPOSEX = lnCONTEX
			ENDIF
		ENDFOR
		lcLINEXT1 = RIGHT(lcRESTEX + ALLTRIM(LEFT(lcEXTENSO,lnPOSEX)) ,tnTAMEXT)
		lcLINEXT2 = LEFT( ALLTRIM(SUBS(lcEXTENSO,lnPOSEX+1,tnTAMEXT)) +lcRESTEX ,tnTAMEXT)
	ENDIF
RETURN(lcEXTENSO)

FUNC PUXAICMS
*************
LPARAMETERS tcPRODUTO, tnCADUNICO, tcEMPRESA
	IF TYPE('tcPRODUTO') <> 'C'
		tcPRODUTO = ''
	ENDIF
	IF EMPTY(tcPRODUTO)
		DO MENS WITH 'Produto não informado!'
		RETURN(0)
	ENDIF
	IF TYPE('tnCADUNICO') <> 'N'
		tnCADUNICO	= 0
	ENDIF
	IF EMPTY(tnCADUNICO)
		RETURN(0)
	ENDIF
	IF TYPE('tcEMPRESA') <> 'C'
		tcEMPRESA	= ''
	ENDIF
	IF EMPTY(tcEMPRESA)
		DO MENS WITH 'Empresa não informada!'
		RETURN(0)
	ENDIF

	LOCAL lcCOMANDO, lcTB_ICMS, lcTG_ISENTOICMS AS String
	LOCAL lnPORICM, lnPORICMCL AS Number
	LOCAL llTEVEICMCL AS Logical
	STORE 0 TO lnPORICM, lnPORICMCL
	STORE .F. TO llTEVEICMCL

	lcTB_ICMS = RETORNASET('ICMS.ESTADOORIGEM','C',1)
	IF EMPTY(lcTB_ICMS)
		lcTB_ICMS	= 'OFF'
	ENDIF

	* CLASSIFICAÇÃO FISCAL DO PRODUTO
	lcCOMANDO = 'SELECT FK_CLAFIS FROM TB_PRODUTOS WHERE PK_ID='+XX(tcPRODUTO)
	=PESQUISASQL(lcCOMANDO,'TMFPRO')

	* TIPO DE PESSOA DO CLIENTE/FORNECEDOR
	lcCOMANDO = 'SELECT TG_PESSOA, DS_INSEST, DS_UF FROM TB_CADUNICO WHERE PK_ID='+XX(tnCADUNICO)
	=PESQUISASQL(lcCOMANDO,'TMFCAD')

	* ALIQUOTA DE ICMS DO ESTADO
	* VERIFICANDO SE USA TB_ICMS
	IF lcTB_ICMS = 'ON'
		*******************************************************************
		* USA TABELA DE ICMS PARA EMPRESAS COM FILIAS EM ESTADOS DIFERENTES
		*******************************************************************

		*******************************************************************
		* ALIQUOTAS DE ICMS DA CLASSIFICAÇÃO FISCAL
		*******************************************************************
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT TOP 1
				EXC.*
			FROM
				TB_CLAFISEXC EXC
				INNER JOIN TB_EMPRESAS EMP ON EMP.PK_ID=[[FK_EMPRESA]] AND EMP.DS_UF=EXC.FK_UFORIGEM
			WHERE
				EXC.FK_ORIGEM=[[FK_ORIGEM]]
				AND EXC.DS_UFDESTINO LIKE [[FK_UFDESTINO]]
		ENDTEXT
		lcCOMANDO	= STRTRAN( lcCOMANDO, '[[FK_ORIGEM]]', XX(TMFPRO.FK_CLAFIS) )
		lcCOMANDO	= STRTRAN( lcCOMANDO, '[[FK_EMPRESA]]', XX(tcEMPRESA) )
		lcCOMANDO	= STRTRAN( lcCOMANDO, '[[FK_UFDESTINO]]', XX(TMFCAD.DS_UF,'%LIKE%') )
		=PESQUISASQL(lcCOMANDO,'TMFCLA')
		IF RECCOUNT('TMFCLA') <> 0
			lnPORICMCL	= TMFCLA.VL_PORICMS
			llTEVEICMCL	= .T.
		ENDIF
		USE IN TMFCLA

		*******************************************************************
		* ALIQUOTA DE ICMS DO ESTADO DE DESTINO
		*******************************************************************
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT 
				ICM.*
			FROM
				TB_ICMS AS ICM
				LEFT JOIN TB_EMPRESAS AS EMP ON EMP.DS_UF=ICM.FK_UFORIGEM
			WHERE
				ICM.FK_UFDESTINO=[[UFDESTINO]]
				AND EMP.PK_ID=[[EMPRESA]]
		ENDTEXT
		lcCOMANDO = STRTRAN(lcCOMANDO,'[[EMPRESA]]',XX(tcEMPRESA))
		lcCOMANDO = STRTRAN(lcCOMANDO,'[[UFDESTINO]]',XX(TMFCAD.DS_UF))
		=PESQUISASQL(lcCOMANDO,'TMFICM')

		*******************************************************************
		* ALIQUOTA DE ICMS PESSOA FÍSICA OU ISENTA
		*******************************************************************
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT
				COALESCE(ICM.VL_PORICM,0) AS VL_PORICM,
				EMP.TG_ISENTOICMS
			FROM
				TB_EMPRESAS AS EMP
				LEFT JOIN TB_ICMS AS ICM ON EMP.DS_UF=ICM.FK_UFDESTINO AND EMP.DS_UF=ICM.FK_UFORIGEM
			WHERE
				EMP.PK_ID=[[EMPRESA]]
		ENDTEXT
	ELSE
		*******************************************************************
		* COMPATIBILIDADE COM TABELA DE ESTADOS
		*******************************************************************

		*******************************************************************
		* ALIQUOTAS DE ICMS DA CLASSIFICAÇÃO FISCAL
		*******************************************************************
		lcCOMANDO	= 'SELECT * FROM TB_CLAFIS WHERE PK_ID=' + XX(TMFPRO.FK_CLAFIS)
		=PESQUISASQL(lcCOMANDO,'TMFCLA')		
		DO CASE
			CASE TMFCLA.TG_ICMS1 = 1 AND (TMFCAD.DS_UF $ TMFCLA.DS_UFICMS1 OR EMPTY(TMFCLA.DS_UFICMS1))
				lnPORICMCL	= TMFCLA.VL_PORICMS1
				llTEVEICMCL	= .T.
			CASE TMFCLA.TG_ICMS2 = 1 AND (TMFCAD.DS_UF $ TMFCLA.DS_UFICMS2 OR EMPTY(TMFCLA.DS_UFICMS2))
				lnPORICMCL	= TMFCLA.VL_PORICMS2
				llTEVEICMCL	= .T.
			CASE TMFCLA.TG_ICMS3 = 1 AND (TMFCAD.DS_UF $ TMFCLA.DS_UFICMS3 OR EMPTY(TMFCLA.DS_UFICMS3))
				lnPORICMCL	= TMFCLA.VL_PORICMS3
				llTEVEICMCL	= .T.
			CASE TMFCLA.TG_ICMS4 = 1 AND (TMFCAD.DS_UF $ TMFCLA.DS_UFICMS4 OR EMPTY(TMFCLA.DS_UFICMS4))
				lnPORICMCL	= TMFCLA.VL_PORICMS4
				llTEVEICMCL	= .T.
			CASE TMFCLA.TG_ICMS5 = 1 AND (TMFCAD.DS_UF $ TMFCLA.DS_UFICMS5 OR EMPTY(TMFCLA.DS_UFICMS5))
				lnPORICMCL	= TMFCLA.VL_PORICMS5
				llTEVEICMCL	= .T.
		ENDCASE
		USE IN TMFCLA

		*******************************************************************
		* ALIQUOTA DE ICMS DO ESTADO DE DESTINO
		*******************************************************************
		lcCOMANDO = 'SELECT VL_PORICM FROM TB_ESTADOS WHERE PK_ID='+XX(TMFCAD.DS_UF)
		=PESQUISASQL(lcCOMANDO,'TMFICM')

		*******************************************************************
		* ALIQUOTA DE ICMS PESSOA FÍSICA OU ISENTA
		*******************************************************************
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT
				COALESCE(EST.VL_PORICM,0) AS VL_PORICM,
				EMP.TG_ISENTOICMS
			FROM
				TB_EMPRESAS AS EMP
				LEFT JOIN TB_ESTADOS AS EST ON EMP.DS_UF = EST.PK_ID
			WHERE
				EMP.PK_ID=[[EMPRESA]]
		ENDTEXT
	ENDIF
	lcCOMANDO	= STRTRAN(lcCOMANDO,'[[EMPRESA]]',XX(tcEMPRESA))
	=PESQUISASQL(lcCOMANDO,'TMFEMP')


	IF TMFCAD.TG_PESSOA = 'F'
		* PESSOA FÍSICA
		IF llTEVEICMCL
			lnPORICM = lnPORICMCL
		ELSE
			IF TYPE('TMFICM.VL_PORICMCONS') = 'N'
				lnPORICM = TMFICM.VL_PORICMCONS
			ELSE
				lnPORICM = TMFEMP.VL_PORICM
			ENDIF
		ENDIF
	ELSE
		* PESSOA JURÍDICA
		IF EMPTY(TMFCAD.DS_INSEST) OR 'ISENT' $ UPPER(TMFCAD.DS_INSEST)
			IF llTEVEICMCL
				lnPORICM = lnPORICMCL
			ELSE
				IF TYPE('TMFICM.VL_PORICMCONS') = 'N'
					lnPORICM = TMFICM.VL_PORICMCONS
				ELSE
					lnPORICM = TMFEMP.VL_PORICM
				ENDIF
			ENDIF
		ELSE
			IF llTEVEICMCL
				lnPORICM = lnPORICMCL
*				lnPORICM = IIF(lnPORICMCL<TMFICM.VL_PORICM, lnPORICMCL, TMFICM.VL_PORICM)
			ELSE
				lnPORICM = TMFICM.VL_PORICM
			ENDIF
		ENDIF
	ENDIF
	* ISENÇÃO DE ICMS PELO EMPRESA (ATUA SOBRE QUALQUER REGRA, EX.: CFOP, CLASS.FISCAL, ETC.)
	IF TMFEMP.TG_ISENTOICMS=1
		lnPORICM = 0
	ENDIF

	USE IN TMFEMP
	USE IN TMFICM
	USE IN TMFPRO

RETURN(lnPORICM)

FUNC PUXAREDUBASE
*****************
LPARAMETERS tcPRODUTO, tnCADUNICO, tcFK_EMPRESA
	IF TYPE('tcPRODUTO') <> 'C'
		tcPRODUTO = ''
	ENDIF
	IF EMPTY(tcPRODUTO)
		DO MENS WITH 'Produto não informado!'
		RETURN(0)
	ENDIF
	IF TYPE('tnCADUNICO') <> 'N'
		tnCADUNICO	= 0
	ENDIF
	IF EMPTY(tnCADUNICO)
		RETURN(0)
	ENDIF
	IF TYPE('tcFK_EMPRESA') <> 'C'
		tcFK_EMPRESA	= ''
	ENDIF

	LOCAL lcCOMANDO AS String
	LOCAL lnPORBASE AS Number
	STORE 0 TO lnPORBASE

	* INFORMAÇÕES DO PRODUTO ( CLASSIFICAÇÃO FISCAL )
	lcCOMANDO	= 'SELECT FK_CLAFIS FROM TB_PRODUTOS WHERE PK_ID='+XX(tcPRODUTO)
	=PESQUISASQL(lcCOMANDO,'TMFPRO')

	* INFORMAÇÕES DO CLIENTE
	lcCOMANDO	= 'SELECT * FROM TB_CADUNICO WHERE PK_ID=' + XX(tnCADUNICO)
	=PESQUISASQL(lcCOMANDO,'TMFCAD')

	lcTB_ICMS = RETORNASET('ICMS.ESTADOORIGEM','C',1)
	IF EMPTY(lcTB_ICMS)
		lcTB_ICMS	= 'OFF'
	ENDIF

	IF lcTB_ICMS = 'ON'
		*******************************************************************
		* USA TABELA DE ICMS PARA EMPRESAS COM FILIAS EM ESTADOS DIFERENTES
		*******************************************************************

		*******************************************************************
		* ALIQUOTAS DE ICMS DA CLASSIFICAÇÃO FISCAL
		*******************************************************************
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT TOP 1
				EXC.*
			FROM
				TB_CLAFISEXC EXC
				INNER JOIN TB_EMPRESAS EMP ON EMP.PK_ID=[[FK_EMPRESA]] AND EMP.DS_UF=EXC.FK_UFORIGEM
			WHERE
				EXC.FK_ORIGEM=[[FK_ORIGEM]]
				AND EXC.DS_UFDESTINO LIKE [[FK_UFDESTINO]]
		ENDTEXT
		lcCOMANDO	= STRTRAN( lcCOMANDO, '[[FK_ORIGEM]]', XX(TMFPRO.FK_CLAFIS) )
		lcCOMANDO	= STRTRAN( lcCOMANDO, '[[FK_EMPRESA]]', XX(tcFK_EMPRESA) )
		lcCOMANDO	= STRTRAN( lcCOMANDO, '[[FK_UFDESTINO]]', XX(TMFCAD.DS_UF,'%LIKE%') )
		=PESQUISASQL(lcCOMANDO,'TMFCLA')
		IF RECCOUNT('TMFCLA') <> 0
			lnPORBASE	= TMFCLA.VL_PORREDUICMS
		ENDIF

	ELSE
		*******************************************************************
		* COMPATIBILIDADE COM TABELA DE ESTADOS
		*******************************************************************

		* ALIQUOTAS DE ICMS DA CLASSIFICAÇÃO FISCAL
		lcCOMANDO	= 'SELECT * FROM TB_CLAFIS WHERE PK_ID=' + XX(TMFPRO.FK_CLAFIS)
		=PESQUISASQL(lcCOMANDO,'TMFCLA')

		DO CASE
			CASE TMFCLA.TG_ICMS1 = 1 AND ( TMFCAD.DS_UF $ TMFCLA.DS_UFICMS1 OR EMPTY(TMFCLA.DS_UFICMS1))
				lnPORBASE	= TMFCLA.VL_PORREDUICMS1

			CASE TMFCLA.TG_ICMS1 = 2 AND (TMFCAD.DS_UF $ TMFCLA.DS_UFICMS2 OR EMPTY(TMFCLA.DS_UFICMS2))
				lnPORBASE	= TMFCLA.VL_PORREDUICMS2

			CASE TMFCLA.TG_ICMS1 = 3 AND (TMFCAD.DS_UF $ TMFCLA.DS_UFICMS3 OR EMPTY(TMFCLA.DS_UFICMS3))
				lnPORBASE	= TMFCLA.VL_PORREDUICMS3

			CASE TMFCLA.TG_ICMS1 = 4 AND (TMFCAD.DS_UF $ TMFCLA.DS_UFICMS4 OR EMPTY(TMFCLA.DS_UFICMS4))
				lnPORBASE	= TMFCLA.VL_PORREDUICMS4

			CASE TMFCLA.TG_ICMS1 = 5 AND (TMFCAD.DS_UF $ TMFCLA.DS_UFICMS5 OR EMPTY(TMFCLA.DS_UFICMS5))
				lnPORBASE	= TMFCLA.VL_PORREDUICMS5

		ENDCASE
	ENDIF

	USE IN TMFCLA
	USE IN TMFCAD
	USE IN TMFPRO

RETURN(lnPORBASE)

FUNC RETORNASET
***************
LPARAMETERS tcPARAMETRO, tcDATATYPE, tnLOAD
	IF TYPE('tcPARAMETRO') <> 'C'
		RETURN('')
	ENDIF
	tcPARAMETRO	= ALLTRIM(tcPARAMETRO)
	IF TYPE('tcDATATYPE') <> 'C'
		tcDATATYPE = 'C'
	ENDIF
	IF TYPE('tnLOAD') <> 'N'
		tnLOAD = 1
	ENDIF
	LOCAL lcCONTEUDO, lcCOMANDO, lcPOINT, lcSEPA AS String
	LOCAL luRETORNO
	IF tnLOAD = 1
		* PROPRIEDADE DO APLICATIVO
		lcCONTEUDO = STREXTRACT(goAPLICATIVO.ZWS,;
					'<'+tcPARAMETRO+'>',;
					'</'+tcPARAMETRO+'>')
		IF tcPARAMETRO = 'SEGMENTO.PICTURE'
			IF EMPTY(lcCONTEUDO) OR ISNULL(lcCONTEUDO)
				lcCONTEUDO	= 'X.XX.XXX'
			ENDIF
		ENDIF
	ELSE
		* REGISTRO VINDO DA TABELA NO BANCO DE DADOS
		lcCOMANDO = 'SELECT DS_CONTEUDO FROM TS_PARAMETROS'+;
					' WHERE DS_PARAMETRO='+XX(tcPARAMETRO)
		=PESQUISASQL(LCCOMANDO,'TMPZWS')
		
		IF USED('TMPZWS')
			SELE TMPZWS
			lcCONTEUDO	= TMPZWS.DS_CONTEUDO
			USE IN TMPZWS
		ELSE
			* SE DEU ERRO NA CRIAÇÃO DO CUROSOR, TENTA CARREGAR ZW CARREGADA NA INICIALIZAÇÃO
			* PROPRIEDADE DO APLICATIVO
			lcCONTEUDO = STREXTRACT(goAPLICATIVO.ZWS,;
						'<'+tcPARAMETRO+'>',;
						'</'+tcPARAMETRO+'>')
			IF tcPARAMETRO = 'SEGMENTO.PICTURE'
				IF EMPTY(lcCONTEUDO) OR ISNULL(lcCONTEUDO)
					lcCONTEUDO	= 'X.XX.XXX'
				ENDIF
			ENDIF
		ENDIF
		
	ENDIF
	* FORMATANDO NO TIPO DE DADO SOLICITADO
	DO CASE
		CASE tcDATATYPE = 'C'
			luRETORNO = ALLTRIM(lcCONTEUDO)
		CASE tcDATATYPE = 'N'
			lcCONTEUDO = STRTRAN(lcCONTEUDO,'.','')
			luRETORNO = VAL(lcCONTEUDO)
		CASE tcDATATYPE = 'D'
			luRETORNO = CTOD(lcCONTEUDO)
		CASE tcDATATYPE = 'L'
			luRETORNO = IIF(lcCONTEUDO='.T.',.T.,.F.)
	ENDCASE
RETURN(luRETORNO)

FUNC RETORNAEMPSET
***************
LPARAMETERS tcPARAMETRO, tcDATATYPE, tcEMPRESA
	IF TYPE('tcPARAMETRO') <> 'C'
		RETURN('')
	ENDIF
	tcPARAMETRO	= ALLTRIM(tcPARAMETRO)
	IF TYPE('tcDATATYPE') <> 'C'
		tcDATATYPE = 'C'
	ENDIF
	IF TYPE('tcEMPRESA') <> 'C'
		tcEMPRESA = ''
	ENDIF
	
	LOCAL lcCONTEUDO, lcCOMANDO, lcPOINT, lcSEPA AS String
	STORE '' TO lcCONTEUDO, lcCOMANDO, lcPOINT, lcSEPA
	LOCAL luRETORNO
	
	* REGISTRO VINDO DA TABELA NO BANCO DE DADOS
	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		SELECT
			ITE.DS_CONTEUDO
		FROM
			TS_EMPPARAMITENS ITE
		INNER JOIN TS_EMPPARAMETROS PAR ON PAR.PK_ID = ITE.FK_EMPPARAMETRO
		WHERE
			ITE.FK_EMPRESA = [[FK_EMPRESA]]
			AND PAR.DS_PARAMETRO = [[DS_PARAMETRO]]
	ENDTEXT
	lcCOMANDO	= STRTRAN( lcCOMANDO, '[[FK_EMPRESA]]', XX(tcEMPRESA) )
	lcCOMANDO	= STRTRAN( lcCOMANDO, '[[DS_PARAMETRO]]', XX(tcPARAMETRO) )
	
	=PESQUISASQL(LCCOMANDO,'TMPZWS')
	lcCONTEUDO	= TMPZWS.DS_CONTEUDO
	USE IN TMPZWS

	* FORMATANDO NO TIPO DE DADO SOLICITADO
	DO CASE
		CASE tcDATATYPE = 'C'
			luRETORNO = ALLTRIM(lcCONTEUDO)
		CASE tcDATATYPE = 'N'
			lcCONTEUDO = STRTRAN(lcCONTEUDO,'.','')
			luRETORNO = VAL(lcCONTEUDO)
		CASE tcDATATYPE = 'D'
			luRETORNO = CTOD(lcCONTEUDO)
		CASE tcDATATYPE = 'L'
			luRETORNO = IIF(lcCONTEUDO='.T.',.T.,.F.)
	ENDCASE
RETURN(luRETORNO)

PROC SALVARSET
**************
LPARAMETERS tcPARAMETRO, tuCONTEUDO
***********************************************
* - tcPARAMETRO - NOME DO PARAMETRO NA TABELA
* - tuCONTEUDO	- CONTEÚDO DO PARAMETRO
***********************************************
	IF TYPE('tcPARAMETRO') <> 'C'
		tcPARAMETRO	= ''
	ENDIF
	IF EMPTY(tcPARAMETRO)
		RETURN
	ENDIF

	LOCAL lcCOMANDO, lcCONTEUDO AS String
	LOCAL lnDECIMAIS AS Integer
	STORE '' TO lcCONTEUDO

	lcCOMANDO	= 'SELECT * FROM TS_PARAMETROS WHERE DS_PARAMETRO=' + XX(tcPARAMETRO)
	=PESQUISASQL(lcCOMANDO,'TMFPARAM')
	IF RECCOUNT('TMFPARAM') <= 0
		USE IN TMFPARAM
		RETURN
	ENDIF

	* SALVANDO CONTEUDO DE ACORDO COM TIPO DE DADO DO PARAMETRO
	DO CASE
		CASE TMFPARAM.TG_DATATYPE = 'N'
			lnDECIMAIS	= 0
			IF NOT EMPTY(TMFPARAM.DS_FORMATO)
				lcDECIMAIS = TRANSFORM( 1, TMFPARAM.DS_FORMATO )
				lnDECIMAIS = OCCURS('0',lcDECIMAIS)
			ENDIF
			lcCONTEUDO	= ALLTRIM( STR( tuCONTEUDO, 15, lnDECIMAIS ) )

		CASE TMFPARAM.TG_DATATYPE = 'D'
			lcCONTEUDO	= DTOC( tuCONTEUDO )

		OTHERWISE
			lcCONTEUDO	= ALLTRIM( tuCONTEUDO )
	ENDCASE

	* SOMENTE ATUALIZA SE CONTEÚDO FOI ALTERADO
	IF lcCONTEUDO == TMFPARAM.DS_CONTEUDO
		USE IN TMFPARAM
		RETURN
	ENDIF
	
	* ATUALIZA VALOR DA ZW NO SISTEMA
	lcTAGINI = '<'+tcPARAMETRO+'>'
	lcTAGFIM = '</'+tcPARAMETRO+'>'

	* SE ZW JÁ FOI CARREGADA ALTERA VALOR CASO CONTRÁRIO INCLUI NA LISTA DE ZW
	IF AT(lcTAGINI,goAPLICATIVO.ZWS) > 0
		lcCONTEUDOOLD 		= STREXTRACT(goAPLICATIVO.ZWS, lcTAGINI, lcTAGFIM)
		goAPLICATIVO.ZWS 	= STRTRAN(goAPLICATIVO.ZWS, lcTAGINI+lcCONTEUDOOLD+lcTAGFIM, lcTAGINI+lcCONTEUDO+lcTAGFIM)
	ELSE
		goAPLICATIVO.ZWS 	= goAPLICATIVO.ZWS + lcTAGINI+lcCONTEUDO+lcTAGFIM
	ENDIF
						
	SELE TMFPARAM
	REPLACE DS_CONTEUDO WITH lcCONTEUDO
	DO ATUSQL WITH 'M', 'TS_PARAMETROS'
	USE IN TMFPARAM

RETURN

PROC SALVAREMPSET
**************
LPARAMETERS tcPARAMETRO, tuCONTEUDO, tcEMPRESA
***********************************************
* - tcPARAMETRO - NOME DO PARAMETRO NA TABELA
* - tuCONTEUDO	- CONTEÚDO DO PARAMETRO
* - tcEMPRESA	- ID DA EMPRESA
***********************************************
	IF TYPE('tcPARAMETRO') <> 'C'
		tcPARAMETRO	= ''
	ENDIF
	IF EMPTY(tcPARAMETRO)
		RETURN(.F.)
	ENDIF
	
	IF TYPE('tcEMPRESA') <> 'C'
		tcEMPRESA	= ''
	ENDIF
	IF EMPTY(tcEMPRESA)
		RETURN(.F.)
	ENDIF
	
	LOCAL lcCOMANDO, lcCONTEUDO, lcACAO AS String
	LOCAL lnDECIMAIS AS Integer
	STORE '' TO lcCONTEUDO, lcACAO

	* REGISTRO VINDO DA TABELA NO BANCO DE DADOS
	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		SELECT
			ITE.*,
			PAR.PK_ID AS FK_KKEMPPARAMETRO,
			PAR.TG_DATATYPE,
			PAR.DS_FORMATO
		FROM
			TS_EMPPARAMETROS PAR 
		LEFT JOIN TS_EMPPARAMITENS ITE ON ITE.FK_EMPPARAMETRO = PAR.PK_ID AND ITE.FK_EMPRESA = [[FK_EMPRESA]]
		WHERE
			PAR.DS_PARAMETRO = [[DS_PARAMETRO]]
	ENDTEXT
	lcCOMANDO	= STRTRAN( lcCOMANDO, '[[FK_EMPRESA]]', XX(tcEMPRESA) )
	lcCOMANDO	= STRTRAN( lcCOMANDO, '[[DS_PARAMETRO]]', XX(tcPARAMETRO) )
	=PESQUISASQL(lcCOMANDO,'TMFPARAM')
	
	* VERIFICA SE PARÂMETRO PRINCIPAL EXISTE
	IF RECCOUNT('TMFPARAM') <= 0
		USE IN TMFPARAM
		RETURN(.F.)
	ENDIF
	
	* VERIFICA SE LINHA DE PARÂMETRO NA EMPRESA INFORMADA EXISTE, SE NÃO, CRIA
	SELE TMFPARAM
	GO TOP
	
	IF EMPTY(NVL(TMFPARAM.PK_ID,0))
		lcACAO = 'A'
		REPLACE FK_EMPPARAMETRO WITH FK_KKEMPPARAMETRO, FK_EMPRESA WITH tcEMPRESA
	ELSE
		lcACAO = 'M'
	ENDIF
	
	* SALVANDO CONTEUDO DE ACORDO COM TIPO DE DADO DO PARAMETRO
	DO CASE
		CASE TMFPARAM.TG_DATATYPE = 'N'
			lnDECIMAIS	= 0
			IF NOT EMPTY(TMFPARAM.DS_FORMATO)
				lcDECIMAIS = TRANSFORM( 1, TMFPARAM.DS_FORMATO )
				lnDECIMAIS = OCCURS('0',lcDECIMAIS)
			ENDIF
			lcCONTEUDO	= ALLTRIM( STR( tuCONTEUDO, 15, lnDECIMAIS ) )

		CASE TMFPARAM.TG_DATATYPE = 'D'
			lcCONTEUDO	= DTOC( tuCONTEUDO )

		OTHERWISE
			lcCONTEUDO	= ALLTRIM( tuCONTEUDO )
	ENDCASE

	* SOMENTE ATUALIZA SE CONTEÚDO FOI ALTERADO
	IF lcCONTEUDO == TMFPARAM.DS_CONTEUDO
		USE IN TMFPARAM
		RETURN
	ENDIF
						
	SELE TMFPARAM
	REPLACE DS_CONTEUDO WITH lcCONTEUDO
	DO ATUSQL WITH lcACAO, 'TS_EMPPARAMITENS', 'UPDATE=NO', 'TG_DATATYPE,DS_FORMATO,FK_KKEMPPARAMETRO'
	USE IN TMFPARAM

RETURN

FUNC CGCCPF
***********
LPARAMETERS tnCPFCGC, tcTIPOPESSOA, tcMENSAGEMSN
	IF TYPE('tcMENSAGEMSN') <> 'C'
		tcMENSAGEMSN = 'S'
	ENDIF
	IF TYPE('tnCPFCGC') <> 'N'
		tnCPFCGC = 0
	ENDIF
	IF EMPTY(tnCPFCGC)
		IF tcMENSAGEMSN = 'S'
			DO MENS WITH 'Digitação de CNPJ/CPF obrigatória'
		ENDIF
		RETURN(.F.)
	ENDIF
	IF TYPE('tcTIPOPESSOA') <> 'C'
		tcTIPOPESSOA = ''
	ENDIF
	IF EMPTY(tcTIPOPESSOA)
		RETURN(.T.)
	ENDIF
	* VALIDAÇÃO DO CPF
	IF tcTIPOPESSOA = 'F'
		LOCAL lcSTRINGCPF, lcRESULTADO  AS String
		LOCAL lnCPO01, lnCPO02, lnCPO03, lnCPO04, lnCPO05 AS Integer
		LOCAL lnCPO06, lnCPO07, lnCPO08, lnCPO09, lnCPO10, lnCPO11 AS Integer
		LOCAL lnVERIF1, lnVERIF2, lnAUX AS Integer

		lcSTRINGCPF	= SUBS(STRZERO(tnCPFCGC,14),4)
		lnCPO01		= VAL(SUBS(lcSTRINGCPF,1,1))
		lnCPO02		= VAL(SUBS(lcSTRINGCPF,2,1))
		lnCPO03		= VAL(SUBS(lcSTRINGCPF,3,1))
		lnCPO04		= VAL(SUBS(lcSTRINGCPF,4,1))
		lnCPO05		= VAL(SUBS(lcSTRINGCPF,5,1))
		lnCPO06		= VAL(SUBS(lcSTRINGCPF,6,1))
		lnCPO07		= VAL(SUBS(lcSTRINGCPF,7,1))
		lnCPO08		= VAL(SUBS(lcSTRINGCPF,8,1))
		lnCPO09		= VAL(SUBS(lcSTRINGCPF,9,1))

		lnVERIF1	= lnCPO01*10 + lnCPO02*9 + lnCPO03*8 + lnCPO04*7 + lnCPO05*6 + ;
					  lnCPO06*5  + lnCPO07*4 + lnCPO08*3 + lnCPO09*2
		lnAUX		= MOD(lnVERIF1,11)
		IF lnAUX <= 1
			lnCPO10	= 0
		ELSE
			lnCPO10	= 11 - lnAUX
		ENDIF
		lnVERIF2	= lnCPO01*11 + lnCPO02*10 + lnCPO03*9 + lnCPO04*8 + lnCPO05*7 + ;
					  lnCPO06*6  + lnCPO07*5  + lnCPO08*4 + lnCPO09*3 + lnCPO10*2
		lnAUX		= MOD(lnVERIF2,11)
		IF lnAUX <= 1
			lnCPO11	= 0
		ELSE
			lnCPO11	= 11 - lnAUX
		ENDIF
		lcRESULTADO	= SUBS(lcSTRINGCPF,1,9) + ;
						STRZERO(lnCPO10,1) + ;
						STRZERO(lnCPO11,1)
		IF lcSTRINGCPF <> lcRESULTADO
			IF tcMENSAGEMSN = 'S'
				DO MENS WITH 'CPF inválido.'
			ENDIF
			RETURN(.F.)
		ELSE
			RETURN(.T.)
		ENDIF
	ENDIF
	* VALIDAÇÃO DO CNPJ
	IF tcTIPOPESSOA = 'J'
		LOCAL lcSTRINGCNPJ, lcRESULTADO  AS String
		LOCAL lnCPO01, lnCPO02, lnCPO03, lnCPO04, lnCPO05, lnCPO06, lnCPO07 AS Integer
		LOCAL lnCPO08, lnCPO09, lnCPO10, lnCPO11, lnCPO12, lnCPO13, lnCPO14 AS Integer
		LOCAL lnVERIF1, lnVERIF2, lnAUX AS Integer
		lcSTRINGCNPJ	= SUBSTR(STRZERO(tnCPFCGC,14),1)
		lnCPO01			= VAL(SUBS(lcSTRINGCNPJ, 1,1))
		lnCPO02			= VAL(SUBS(lcSTRINGCNPJ, 2,1))
		lnCPO03			= VAL(SUBS(lcSTRINGCNPJ, 3,1))
		lnCPO04			= VAL(SUBS(lcSTRINGCNPJ, 4,1))
		lnCPO05			= VAL(SUBS(lcSTRINGCNPJ, 5,1))
		lnCPO06			= VAL(SUBS(lcSTRINGCNPJ, 6,1))
		lnCPO07			= VAL(SUBS(lcSTRINGCNPJ, 7,1))
		lnCPO08			= VAL(SUBS(lcSTRINGCNPJ, 8,1))
		lnCPO09			= VAL(SUBS(lcSTRINGCNPJ, 9,1))
		lnCPO10			= VAL(SUBS(lcSTRINGCNPJ,10,1))
		lnCPO11			= VAL(SUBS(lcSTRINGCNPJ,11,1))
		lnCPO12			= VAL(SUBS(lcSTRINGCNPJ,12,1))

		lnVERIF1		= lnCPO01*5 + lnCPO02*4 + lnCPO03*3 + lnCPO04*2 + ;
						  lnCPO05*9 + lnCPO06*8 + lnCPO07*7 + lnCPO08*6 + ;
						  lnCPO09*5 + lnCPO10*4 + lnCPO11*3 + lnCPO12*2
  		lnAUX			= MOD(lnVERIF1,11)
		IF lnAUX <= 1
			lnCPO13		= 0
		ELSE
			lnCPO13		= 11 - lnAUX
		ENDIF

		lnVERIF2		= lnCPO01*6 + lnCPO02*5 + lnCPO03*4 + lnCPO04*3 + ;
						  lnCPO05*2 + lnCPO06*9 + lnCPO07*8 + lnCPO08*7 + ;
						  lnCPO09*6 + lnCPO10*5 + lnCPO11*4 + lnCPO12*3 + ;
						  lnCPO13*2
  		lnAUX			= MOD(lnVERIF2,11)
		IF lnAUX <= 1
			lnCPO14		= 0
		ELSE
			lnCPO14		= 11 - lnAUX
		ENDIF
		lcRESULTADO		= SUBSTR(lcSTRINGCNPJ,1,12) + ;
						  STRZERO(lnCPO13,1) + ;
						  STRZERO(lnCPO14,1)
		IF lcSTRINGCNPJ <> lcRESULTADO
			IF tcMENSAGEMSN = 'S'
				DO MENS WITH 'CNPJ inválido.'
			ENDIF
			RETURN(.F.)
		ELSE
			RETURN(.T.)
		ENDIF
	ENDIF
RETURN

PROC SYSHELP
************
LPARAMETERS toFORM
	IF goAPLICATIVO.HELPF1=0
		RETURN
	ENDIF
	IF TYPE('toFORM')<>'O'
		IF TYPE('_SCREEN.ACTIVEFORM')='O'
			toFORM = _SCREEN.ACTIVEFORM
		ELSE
			RETURN
		ENDIF
	ENDIF

	IF UPPER(toFORM.BASECLASS)<>'FORM'
		RETURN
	ENDIF

	lcOBJETO = ALLTRIM(UPPER(toFORM.NAME))
	IF EMPTY(lcOBJETO) OR lcOBJETO='SYSTEM_AJUDA'
		RETURN
	ENDIF

	=CHAMAFORM( 'SYSTEM_AJUDA' ,'', toFORM )
RETURN

PROC SYSROTF8
*************
* APLICAR O VALOR ATUAL DA CALCULADORA NO CAMPO ATUAL
	LOCAL loF8 AS Object
	LOCAL lnOK, lnQT_DECIMAIS AS Integer
	LOCAL lnCALCULO AS Number
	LOCAL lcPICT AS String
	lnOK = 0
	DEACTIVATE WINDOW CALCULATOR
	TRY
		loF8 = _SCREEN.ACTIVEFORM.ACTIVECONTROL
		lnOK=1
	CATCH
		lnOK=0
	FINALLY
	ENDTRY
	IF lnOK=0
		RETURN
	ENDIF
	IF UPPER(loF8.BASECLASS)<>'TEXTBOX'
		RETURN
	ENDIF
	IF NOT loF8.ENABLED OR loF8.READONLY
		RETURN
	ENDIF
	IF TYPE('loF8.VALUE')<>'N'
		RETURN
	ENDIF
	IF EMPTY(loF8.INPUTMASK)
		lnCALCULO = INT(_CALCVALUE)
	ELSE
		lnQT_DECIMAIS	= LEN( STREXTRACT(loF8.INPUTMASK,'.','') )
		lcPICT			= REPLICATE('9',14) + '.' + REPLICATE('9',lnQT_DECIMAIS)
		lnCALCULO		= VAL(TRANSFORM(ROUND(_CALCVALUE,lnQT_DECIMAIS), lcPICT ))
	ENDIF
	loF8.VALUE = lnCALCULO
	RELEASE loF8
RETURN

FUNC SYSROTF4			
*************
	LOCAL loMASTER AS Object

	* TELA DE APOIO (PEGAR DADOS)
	* VERIFICA SE ESTA TUDO OK (VARIAVEL, OBJETO, TABELAF4, ETC)
	IF TYPE('_SCREEN.ACTIVEFORM.ACTIVECONTROL')<>'O'
		RETURN
	ELSE
		loMASTER = _SCREEN.ACTIVEFORM.ACTIVECONTROL
	ENDIF

	* F4 JÁ ESTA ENDO EXECUTADO ENTÃO NÃO EXECUTA DE NOVO
*!*		IF TYPE('goAPLICATIVO.F4_STILLRUN')='L'
*!*			IF goAPLICATIVO.F4_STILLRUN
*!*				RETURN
*!*			ENDIF
*!*		ENDIF

	PRIVATE poCORRENTE AS OBJECT

	LOCAL lcAUXPO, lcORIGEM_CPO, lcORIGEM_TAB, lcCONDIEMP, lcNOVOENDERECO, lcEMPEXTRA AS String
	LOCAL llTEVEGRID AS Logical
	LOCAL lnFILTROEMP,lnDATASESSION AS Integer
	STORE .F. TO llTEVEGRID
	STORE '' TO lcAUXPO, lcORIGEM_CPO, lcORIGEM_TAB, lcCONDIEMP, lcNOVOENDERECO
	STORE -1 TO lnFILTROEMP

	* FLAG INDICATIVA PARA F4 EM EXECUÇÃO
*!*		goAPLICATIVO.F4_STILLRUN = .T.
	
	* CONTROLE DE F4 DENTRO DE UM GRID
	IF UPPER(loMASTER.BASECLASS) = 'GRID'
		lcAUXPO			= 'loMASTER.COLUMN' + ;
							ALLTRIM(STR(loMASTER.ACTIVECOLUMN)) + ;
							'.TEXT1'
		IF TYPE(lcAUXPO) <> 'O'
*!*				goAPLICATIVO.F4_STILLRUN = .F.
			RETURN
		ENDIF
		poCORRENTE		= &lcAUXPO
		* CONTROLE DE ATUALIZAÇÃO DE CONTEUDO
		lcORIGEM_TAB	= ALLTRIM(UPPER(loMASTER.RecordSource))
		lcORIGEM_CPO	= ALLTRIM(UPPER(poCORRENTE.CONTROLSOURCE))
		llTEVEGRID		= .T.
		lnDATASESSION	= SET("DataSession")
		IF TYPE('poCORRENTE.Parent.Parent.Parent.DataSessionId')='N'
			IF poCORRENTE.Parent.Parent.Parent.DataSessionId>0
				lnDATASESSION = poCORRENTE.Parent.Parent.Parent.DataSessionId
			ENDIF
		ENDIF
	ELSE
		poCORRENTE	= loMASTER
	ENDIF
	RELEASE loMASTER

	IF NOT ALLTRIM(UPPER(poCORRENTE.BASECLASS)) $ ',TEXTBOX,EDITBOX,'
*!*			goAPLICATIVO.F4_STILLRUN = .F.
		RETURN
	ENDIF

	* NÃO PODERÁ SER CHAMADO QUANDO FOR READONLY
	IF PEMSTATUS(poCORRENTE,'READONLY',5)
		IF poCORRENTE.READONLY
			RETURN
		ENDIF
	ENDIF

	PRIVATE pcF4STRING, pcCONDAUX AS String
	LOCAL lcNOMETAB, lcAUX AS String
	STORE '' TO pcF4STRING, pcCONDAUX, lcNOMETAB

	IF ALLTRIM(UPPER(poCORRENTE.BASECLASS)) = 'EDITBOX'
		* TODOS OS OBJETOS (EDITBOX) TERÃO F4 PELA TABELA DE TEXTOS
		pcF4STRING	= 'FORM:SYSTEM_F4TEXTOS'
	ELSE
		IF INLIST( TYPE('poCORRENTE.Value'), 'D', 'T' )
			* USAR FORM DE CALENDARIO
			pcF4STRING	= 'FORM:SYSTEM_CALENDARIO'
		ELSE
			* USAR FORM DE "CORRIGIR ENDEREÇO"
			IF '<END>' $ UPPER( poCORRENTE.COMMENT)
*!*					goAPLICATIVO.F4_STILLRUN = .F.
				DO FORM SYSTEM_ENDERECO WITH poCORRENTE
				RETURN
            ENDIF
    
            IF EMPTY(poCORRENTE.TAG)
*!*	            	goAPLICATIVO.F4_STILLRUN = .F.
				RETURN
            ENDIF
            
			lcNOMETAB = ALLTRIM(STREXTRACT(poCORRENTE.COMMENT,'<F4>','</F4>'))
			IF EMPTY(lcNOMETAB)
				lcNOMETAB = poCORRENTE.TAG
			ENDIF
			* SINTAXE DA SELECT
			pcF4STRING	= EVALUATE('MONTAF4(lcNOMETAB)')
			pcF4STRING	= STRTRAN(pcF4STRING,CHR(9),'')
			pcF4STRING	= ALLTRIM(pcF4STRING)
			pcF4STRING	= UPPER(pcF4STRING)
			IF EMPTY(pcF4STRING)
*!*					goAPLICATIVO.F4_STILLRUN = .F.
				RETURN
			ENDIF
		ENDIF

	ENDIF

	PRIVATE pcF4OPCOES, pcCAMPOF4, lcFORMF4  AS String
	PRIVATE	pnOCOCOMBO AS Integer
	STORE '' TO pcF4OPCOES, pcCAMPOF4
	STORE 1  TO pnOCOCOMBO

	IF 'FORM:' $ pcF4STRING
		lcFORMF4 = STRTRAN(pcF4STRING,'FORM:','')
*!*			goAPLICATIVO.F4_STILLRUN = .F.
		IF INLIST( TYPE('poCORRENTE.Value'), 'D', 'T' )
			DO CHAMAFORM WITH lcFORMF4, '', poCORRENTE
		ELSE
			DO CHAMAFORM WITH lcFORMF4, ''
		ENDIF
	ELSE
		* FILTRO ADICIONAL DO F4
		lcAUX		= ALLTRIM(STREXTRACT(poCORRENTE.COMMENT,'<F4COND>','</F4COND>'))
		lcAUX		= '_SCREEN.ACTIVEFORM.' + lcAUX
		IF TYPE(lcAUX) = 'C'
			pcCONDAUX	= &lcAUX
		ENDIF
		* FILTRO DE EMPRESA DO USUARIO
		lnFILTROEMP	= goAPLICATIVO.VFKEMPRESA(poCORRENTE.TAG)
		IF lnFILTROEMP > 0
			* lcCONDIEMP = goAPLICATIVO.EMPFILTRO
			lcEMPEXTRA = ALLTRIM(IIF(EMPTY(goAPLICATIVO.F4SQLALIAS),poCORRENTE.TAG,goAPLICATIVO.F4SQLALIAS))
			lcCONDIEMP = goAPLICATIVO.EMPFILTRO_COMEXTRA(lcEMPEXTRA)
			IF lnFILTROEMP=2
				* TEM FILTRO E É PELO PK_ID (TB_EMPRESAS)
				lcCONDIEMP = STRT(lcCONDIEMP,'FK_EMPRESA','PK_ID')
			ENDIF
			IF NOT EMPTY(goAPLICATIVO.F4SQLALIAS)
				lcCONDIEMP	= ALLTRIM(goAPLICATIVO.F4SQLALIAS) + '.' + lcCONDIEMP
			ELSE
				lcCONDIEMP	= ALLTRIM(poCORRENTE.TAG) + '.' + lcCONDIEMP
			ENDIF
			* CONCATENA NA STRING DE CONDIÇÃO JA EXISTENTE
			IF NOT EMPTY(pcCONDAUX)
				pcCONDAUX	= pcCONDAUX + ' AND (' +lcCONDIEMP + ')'
			ELSE
				pcCONDAUX	= '(' + lcCONDIEMP + ')'
			ENDIF
		ENDIF

		DO MONTAOPCOES
		DO FORM SYSTEM_ROTF4
	ENDIF

	IF llTEVEGRID
		* SÓ VOLTA DATASSESSION CASO NÃO CONSIGA "ENCONTRAR" O CURSOR DE ORIGEM
		IF NOT USED(lcORIGEM_TAB) AND lnDATASESSION>0
			SET DATASESSION TO lnDATASESSION
		ENDIF
		
		SELE (lcORIGEM_TAB)
		REPLACE &lcORIGEM_CPO WITH poCORRENTE.VALUE
	ENDIF

	* FECHANDO ARQUIVO DE PESQUISA
	IF USED('TMPGRIDF4')
		USE IN TMPGRIDF4
	ENDIF
	
	goAPLICATIVO.F4TITULO	= ''
	goAPLICATIVO.F4INCLUIR	= ''
	goAPLICATIVO.F4SQLALIAS	= ''
	
*!*		goAPLICATIVO.F4_STILLRUN = .F.
RETURN

PROC MONTAOPCOES
****************
	LOCAL lnOCO, lnXI, lnMEMOWIDTH AS Integer
	LOCAL lcAUX AS String

	* ALTERA MEMOWIDTH 	
	lnMEMOWIDTH = SET("Memowidth")
	SET MEMOWIDTH TO 1024
	
	* MONTA OPÇÕES DO F4
	lnOCO = MEMLINES(pcF4STRING)
	IF lnOCO > 1
		FOR lnXI = 1 TO lnOCO
			lcAUX		= STRTRAN( MLINE(pcF4STRING,lnXI), CHR(9), '')
			pcF4OPCOES	= pcF4OPCOES + ;
							IIF(EMPTY(pcF4OPCOES),'',',') + ;
							ALLTRIM(STREXTRACT(lcAUX,':',':',1))
		ENDFOR
	ELSE
		lcAUX		= STRTRAN( pcF4STRING, CHR(9), '')
		pcF4OPCOES	= ALLTRIM(STREXTRACT(lcAUX,':',':',1))
	ENDIF
	
	* VOLTA MEMOWIDTH PARA COMO ESTAVA ANTES
	SET MEMOWIDTH TO lnMEMOWIDTH
RETURN

PROC TRAZARQF4
**************
	*FECHA ARQUIVO SE ELE AINDA ESTIVER ABERTO
	IF USED('TMPGRIDF4')
		USE IN TMPGRIDF4
	ENDIF

	PRIVATE pcCOMANDOF4 AS String
	pcCOMANDOF4 = ''
	DO MONTASTRINGS
	=PESQUISASQL(pcCOMANDOF4,'TMPGRIDF4')

	IF RECCOUNT()=0
		APPEND BLANK
	ENDIF

	* POSICIONANDO REGISTRO DE ACORDO COM O QUE ESTA DIGITADO NO TEXTBOX
	SELE TMPGRIDF4
	LOCAL laSTRU[1]
	LOCAL lcNOMECAMPO AS String
	=AFIELDS(laSTRU)
	lcNOMECAMPO = laSTRU[1,1]
	LOCATE FOR &lcNOMECAMPO = poCORRENTE.VALUE
	IF EOF()
		GO TOP
	ENDIF
RETURN

PROC MONTASTRINGS
*****************
*MONTA STRING DO ARQUIVO F4 E DEFINE LAY-OUT DOS CAMPOS
	LOCAL lcCMD, lcAUX, lcCAMPOX, lcTIPOVAR AS String
	LOCAL llDUPLOLIKE AS Logical
	LOCAL lnMEMOWIDTH AS Integer 
	STORE '' TO lcCMD, lcAUX, lcCAMPOX, lcTIPOVAR
	STORE .F. TO llDUPLOLIKE

	lcTIPOVAR	= 'C'
	
	* ALTERA O TAMANHO DO MEMOWIDTH PARA EXTRAIR STRING DA SELECT
	lnMEMOWIDTH = SET("Memowidth")
	SET MEMOWIDTH TO 1024
	lcAUX		= STRTRAN(MLINE(pcF4STRING,pnOCOCOMBO),CHR(9),'')
	SET MEMOWIDTH TO lnMEMOWIDTH

	IF '=<<COND' $ lcAUX
		lcTIPOVAR	= 'N'
	ENDIF
	IF '%<<COND' $ lcAUX
		lcAUX		= STRTRAN( lcAUX, '%<<COND', '<<COND' )
		llDUPLOLIKE	= .T.
	ENDIF

	* CAMPO DIGITADO PELO USUARIO
	lcCAMPOX	= pcCAMPOF4
	lcCAMPOX	= STRTRAN(lcCAMPOX,"'","")
	
	* COMENTADO POR: EWERTON CARREIRA
	* EM: 23/06/2015
	* MOTIVO: AO REMOVER AS % NÃO CONSEGUIMOS FAZER BUSCA COM CARACTERES CORINGAS
	*lcCAMPOX	= STRTRAN(lcCAMPOX,"%","")

	DO CASE
		CASE lcTIPOVAR = 'C'
			IF TYPE('plCHKBUSCAMEIO') = 'L'
				IF plCHKBUSCAMEIO
					llDUPLOLIKE = .T.
				ENDIF
			ENDIF
			IF llDUPLOLIKE OR plCHKBUSCAMEIO
				lcCAMPOX	= XX(lcCAMPOX,'%LIKE%')
			ELSE
				lcCAMPOX	= XX(lcCAMPOX,'LIKE%')
			ENDIF

		CASE lcTIPOVAR = 'N'
			lcCAMPOX	= XX(VAL(lcCAMPOX))

	ENDCASE

	IF '<<CONDX>>' $ lcAUX
		* INSTRUÇÃO DE SQL PESADA (VARIOS REGISTROS)
		lcAUX		= STRTRAN(lcAUX,'<<CONDX>>','<<COND>>')
		pcF4STRING	= STRTRAN(pcF4STRING,'<<CONDX>>','<<COND>>')
		lcCAMPOX	= " '%' AND "
		IF NOT EMPTY(goAPLICATIVO.F4SQLALIAS)
			lcCAMPOX	= lcCAMPOX + goAPLICATIVO.F4SQLALIAS
		ELSE
			lcCAMPOX	= lcCAMPOX + ALLTRIM(poCORRENTE.TAG)
		ENDIF
		lcCAMPOX	= lcCAMPOX + '.PK_ID=' + XX(poCORRENTE.VALUE)
	ENDIF

	* CONDIÇÃO AUXILIAR DO F4
	IF NOT EMPTY(pcCONDAUX)
		lcCAMPOX	= lcCAMPOX + ' AND ' + pcCONDAUX
	ENDIF
	IF TYPE('pcINATIVO')='C'
		lcCAMPOX = lcCAMPOX + pcINATIVO
	ENDIF	
	* INSERINDO NO COMANDO SQL DO F4
	pcCOMANDOF4	= ALLTRIM(STREXTRACT(lcAUX,':',':',2))
	pcCOMANDOF4	= STRTRAN(pcCOMANDOF4,'<<COND>>',lcCAMPOX)

RETURN

FUNC AUTORIZOU
**************
LPARAMETERS tcMENSAGEM, tcGRUPOAUTO, tuPK_ID, tcTABELA
* tcMENSAGEM	= MENSAGEM QUE SERÁ EXIBIDA NA TELA DE AUTORIZAÇÃO
* tcGRUPOAUTO	= GRUPOS QUE TEM AUTORIZAÇÃO 
	** O PARAMETRO DE GRUPO AUTORIZADO PODE SER PASSADO DA SEGUINTE FORMA:
		*** '<GRUPOS>[GRUPOS QUE POSSUEM DIREITO]</GRUPOS>'
		*** '<ZW>[NOME DA ZW QUE CONTEM GRUPOS COM DIREITO]</ZW>'
		*** '<ROTINA>[NOME DA ROTINA QUE CONTEM OS GRUPOS COM DIREITO]</ROTINA>'
		*** '[ID DA TABELA TB_FECHAMENTOS]'
* tuPK_ID		= PK_ID QUE SERÁ GRAVADO NO LOG
* tcTABELA 		= NOME DA TABELA QUE SERÁ GRAVADA NO LOG

	IF TYPE('tcMENSAGEM') <> 'C'
		tcMENSAGEM	= ''
	ENDIF
	IF TYPE('tcGRUPOAUTO') <> 'C'
		tcGRUPOAUTO	= ''
	ENDIF
	IF TYPE('tcTABELA') <> 'C'
		tcTABELA	= ''
	ENDIF
	IF NOT TYPE('tuPK_ID') $ 'CN'
		tuPK_ID		= ''
	ENDIF
	IF TYPE('tuPK_ID') = 'N'
		tuPK_ID		= ALLTRIM(STR(tuPK_ID))
	ENDIF

	PRIVATE pnFK_USUARIO AS Integer
	LOCAL lcPARAMETRO AS String
	pnFK_USUARIO	= 0
	lcPARAMETRO	= '|' + tcMENSAGEM + '|' + tcGRUPOAUTO + '|' + tuPK_ID + '|' + tcTABELA + '|'

	DO FORM SYSTEM_AUTORIZAR WITH lcPARAMETRO

RETURN( pnFK_USUARIO )

PROC TOTSEGMENTO
****************
PARAMETERS tcALIAS AS String

	IF TYPE('tcALIAS') <> 'C'
		tcALIAS = ''
	ENDIF
	IF EMPTY(tcALIAS)
		DO MENS WITH 'Selecione uma tabela para ser totalizada!'
		RETURN
	ENDIF

	LOCAL lcPICTSEG ,lcNOMEARQ ,lcCOMANDO, lcLETRA AS String
	LOCAL lnXI, lnOCOGRUPO AS Integer
	STORE '' TO lcPICTSEG ,lcNOMEARQ ,lcCOMANDO, lcLETRA

	lcPICTSEG = ALLTRIM(RETORNASET('SEGMENTOS.PICTURE','C',1))

	lcCOMANDO = "SELECT PK_ID ,DS_SEGMENTO FROM TB_SEGMENTOS ORDER BY PK_ID"
	=PESQUISASQL(lcCOMANDO,'TMPAUXSEG')

	SELE TMPAUXSEG
	INDEX ON PK_ID TO TEMPFILE()

	* VARRE BYTE A BYTE, TRABALHANDO COM CADA BLOCO DE TOTALIZAÇÃO
	FOR lnXI = 1 TO LEN(lcPICTSEG)

		* VERIFICA SE É UM GRUPO
		lcLETRA	= SUBSTR(lcPICTSEG,lnXI,1)
		IF lcLETRA =  '.'
			lnOCOGRUPO	= LEN( STRTRAN(LEFT(lcPICTSEG,lnXI),'.','') )
			lcNOMEARQ	= TEMPFILE()

			* CRIA UMA TMP COM A TOTALIZAÇÃO DOS CAMPOS DE VALORES
			SELE (tcALIAS)
			TOTAL TO &lcNOMEARQ ON LEFT(FK_SEGMENTO,lnOCOGRUPO)
			USE &lcNOMEARQ ALIAS TOTGRUPO IN 0

			SELE TOTGRUPO
			SCAN WHILE NOT EOF()
				* FK_SEGMENTO VIRA FK_SEGMENT NO "TOTAL"
				IF LEN(ALLTRIM(FK_SEGMENT)) < lnOCOGRUPO
					LOOP
				ENDIF
				SELE TOTGRUPO
				SCATTER NAME loTOT

				SELE (tcALIAS)
				=ADDPROPERTY(loTOT,'FK_SEGMENTO','')
				=ADDPROPERTY(loTOT,'DS_SEGMENTO','')
				loTOT.FK_SEGMENTO = PADR( LEFT(TOTGRUPO.FK_SEGMENT,lnOCOGRUPO),12 )

				SELE TMPAUXSEG
				SET ORDER TO 1
				SEEK ALLTRIM(loTOT.FK_SEGMENTO)
				IF FOUND()
					loTOT.FK_SEGMENTO = TMPAUXSEG.PK_ID
					loTOT.DS_SEGMENTO = TMPAUXSEG.DS_SEGMENTO
				ENDIF
				
				SELE (tcALIAS)
				APPEND BLANK 
				GATHER NAME loTOT
	
			ENDSCAN
			* APAGA CURSOR DE TOTALIZAÇÃO
			SELE TOTGRUPO
			lcARQTOT = DBF()
			USE IN TOTGRUPO
			DELE FILE &lcARQTOT
		ENDIF	
	ENDFOR
	SELE (tcALIAS)
	GO TOP
RETURN

PROC MENUTOPO
*************
	SET SYSMENU TO

	LOCAL lnBAR AS Integer
	LOCAL lcFORM, lcPICT, lcGUIAS, lcAUX, lcGI AS String 
	lcGUIAS = ''

	SELECT TMPSYS
	GO TOP
	SCAN WHILE NOT EOF()
		IF TMPSYS.NR_TIPO<>0
			LOOP
		ENDIF
		IF NOT VERIFGRUPOS(GOCONEXAO.GRUPO,TMPSYS.DS_DIREITOS)
			LOOP
		ENDIF
		lcGUIAS	= lcGUIAS + STRZERO(TMPSYS.NR_GUIA,2) + ','
	ENDSCAN

	STORE '' TO lcFORM, lcPICT, lcAUX, lcGI
	STORE 0  TO lnBAR

	*--------- DEFINIÇÃO DOS PADS DE MENU------------*

	* MENU FIXO (ARQUIVO)
	DEFINE PAD ARQUIVO OF _MSYSMENU PROMPT "\<Arquivo" COLOR 3;
		NEGOTIATE  NONE, LEFT ;
		KEY ALT+A, "" 
	ON PAD ARQUIVO OF _MSYSMENU ACTIVATE POPUP popARQUIVO

	* MENU FIXO (EDITAR)
	DEFINE PAD EDITAR OF _MSYSMENU PROMPT "\<Editar" COLOR 3;
		NEGOTIATE  NONE, LEFT ;
		KEY ALT+E, "" 
	ON PAD EDITAR OF _MSYSMENU ACTIVATE POPUP popEDITAR

	* MENU FIXO (MÓDULOS)
	DEFINE PAD sysModulos OF _MSYSMENU PROMPT "\<Módulos" COLOR SCHEME 3 ;
		NEGOTIATE  NONE, LEFT ;
		KEY ALT+M, ""
	ON PAD sysModulos OF _MSYSMENU ACTIVATE POPUP popModulos

	* MENU FIXO (MÓDULOS)
	DEFINE PAD FERRAMENTAS OF _MSYSMENU PROMPT "\<Ferramentas" COLOR SCHEME 3 ;
		NEGOTIATE  NONE, LEFT ;
		KEY ALT+M, ""
	ON PAD FERRAMENTAS OF _MSYSMENU ACTIVATE POPUP popFERRAMENTAS


	* MENU FIXO (AJUDA)
	DEFINE PAD _msm_systm OF _MSYSMENU PROMPT "\<Ajuda" COLOR SCHEME 3 ;
		NEGOTIATE  NONE, RIGHT ;
		KEY ALT+A
	ON PAD _msm_systm OF _MSYSMENU ACTIVATE POPUP popAJUDA


	*------------- DEFINIÇÃO DOS POPUPS -------------*

* MENU FIXO (ARQUIVO)
	DEFINE POPUP popARQUIVO MARGIN RELATIVE SHADOW COLOR SCHEME 4
	DEFINE BAR 1  OF popARQUIVO PROMPT "R\<eexibir Desktop" KEY Ctrl+E SKIP FOR goAPLICATIVO.VALIDADE<=0
	
	* #FLAT - OPÇÃO DE ALTERNAR LAYOUT SOMENTE PARA QUEM TEM O FLAT HABILITADO
	IF RETORNASET('SISTEMA.FLAT','N',1) = 1 &&AND FILE('C:\TEMP\FLAT.TXT') 
		DEFINE BAR 2  OF popARQUIVO PROMPT "Alternar Layout (Clássico/Flat)"
	ENDIF
	
	DEFINE BAR 3  OF popARQUIVO PROMPT "\-"
	DEFINE BAR 4  OF popARQUIVO PROMPT "Ferramentas Administrativas" SKIP FOR goCONEXAO.SUPERUSUARIO<>1 OR goAPLICATIVO.VALIDADE<=0
	DEFINE BAR 5  OF popARQUIVO PROMPT "\<Trocar senha" SKIP FOR goAPLICATIVO.VALIDADE<=0
	DEFINE BAR 6  OF popARQUIVO PROMPT "\<Configurar conexão" SKIP FOR goAPLICATIVO.VALIDADE<=0
	DEFINE BAR 7  OF popARQUIVO PROMPT "\<Filtrar empresas" SKIP FOR goAPLICATIVO.VALIDADE<=0
	DEFINE BAR 8  OF popARQUIVO PROMPT "\-"
	DEFINE BAR 9  OF popARQUIVO PROMPT "Solicitar assistência remota" SKIP FOR NOT goAPLICATIVO.PERMITESAR
	DEFINE BAR 10  OF popARQUIVO PROMPT "\-"
	DEFINE BAR 11 OF popARQUIVO PROMPT "Minimizar na bandeja" KEY Ctrl+M SKIP FOR NOT goAPLICATIVO.PERMITESYSTRAY OR goAPLICATIVO.VALIDADE<=0
	DEFINE BAR 12 OF popARQUIVO PROMPT "Bloquear na bandeja" KEY Ctrl+B SKIP FOR NOT goAPLICATIVO.PERMITESYSTRAY OR goAPLICATIVO.VALIDADE<=0
	DEFINE BAR 13 OF popARQUIVO PROMPT "Sai\<r" KEY Ctrl+Q
	
	ON SELECTION BAR 1  OF popARQUIVO goCONEXAO.REEXIBIRDESKTOP()
	
	* #FLAT - OPÇÃO DE ALTERNAR LAYOUT SOMENTE PARA QUEM TEM O FLAT HABILITADO
	IF RETORNASET('SISTEMA.FLAT','N',1) = 1 &&AND FILE('C:\TEMP\FLAT.TXT') 
		ON SELECTION BAR 2  OF popARQUIVO goCONEXAO.REEXIBIRDESKTOP(1)
	ENDIF
	
	ON			 BAR 4  OF popARQUIVO ACTIVATE POPUP popTOOLSADM
	ON SELECTION BAR 5  OF popARQUIVO DO FORM SYSTEM_TROCARSENHA
	ON SELECTION BAR 6  OF popARQUIVO DO FORM SYSTEM_PARAMCONEXAO
	ON SELECTION BAR 7  OF popARQUIVO DO FORM SYSTEM_FILTRAREMPRESAS
	ON SELECTION BAR 9	OF popARQUIVO DO FORM SYSTEM_SAR
	ON SELECTION BAR 11	OF popARQUIVO goAPLICATIVO.Min2Systray()
	ON SELECTION BAR 12	OF popARQUIVO goAPLICATIVO.Bloq2Systray()
	ON SELECTION BAR 13 OF popARQUIVO DO ENCERRAR WITH 1
		
	IF goAPLICATIVO.TESTE
		* opções exclusivas da área de testes e desenvolvimento
		DEFINE BAR 14 OF popARQUIVO PROMPT "\-"
		DEFINE BAR 15 OF popARQUIVO PROMPT "Debugar SQL"
		DEFINE BAR 16 OF popARQUIVO PROMPT "De\<senvolvimento"
		ON SELECTION BAR 15 OF popARQUIVO DO ATIVARDEBUG
		ON SELECTION BAR 16 OF popARQUIVO DO ARETRA
	ENDIF
		
	* MENU FERRAMENTAS ADMINISTRATIVAS
	DEFINE POPUP popTOOLSADM MARGIN SHADOW COLOR SCHEME 4
	DEFINE BAR 1 OF popTOOLSADM PROMPT 'Gerenciar \<Desktop'
	DEFINE BAR 2 OF popTOOLSADM PROMPT "\<Simular outro usuário"

	ON SELECTION BAR 1 OF popTOOLSADM DO FORM SYSTEM_DESKTOPMANAGER
	ON SELECTION BAR 2 OF popTOOLSADM DO FORM SYSTEM_SIMULARUSUARIO

	* MENU FIXO (EDITAR)
	DEFINE POPUP popEDITAR MARGIN RELATIVE SHADOW COLOR SCHEME 4
	DEFINE BAR _med_undo OF popEDITAR PROMPT "Desfa\<zer" ;
		KEY CTRL+Z, "Ctrl+Z" ;
		PICTRES _med_undo 
	DEFINE BAR _med_redo OF popEDITAR PROMPT "\<Refazer" ;
		KEY CTRL+R, "Ctrl+R" ;
		PICTRES _med_redo 
	DEFINE BAR _med_sp100 OF popEDITAR PROMPT "\-" ;
		PICTRES _med_sp100
	DEFINE BAR _med_copy OF popEDITAR PROMPT "\<Copiar" ;
		KEY CTRL+C, "Ctrl+C" ;
		PICTRES _med_copy 
	DEFINE BAR _med_paste OF popEDITAR PROMPT "Co\<lar" ;
		KEY CTRL+V, "Ctrl+V" ;
		PICTRES _med_paste 
	DEFINE BAR _med_cut OF popEDITAR PROMPT "Recor\<tar" ;
		KEY CTRL+X, "Ctrl+X" ;
		PICTRES _med_cut
	DEFINE BAR _med_cut OF popEDITAR PROMPT "Copiar \<do Mouse" ;
		KEY CTRL+D, "Ctrl+D" ;
		PICTRES _med_copy

	* MENU VARIÁVEL (VEM DO TS_MODULOS, DEPENDENDO DOS DIREITOS DO USUÁRIO)
	DEFINE POPUP popModulos MARGIN RELATIVE SHADOW COLOR SCHEME 4
	
	* MENU VARIÁVEL (VEM DO TS_MODULOS, DEPENDENDO DOS DIREITOS DO USUÁRIO)
	LOCAL lcNOMEPOP1, lcNOMEPOP2, lcCHAMADA, lcCAPPAD, lcCAPCOL, lcGI AS STRING
	lcGI = 'ZZZ'
	LOCAL lnBARRA, lnBARRA2, lnGUIA, lnCOLUNA AS Integer
	STORE 0 TO lnBARRA, lnBARRA2, lnGUIA, lnCOLUNA
	lnGUIA = 2

	DEFINE BAR 1 OF popModulos PROMPT 'Procurar atalho...' KEY ALT+L, 'ALT+L'
	
	DEFINE BAR 2 OF popModulos PROMPT "\-"
	ON SELECTION BAR 1 OF popModulos DO FORM SYSTEM_PROCURARATALHO

	SELECT TMPSYS
	GO TOP
	SCAN WHILE NOT EOF()
		IF NOT STRZERO(TMPSYS.NR_GUIA,2) $ lcGUIAS
			LOOP
		ENDIF
		IF TMPSYS.NR_GUIA=0
			LOOP
		ENDIF
		IF TMPSYS.NR_TIPO>1
			LOOP
		ENDIF
		lcCHAMADA	= ALLTRIM(TMPSYS.DS_ROTINA)
		lcCAPPAD	= ALLTRIM(TMPSYS.DS_TITULO)
		IF TMPSYS.NR_TIPO=0
			lcNOMEPOP1 = 'pop'+STRZERO(TMPSYS.PK_ID,5)
			lcNOMEPOP2 = ''
			lnGUIA = lnGUIA + 1
			DEFINE BAR lnGUIA OF popModulos PROMPT lcCAPPAD
			ON BAR lnGUIA OF popModulos ACTIVATE POPUP (lcNOMEPOP1)
			DEFINE POPUP (lcNOMEPOP1) MARGIN RELATIVE SHADOW COLOR SCHEME 4
			lnBARRA = 0
			lnBARRA2 = 0
			lcGI = 'ZZZ'
			LOOP
		ENDIF
		IF NOT VERIFGRUPOS(GOCONEXAO.GRUPO,TMPSYS.DS_DIREITOS)
			LOOP
		ENDIF
		IF EMPTY(lcGI)
			lcGI	= TMPSYS.DS_GI
		ENDIF

*!*			IF TMPSYS.DS_GI <> lcGI
*!*				lnBARRA	= lnBARRA + 1
*!*				DEFINE BAR lnBARRA OF (lcNOMEPOP1) PROMPT "\-"
*!*			ENDIF

		* MENU DO GI (COLUNA)
		IF TMPSYS.DS_GI<>lcGI
			lcNOMEPOP2 = 'pop'+STRZERO(TMPSYS.PK_ID,5)
			lcCAPCOL = TMPSYS.DS_GINOME
			lcGI = TMPSYS.DS_GI
			lnBARRA	= lnBARRA + 1
			lnBARRA2 = 0
			IF EMPTY(lcCAPCOL)
				lcCAPCOL = 'Coluna '+TRANSFORM(lnBARRA)
			ELSE
				lcCAPCOL = TMPSYS.DS_GINOME
			ENDIF
			DEFINE BAR lnBARRA OF (lcNOMEPOP1) PROMPT lcCAPCOL
			ON BAR lnBARRA OF (lcNOMEPOP1) ACTIVATE POPUP (lcNOMEPOP2)
			DEFINE POPUP (lcNOMEPOP2) MARGIN RELATIVE SHADOW COLOR SCHEME 4
		ENDIF

		* CHAMADA DA ROTINA PELO MENU
		lnBARRA2	= lnBARRA2 + 1
		lcFORM		= ALLTRIM(TMPSYS.DS_ROTINA)
		DEFINE BAR lnBARRA2 OF (lcNOMEPOP2) PROMPT lcCAPPAD SKIP FOR goAPLICATIVO.VALIDADE<=0
		lcPARAM = NVL(TMPSYS.DS_PARAMETROS,' ')
		IF NOT EMPTY(lcPARAM)
			IF VAL(lcPARAM)>0
				lcPARAM = ', '+lcPARAM
			ELSE
				lcPARAM = ', '+XX(lcPARAM)
			ENDIF
		ENDIF
		lcAUX = "ON SELECTION BAR lnBARRA2 OF (lcNOMEPOP2) DO CHAMAFORM WITH '" +lcFORM+ "',' '" + lcPARAM
		&lcAUX
	ENDSCAN

	* MENU FIXO (JANELA)
	DEFINE POPUP popJANELA MARGIN RELATIVE SHADOW COLOR SCHEME 4
	DEFINE BAR _mwi_cascade OF popJANELA PROMPT "Ca\<scata" ;
		PICTRES _mwi_cascade
	DEFINE BAR _mwi_arran OF popJANELA PROMPT "\<Lado a Lado" ;
		PICTRES _mwi_arran

	* MENU FIXO (FERRAMENTAS)
	DEFINE POPUP popFERRAMENTAS MARGIN RELATIVE SHADOW COLOR SCHEME 4
	DEFINE BAR 1 OF popFERRAMENTAS PROMPT "Log de performance" KEY CTRL+F7, 'CTRL+F7'
	DEFINE BAR 2 OF popFERRAMENTAS PROMPT "Quick-mail" KEY F9, 'F9'
	
	ON SELECTION BAR 1 OF popFERRAMENTAS DO FORM SYSTEM_LOGPERFORMANCE
	ON SELECTION BAR 2 OF popFERRAMENTAS DO QUICKMAIL_CALL

	* MENU FIXO (AJUDA)
	DEFINE POPUP popAJUDA MARGIN RELATIVE SHADOW COLOR SCHEME 4
	DEFINE BAR 1 OF popAJUDA PROMPT "\<Tópicos de ajuda";
		KEY F1, "F1"
	DEFINE BAR 2 OF popAJUDA PROMPT "\<Manuais do usuário"
	DEFINE BAR 3 OF popAJUDA PROMPT "\<Suporte técnico"
	DEFINE BAR _mst_sp200 OF popAJUDA PROMPT "\-" 
	DEFINE BAR 4 OF popAJUDA PROMPT "Calculadora"
	
	DEFINE BAR _mst_sp300 OF popAJUDA PROMPT "\-"
	DEFINE BAR 6 OF popAJUDA PROMPT "Sobre"
	ON SELECTION BAR 1 OF popAJUDA DO SYSHELP
	ON SELECTION BAR 2 OF popAJUDA DO STARTAFILE WITH 'www.pwi.com.br/manuais/volpe/manuais.htm',1
	ON SELECTION BAR 3 OF popAJUDA DO FORM SYSTEM_SUPORTETECNICO
	ON SELECTION BAR 4 OF popAJUDA acti wind calculator
	ON SELECTION BAR 6 OF popAJUDA DO FORM SYSTEM_SOBRE
	
	* #FLAT  
	IF goAPLICATIVO.TESTE OR goAPLICATIVO.WAWATIVO = 0 
		*#FLATTEMP - INCLUIR ATALHO DO MIGRADOR
		*DEFINE BAR 7 OF popAJUDA PROMPT "\-"
		*DEFINE BAR 8  OF popAJUDA PROMPT "Migrar para layout FLAT"
		*ON SELECTION BAR 8 OF popAJUDA DO FORM FLAT_MIGRACAO
	ENDIF 

RETURN

PROC ATIVARDEBUG
****************
	goAPLICATIVO.DEBUGSQL = 0
	IF SIMOUNAO('Ativar debug de sintaxes Sql. Sim=ATIVAR Não=DESATIVAR.','DEBUG SQL',2)
		goAPLICATIVO.DEBUGSQL = 1
	ENDIF
RETURN

PROC ATUSQL
***********************************************************************
* ATUSQL - ATUALIZA BASE SQL DE ACORDO COM A AÇÃO DESEJADA	- *
***********************************************************************
PARAMETERS tcACTION, tcTABELA, tcOUTROS, tcCAMPOSUPDATE
	* PARAMETRO1 - ACAO (A/M/D)
	* PARAMETRO2 - TABELA
	* PARAMETRO3 - STRING CONTENDO PALAVRAS-CHAVE
	* PARAMETRO4 - CAMPOS EXCEÇÕES (SE VAI GRAVAR OU NÃO, DEPENDE DAS PALAVRAS-CHAVE)
	* PALAVRAS-CHAVE:
	* NOAUTOINC = INDICA QUE O PK_ID NÃO É AUTONUMERAÇÃO (PRECISA GRAVA-LO)
	* NOSTOP = SE DER ERRO, NÃO PARA A APLICAÇÃO E LOGA O REGISTRO (USADO EM IMPORTAÇÕES)
	* UPDATE=NO = INDICA QUE OS CAMPOS RELACIONADOS DEVEM SER IGNORADOS
	* UPDATE=YES= INDICA QUE OS SÓ CAMPOS RELACIONADOS DEVEM SER GRAVADOS
	* ERRO=CONTINUE = INDICA QUE EM CASO DE ERRO NA GRAVACAO DEVE AVISAR, IGNORAR E PROSSEGUIR
	* ERRO=LOG = INDICA QUE NÃO VAI DAR MENSAGEM DE ERRO SQL, APENAS GERAR LOG
	* ALCA=n = INDICA QUE DEVE EXECUTAR EM OUTRA ALÇA DE CONEXÃO (USADO EM INTEGRAÇÕES)
	* FORCEDH = INDICA QUE É PARA MANTER O DH_INC/DH_ALT QUE ESTÁ NO CUSROR (NÃO USAR O DO GETDATE-SQL)
	IF TYPE('tcACTION') <> 'C'
		DO MENS WITH 'Nenhuma ação foi informada (ATUSQL)'
		RETURN
	ENDIF
	IF EMPTY(ALIAS())
		DO MENS WITH 'Nenhuma tabela selecionada (ATUSQL)'
		RETURN
	ENDIF
	IF NOT tcACTION $ 'AMD'
		DO MENS WITH 'Ação informada não foi reconhecida: ('+tcACTION+') ATUSQL'
		RETURN
	ENDIF
	IF TYPE('tcTABELA') <> 'C'
		tcTABELA = ALIAS()
	ENDIF
	IF TYPE('tcOUTROS') <> 'C'
		tcOUTROS = ''
	ENDIF
	IF TYPE('tcCAMPOSUPDATE') <> 'C'
		tcCAMPOSUPDATE = ''
	ENDIF
	tcCAMPOSUPDATE = VIRGULAR(STRTRAN(tcCAMPOSUPDATE,' ',''))

	lnUPDATE = 0
	IF 'UPDATE=NO' $ tcOUTROS
		lnUPDATE = 1
		tcCAMPOSUPDATE	= STRTRAN( tcCAMPOSUPDATE, 'DH_INCLUSAO', '' )
		tcCAMPOSUPDATE	= STRTRAN( tcCAMPOSUPDATE, 'DH_ALTERACAO', '' )
		tcCAMPOSUPDATE	= STRTRAN( tcCAMPOSUPDATE, 'FK_OWNER', '' )
	ENDIF
	IF 'UPDATE=YES' $ tcOUTROS
		lnUPDATE = 2
		IF tcACTION = 'A'
			tcCAMPOSUPDATE	= tcCAMPOSUPDATE + ',DH_INCLUSAO,FK_OWNER,'
		ELSE
			tcCAMPOSUPDATE	= tcCAMPOSUPDATE + ',DH_ALTERACAO,'
		ENDIF
	ENDIF

	* INDICADOR SE É PARA FORÇAR OU NÃO OS CAMPOS DH_INC,DH_ALT
	PRIVATE tnFORCEDH AS Integer
	tnFORCEDH = 0
	IF AT('FORCEDH',tcOUTROS)>0
		tnFORCEDH= 1
	ENDIF
	
	PRIVATE ARRAY laERRO[1]
	PRIVATE lnSQLOK, lnRESP, lnIDENTITY, lnCONTEUXID, lnRESPIDENTITY, lnALCABD AS Integer
	PRIVATE lcATUSQL, lcERRO, lcALIASUI, lcCMDIDENTITY, lcMOTIVO, pcSINTAXELIXEIRA, lcALIASFOX, lcNUMERRO, lcODBCSTATE, lcNUMODBCSTATE AS String
	LOCAL lcAUX AS String
	LOCAL lnALCAP AS INTEGER
	
	* OBJETO PARA ATUALIZAÇÃO DE ESTOQUE (SALDO ON-LINE)
	PRIVATE poESTOQUE AS Object
	poESTOQUE	= CREATEOBJECT('EMPTY')
	* PROPRIEDADES GERAIS
	=ADDPROPERTY(poESTOQUE,'FK_PROANT','')
	=ADDPROPERTY(poESTOQUE,'FK_PROATU','')
	=ADDPROPERTY(poESTOQUE,'FK_ESTANT','')
	=ADDPROPERTY(poESTOQUE,'FK_ESTATU','')
	=ADDPROPERTY(poESTOQUE,'TG_ESTANT',0)
	=ADDPROPERTY(poESTOQUE,'TG_ESTATU',0)
	=ADDPROPERTY(poESTOQUE,'QT_ESTANT',0)
	=ADDPROPERTY(poESTOQUE,'QT_ESTATU',0)
	* CONTROLE DE ATUALIZAÇÃO POR FOR E TAMANHO
	=ADDPROPERTY(poESTOQUE,'FK_CORANT',SPACE(3))
	=ADDPROPERTY(poESTOQUE,'FK_CORATU',SPACE(3))
	=ADDPROPERTY(poESTOQUE,'FK_TAMANT',SPACE(3))
	=ADDPROPERTY(poESTOQUE,'FK_TAMATU',SPACE(3))
	* PROPRIEDADES PARA CONTROLE DE QTD DE NOTAS FISCAIS (E/S)
	=ADDPROPERTY(poESTOQUE,'TG_ORIANT','')
	=ADDPROPERTY(poESTOQUE,'TG_ORIATU','')
	* PROPRIEDADES PARA CONTROLE DE CONSIGNAÇÃO
	=ADDPROPERTY(poESTOQUE,'TG_CONANT',0)
	=ADDPROPERTY(poESTOQUE,'TG_CONATU',0)
	* PROPRIEDADES PARA CONTROLE DE PENDÊNCIA DE PRODUTOS (VENDAS)
	=ADDPROPERTY(poESTOQUE,'TG_PENANT',0)
	=ADDPROPERTY(poESTOQUE,'TG_PENATU',0)
	=ADDPROPERTY(poESTOQUE,'TG_PENTEM',0)
	
	* VARIAVEIS PARA RESERVA DE PRODUTOS
	PRIVATE poRESERVA AS Object
	poRESERVA	= CREATEOBJECT('EMPTY')
	* PROPRIEDADES GERAIS
	=ADDPROPERTY(poRESERVA,'FK_PROANT','')
	=ADDPROPERTY(poRESERVA,'FK_PROATU','')
	=ADDPROPERTY(poRESERVA,'FK_ESTANT','')
	=ADDPROPERTY(poRESERVA,'FK_ESTATU','')
	=ADDPROPERTY(poRESERVA,'TG_RESANT',0)
	=ADDPROPERTY(poRESERVA,'TG_RESATU',0)
	=ADDPROPERTY(poRESERVA,'QT_RESANT',0)
	=ADDPROPERTY(poRESERVA,'QT_RESATU',0)

	
	* GRAVA ESPELHO DO REGISTRO PARA ARMAZENAR NA LIXEIRA DO SISTEMA
	pcSINTAXELIXEIRA	= ''

	lnALCABD	= goCONEXAO.ALCA
	lnSQLOK		= -1				&& CONTROLE DE OPERAÇÃO BEM SUCEDIDA
	luPK_ID		= PK_ID
	lcATUSQL	= ''
	lcALIASFOX  = ALIAS()

	* ALCA DE BANCO (OPÇÃO DE USAR UMA OUTRA ALCA)
	IF 'ALCA=' $ tcOUTROS
		lnALCAP = VAL(STREXTRACT(tcOUTROS+' ','ALCA=',' '))
		IF lnALCAP>0
			lnALCABD = lnALCAP
		ENDIF
	ENDIF
	
	pnAUTOINC = 0
	IF TYPE(ALIAS()+'.PK_ID') = 'N' AND NOT 'NOAUTOINC' $ tcOUTROS
		* POR DEFAULT OS PK NUMERICOS SÃO AUTONUMERAÇÃO
		pnAUTOINC = 1
	ENDIF

	* MONTA SINTAXE COMPLETA
	DO MONTASQLC

	* TRATAMENTOS ESPECIAIS DE SINTAXE
	DO CASE
		CASE goCONEXAO.BANCO = 'POS'
			lcATUSQL = TRTSINPGSQL(lcATUSQL)
		CASE goCONEXAO.BANCO = 'ORA'
			lcATUSQL = TRATASQLORACLE(lcATUSQL)
		CASE goCONEXAO.BANCO = 'MYS'
			lcATUSQL = TRATASQLMYSQL(lcATUSQL)
		OTHERWISE
			lcATUSQL = TRATASQLMSSQL(lcATUSQL)
	ENDCASE
	
	* PROTEÇÃO CONTRA CHR(0) ASCII DE NULO
	lcATUSQL = STRTRAN(lcATUSQL, CHR(0), '')

	goCONEXAO.LASTCOMMAND   = lcATUSQL
	goCONEXAO.LASTCURSOR    = ''	
		
	* EXECUTA COMANDO NA BASE
	LOCAL lnSECINI, lnSECFIM AS Integer 
	LOCAL ldDATETIME AS Datetime
	ldDATETIME	= DATETIME()
	lnSECINI 	= SECONDS()
	lnSQLOK		= SQLEXEC(lnALCABD, lcATUSQL)
	lnSECFIM	= SECONDS()

	* LOG DE PEFORMANCE
	IF GOAPLICATIVO.LOGPERF = 1 AND lnSQLOK > 0
		LOCAL lcACAOLOG AS String
		STORE '' TO lcACAOLOG
		
		DO CASE
			CASE tcACTION = 'A'
				lcACAOLOG = 'INSERT'
			CASE tcACTION = 'M'
				lcACAOLOG = 'UPDATE'
			CASE tcACTION = 'D'
				lcACAOLOG = 'DELETE'		
		ENDCASE
		
		LOCAL lcID AS String
		STORE '' TO lcID
		DO CASE
			CASE TYPE('luPK_ID') = 'N'
				lcID = ALLTRIM(TRANSFORM(luPK_ID))
			CASE TYPE('luPK_ID') = 'C'
				lcID = ALLTRIM(luPK_ID)
		ENDCASE
		
		IF NOT EMPTY(lcID)
			LOGPERF_GRAVAR(ldDATETIME,lnSECFIM-lnSECINI,1,'ATUS',lcACAOLOG+'->'+tcTABELA+' PK_ID='+lcID)
		ELSE
			LOGPERF_GRAVAR(ldDATETIME,lnSECFIM-lnSECINI,1,'ATUS',lcACAOLOG+'->'+tcTABELA)
		ENDIF
	ENDIF
	
	IF NOT goAPLICATIVO.TESTE AND lnSQLOK<0 AND lnALCABD=goCONEXAO.ALCA 
		=AERROR(laERRO)
		* CASO SEJA ERRO DE CONEXÃO
		IF VERERROCONEXAO(laERRO[4], laERRO[5], laERRO[3])
			DO FORM SYSTEM_ERROCONEXAO
			* ATUALIZA VARIÁVEL DE ALCA DE ACESSO
			lnALCABD=goCONEXAO.ALCA
			* SE OPTOU POR RECONECTAR, TENTA REPETIR A QUERY
			lnSQLOK = REPETIRQUERY()
		ENDIF
	ENDIF
	goCONEXAO.LASTCOMMAND   = ''
	goCONEXAO.LASTCURSOR    = ''

	LOCAL lcMSG AS String
	
	IF lnSQLOK<0
		=AERROR(laERRO)
		lcNUMERRO		= ALLTRIM(STR(laERRO(1)))
		lcERRO			= laERRO[3]
		lcODBCSTATE 	= NVL(laERRO[4],' ')
		lcNUMODBCSTATE	= ALLTRIM(STR(NVL(laERRO[5],0)))
		
		goCONEXAO.LASTERRORSQL = lcNUMERRO + ' - ' + lcERRO + ' (ODBC NUM: ' + lcNUMODBCSTATE + ' - ODBC STATE: ' + lcODBCSTATE + ')'
		
		* VERIFICA SE ERRO FOI "TRATADO" 
		IF goAPLICATIVO.ERROTRATADO='ON'
			IF VEERROTRATADO_RAIZ(@laERRO)
				
				* RETORNO DE ACORDO COM TIPO DO PK_ID
				IF VARTYPE(PK_ID) = 'N'
					RETURN(0)
				ELSE
					RETURN('')
				ENDIF
			ENDIF
		ENDIF
	
		* VERIFICA SE ERRO FOI OCASIONADO DEVIDO A RESTRICT DE INTEGRIDADE REFERÊNCIAL
		IF VERERROCONSTRAINT(@laERRO)
			DO CASE
				CASE tcACTION = 'A'
					lcMSG = 'REGISTRO NÃO PODE SER INCLUÍDO POR REGRAS DO SISTEMA!' + CHR(13) +;
							'Este registro é dependente de um registro não cadastrado.'

				CASE tcACTION = 'M'
					lcMSG = 'REGISTRO NÃO PODE SER MODIFICADO POR REGRAS DO SISTEMA!' + CHR(13) +;
							'Este registro é dependente de um registro não cadastrado.'

				CASE tcACTION = 'D'
					lcMSG = 'REGISTRO NÃO PODE SER DELETADO POR REGRAS DO SISTEMA!' + CHR(13) +;
							'Existem registros que dependem do registro a ser deletado.'
				OTHERWISE
					lcMSG = ''
			ENDCASE

			DO MENS WITH lcMSG,1
			
			* RETORNO DE ACORDO COM TIPO DO PK_ID
			IF VARTYPE(PK_ID) = 'N'
				RETURN(0)
			ELSE
				RETURN('')
			ENDIF
		ENDIF
				
		DO CASE
			CASE 'ERRO=LOG' $ tcOUTROS
				* SÓ GRAVAR LOG LOCAL E CONTINUAR
				DO LOGSQLERRO WITH tcTABELA, lcNUMERRO, lcERRO, lcATUSQL
			CASE 'ERRO=CONTINUE' $ tcOUTROS
				* NÃO MOSTRA ERRO, APENAS CONTINUA
			CASE goAPLICATIVO.TESTE
				* TRATAMENTO DE ERRO CONTORNAVEL (AREA DE TESTES)
				lnRESP	= MESSAGEBOX('ERRO NO COMANDO À BASE DE DADOS: ' + CHR(13)+CHR(10)+;
									SYS(16)+CHR(13)+CHR(10)+;
									lcNUMERRO+CHR(13)+CHR(10)+;
									lcERRO,'AVISO: SQL-ERRO',48+2+256)
				IF lnRESP = 3
					IF goAPLICATIVO.TESTE
						DEBUG
						SUSPEND
					ELSE
						DO ROTERRO WITH 0-laERRO(1), lcERRO, SYS(16), 0
					ENDIF
				ENDIF
				IF lnRESP = 4
					_CLIPTEXT = lcATUSQL
				ENDIF
			OTHERWISE
				* TRATAMENTO DE ERRO CONVENCIONAL (AMBIENTE DE PRODUÇÃO)
				** TRATAMENTO DE ERRO COMUM
				DO ROTERRO WITH 0-laERRO(1), lcERRO, SYS(16), 0
				RETURN
		ENDCASE
	ELSE
		* MEDIDORES DE TRAFEGO
		LOCAL 		lnTRAFEGOVAI, lnTRAFEGOVEM AS Double
		STORE 0 TO	lnTRAFEGOVAI, lnTRAFEGOVEM 

		lnTRAFEGOVAI = LEN(lcATUSQL)
		lnTRAFEGOVEM = 1
		
		goCONEXAO.QT_QUERYS 	= goCONEXAO.QT_QUERYS + 1 
		goCONEXAO.QT_TEMPO		= goCONEXAO.QT_TEMPO + lnSECFIM-lnSECINI
		goCONEXAO.QT_TRAFEGOVAI = goCONEXAO.QT_TRAFEGOVAI + lnTRAFEGOVAI
		goCONEXAO.QT_TRAFEGOVEM = goCONEXAO.QT_TRAFEGOVEM + lnTRAFEGOVEM
	
		* SE O COMANDO DE [DELETAR] FOI BEM SUCEDIDO, GRAVA A LIXEIRA
		IF NOT EMPTY(pcSINTAXELIXEIRA) AND NOT tcTABELA $ '/TS_LIXEIRA/'
			=EXECUTASQL(pcSINTAXELIXEIRA)
		ENDIF
	ENDIF
	
	* PARA CONEXÃO ORACLE É NECESSÁRIO DAR COMMIT
	IF 'ORACLE' $ UPPER(goCONEXAO.DRIVER)
		=SQLEXEC(lnALCABD,'COMMIT') 
	ENDIF

	IF tcACTION='A' AND pnAUTOINC=1
		* SE FOI UM INSERT, PEGAR O CAMPO C/ AUTOINCREMENTO (IDENTITY)
		lcALIASUI	= ALIAS()
		lnIDENTITY	= 0
		DO PEGAULTINC WITH tcTABELA
		SELE &lcALIASUI
		IF lnIDENTITY>0
			* ATUALIZA CAMPO AUTO-NUMERAÇÃO NA BASE LOCAL
			REPLACE PK_ID WITH lnIDENTITY
		ELSE
			lnSQLOK = -2
			* EXCLUIR REGISTRO (NAO FOI INCLUIDO NO SQL)
			DELETE
			SKIP-1
			IF BOF() AND NOT EOF()
				SKIP
			ENDIF
		ENDIF
	ENDIF

	IF lnSQLOK>0 AND lnALCABD = goCONEXAO.ALCA
		* GRAVAÇÃO DE LOG DO SISTEMA
		IF '#'+tcTABELA+'#' $ goAPLICATIVO.LOGTABSIM
			DO GRAVARLOGSYS
		ENDIF
	ENDIF
	IF NOT EMPTY(lcALIASFOX)
		SELECT &lcALIASFOX
	ENDIF
RETURN(PK_ID)

PROC PEGAULTINC
***************
LPARAMETERS tcTABELA AS String
	IF TYPE('tcTABELA') <> 'C'
		tcTABELA	= ''
	ENDIF
	IF EMPTY(tcTABELA)
		RETURN
	ENDIF
	
	* PROTEÇÃO PARA PEGAR ALÇA DE CONEXÃO ATUAL
	* POIS SE A ROTINA PEGAULTINC FOR CHAMADA ATRAVÉS DO ATUSQL A VARIÁVEL lnALCADB JÁ EXISTE NO ESCOPO ATUAL DO FOX E NÃO PRECISA SER CRIADA / ALIMENTADA
	IF TYPE('lnALCABD') <> 'N'
		lnALCABD = GOCONEXAO.ALCA
	ENDIF
	
	DO CASE
		CASE goCONEXAO.BANCO = 'MYS' &&&  LINHA ALTERADA  &&&
			lcCMDIDENTITY	= 'SELECT MAX(PK_ID) ULTIMAINC FROM '+tcTABELA 
		CASE 'POSTGRES' $ UPPER(goCONEXAO.DRIVER)
			lcCMDIDENTITY	= "SELECT CURRVAL('"+tcTABELA+"_S'::text) AS ULTIMAINC" &&tcSEQUENCIA
		CASE goCONEXAO.BANCO = 'ORA'
			lcCMDIDENTITY	= 'SELECT '+tcTABELA+'_S.CURRVAL AS ULTIMAINC FROM DUAL'
		OTHERWISE
			*SQL SERVER
			lcCMDIDENTITY	= 'SELECT SCOPE_IDENTITY() AS ULTIMAINC'
	ENDCASE
	lnRESPIDENTITY	= SQLEXEC(lnALCABD, lcCMDIDENTITY, 'TMPLASTPK')

	DO CASE
		CASE lnRESPIDENTITY<0
			lcMOTIVO = 'EXEC-SQL'
		CASE TYPE('TMPLASTPK.ULTIMAINC')<>'N'
			lcMOTIVO = 'SEM PK_ID'
		CASE ULTIMAINC<=0
			lcMOTIVO = 'PK_ID SEM CONTEUDO'	
		OTHERWISE
			lcMOTIVO = ''
	ENDCASE

	IF NOT EMPTY(lcMOTIVO)
		DO MENS WITH 'ERRO NA INCLUSÃO (P/RETORNAR PK_ID): '+lcMOTIVO+' ATUSQL'
	ELSE
		*RETORNA ULTIMA INSERÇÃO
		IF TYPE('TMPLASTPK.ULTIMAINC') <> 'U'
			lnIDENTITY = TMPLASTPK.ULTIMAINC
		ENDIF
	ENDIF
	IF USED('TMPLASTPK')
		USE IN TMPLASTPK
	ENDIF
RETURN

PROC MONTASQLC
*******************
* MONTA COMANDO DE ACORDO COM A ACAO EXECUTADA NA BASE LOCAL
* OBS: A ACAO É EFETUADA NO DBF (CURSOR LOCAL) E DEPOIS PRECISA QUE SEJA ATUALIZADA
* ---- A BASE SQL. ASSIM ESTE COMANDO É MONTADO PARA SER EXECUTADO E EFETUAR ESTA TAREFA

	*CONDICAO
	LOCAL lcSQLCONDI AS String
	lcSQLCONDI = " WHERE PK_ID="+XX(luPK_ID)

	* MONTA NOME DA TABELA NO SQL
	IF tcTABELA = 'TMP'
		RETURN
	ENDIF

	* MONTANDO O CÓDIGO DE ESTOQUE PARA A TABELA DE ES_MOVIMENTOS NA INCLUSÃO
	IF tcACTION	= 'A' AND tcTABELA $ ',ES_MOVIMENTOS,VD_RESERVAS,'
		IF TYPE('FK_EMPRESA')='C' AND TYPE('FK_ESTOQUE')='C'
			IF EMPTY(FK_ESTOQUE) AND NOT EMPTY(FK_EMPRESA)
				LOCAL lnQTDEMP AS Integer
				LOCAL lcAUXEMP AS String
				FOR lnQTDEMP = 1 TO MEMLINES(goAPLICATIVO.EMPXEST)
					lcAUXEMP = MLINE(goAPLICATIVO.EMPXEST,lnQTDEMP)
					IF FK_EMPRESA = LEFT(lcAUXEMP,3)
						REPLACE FK_ESTOQUE WITH SUBS(lcAUXEMP,5)
					ENDIF
				ENDFOR
			ENDIF
		ENDIF
	ENDIF

	* MONTA SINTAXE DE CADA COMANDO, DEPENDENDO DA AÇÃO
	LOCAL lnORIGEM, lcCPOORIGEM, lcCOMANDO, lcCPOAUX AS String
	STORE '' TO lnORIGEM, lcCPOORIGEM, lcCPOAUX

	* VARIAVEIS DE ATUALIZAÇÃO DE ESTOQUE
	LOCAL llresBXATU AS Logical
	LOCAL lcestCOMANDO, lcestTABANT, lcestTGES AS String
	STORE .F. TO llresBXATU
	STORE '' TO lcestCOMANDO, lcestTABANT, lcestTGES

	lcCPOAUX = ''
	DO CASE
		CASE tcACTION = 'D'
			* DELETAR REGISTRO (DELETE)
			lcATUSQL = 'DELETE FROM '+tcTABELA+lcSQLCONDI

			* GRAVANDO ESPELHO DO REGISTRO
			lcCOMANDO = 'SELECT * FROM '+tcTABELA+lcSQLCONDI
			pcSINTAXELIXEIRA = MONTALIXEIRA( lcCOMANDO, tcTABELA, luPK_ID )

			* CONTROLE DE RESERVA DE PRODUTOS
			IF tcTABELA = 'VD_RESERVAS'
				lcestTABANT		= ALIAS()
				TEXT TO lcestCOMANDO NOSHOW PRETEXT 7
					SELECT
						FK_PRODUTO,
						QT_RESERVA,
						TG_RESERVA,
						FK_ESTOQUE,
						DT_BAIXA
					FROM
						<<TABELA>>
						<<CONDICAO>>
				ENDTEXT
				lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<TABELA>>',tcTABELA)
				lcestCOMANDO	= STRTRAN(lcestCOMANDO,'<<CONDICAO>>',lcSQLCONDI)
				=PESQUISASQL(lcestCOMANDO,'TMPESTAUX')
				SELE TMPESTAUX
				poRESERVA.TG_RESANT	= TMPESTAUX.TG_RESERVA
				poRESERVA.FK_PROANT	= TMPESTAUX.FK_PRODUTO
				poRESERVA.FK_ESTANT	= TMPESTAUX.FK_ESTOQUE
				poRESERVA.QT_RESANT	= 0 - ABS( TMPESTAUX.QT_RESERVA )
				IF NOT ISNULL(TMPESTAUX.DT_BAIXA)
					poRESERVA.QT_RESANT	= 0
				ENDIF
				USE IN TMPESTAUX
				IF NOT EMPTY(lcestTABANT)
					SELE (lcestTABANT)
				ENDIF
			ENDIF

		CASE tcACTION = 'A'
			* INCLUIR REGISTRO (INSERT)
			WQF = AFIELDS(WTABF)
			STORE '' TO lcINSERE1, lcINSERE2
			FOR WXC = 1 TO WQF
				lcCPOAUX = ALLTRIM(WTABF[WXC,1])
				IF lcCPOAUX = 'PK_ID' AND pnAUTOINC=1
					* CAMPO IDENTITY
					LOOP
				ENDIF
				IF lcCPOAUX = 'DH_ALTERACAO'
					LOOP
				ENDIF
				IF lcCPOAUX = 'ROWGUID' OR lcCPOAUX = 'MSREPL_TRAN_VERSION'
					LOOP
				ENDIF
				IF lnUPDATE=1
					IF VIRGULAR(lcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO A SER IGNORADO
						LOOP
					ENDIF
				ENDIF
				IF lnUPDATE=2
					IF NOT VIRGULAR(lcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO QUE NÃO FAZ PARTE DA RELAÇÃO
						LOOP
					ENDIF
				ENDIF
				IF EMPTY(lcINSERE1)
					lcSEPARA = ''
				ELSE
					lcSEPARA = ', '
				ENDIF

				lcCONTEUDO = XX( &lcCPOAUX )
				IF lcCPOAUX = 'DH_INCLUSAO' AND tnFORCEDH=0
					lcCONTEUDO = D2SQL(DATE(),'HOJE')
				ENDIF

				IF lcCPOAUX = 'FK_OWNER' AND tnFORCEDH=0
					lcCONTEUDO = XX(goCONEXAO.FK_USUARIO)
				ENDIF
				
				* CAMPO DE CONTROLE DE ULTIMO USUÁRIO QUE ALTEROU O REGISTRO
				IF lcCPOAUX = 'FK_USUULTGRA'
					lcCONTEUDO = XX(GOCONEXAO.FK_USUARIO)
				ENDIF
				
				IF '_KK' $ lcCPOAUX AND tnFORCEDH=0
					* CAMPO DE CONTROLE (NUNCA É FEITO UPDATE POR ESTA ROTINA)
					lcTIPO	= TYPE(lcCPOAUX)
					DO CASE
						CASE lcTIPO $ 'CM'
							lcCONTEUDO = XX('')
						CASE lcTIPO = 'N'
							lcCONTEUDO = XX(0)
					ENDCASE
				ENDIF

				lcINSERE1 = lcINSERE1 + lcSEPARA + lcCPOAUX
				lcINSERE2 = lcINSERE2 + lcSEPARA + lcCONTEUDO

			ENDFOR

			IF pnAUTOINC=1 AND 'ORACLE' $ UPPER(goCONEXAO.DRIVER)
				lcINSERE1	= 'PK_ID, ' + lcINSERE1
				lcINSERE2	= tcTABELA + '_S.NEXTVAL, ' + lcINSERE2
			ENDIF

			lcATUSQL = 'INSERT INTO '+tcTABELA+' ('+lcINSERE1+') VALUES ('+lcINSERE2+')'

		CASE tcACTION = 'M'
			* ALTERAR REGISTRO (UPDATE)
			LOCAL lcCAMPOSUP AS STRING
			WQF = AFIELDS(WTABF)
			lcCAMPOSUP = ''
			STORE '' TO lcINSERE1, lcINSERE2
			FOR WXC = 1 TO WQF
				lcCPOAUX = ALLTRIM(WTABF[WXC,1])
				IF lcCPOAUX = 'PK_ID'
					* CAMPO IDENTITY
					LOOP
				ENDIF
				IF lcCPOAUX = 'DH_INCLUSAO' AND tnFORCEDH=0
					LOOP
				ENDIF
				IF lcCPOAUX = 'ROWGUID' OR lcCPOAUX = 'MSREPL_TRAN_VERSION'
					LOOP
				ENDIF
				IF lnUPDATE=1
					IF VIRGULAR(lcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO A SER IGNORADO
						LOOP
					ENDIF
				ENDIF
				IF lnUPDATE=2
					IF NOT VIRGULAR(lcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO QUE NÃO FAZ PARTE DA RELAÇÃO
						LOOP
					ENDIF
				ENDIF
				IF '_KK' $ lcCPOAUX AND tnFORCEDH=0
					* CAMPO DE CONTROLE (NUNCA É FEITO UPDATE POR ESTA ROTINA
					LOOP
				ENDIF
				IF EMPTY(lcCAMPOSUP)
					lcSEPARA = ''
				ELSE
					lcSEPARA = ', '
				ENDIF

				lcCONTEUDO = XX( &lcCPOAUX )
				IF lcCPOAUX = 'DH_ALTERACAO' AND tnFORCEDH=0
					lcCONTEUDO = D2SQL(DATE(),'HOJE')
				ENDIF
				
				* CAMPO DE CONTROLE DE ULTIMO USUÁRIO QUE ALTEROU O REGISTRO
				IF lcCPOAUX = 'FK_USUULTGRA'
					lcCONTEUDO = XX(GOCONEXAO.FK_USUARIO)
				ENDIF

				lcCAMPOSUP = lcCAMPOSUP + lcSEPARA + lcCPOAUX + "="+lcCONTEUDO

			ENDFOR
			lcATUSQL = 'UPDATE '+tcTABELA+' SET '+ lcCAMPOSUP + lcSQLCONDI

	ENDCASE
RETURN

PROC MONTALIXEIRA
*****************
LPARAMETERS tcDELCMD, tcDELTAB, tuDELPK
	IF TYPE('tcDELCMD') <> 'C'
		tcDELCMD = ''
	ENDIF
	IF EMPTY(tcDELCMD)
		RETURN
	ENDIF
	LOCAL lnQTDFIELDS, lnXI AS Integer
	LOCAL lcAUX, lcCONTEUDO, lcCAMPO, lcCAMPOAUX, lcCOMANDO, lcARQVOL AS String
	LOCAL ARRAY laFIELDS[1]

	lcARQVOL	= ALIAS()
	=PESQUISASQL(tcDELCMD,'TMPLIXEIRA')

	lcAUX = ''
	SELE TMPLIXEIRA
	lnQTDFIELDS = AFIELDS(laFIELDS)
	FOR lnXI = 1 TO lnQTDFIELDS
		lcCAMPO		= ALLTRIM(laFIELDS[lnXI,1])
		lcCAMPOAUX	= 'TMPLIXEIRA.' + lcCAMPO
		DO CASE
			CASE laFIELDS[lnXI,2] $ 'NFIBY'
				DO CASE
					CASE LEFT(lcCAMPO,2) = 'VL'
						lcCONTEUDO	= ALLTRIM( STR( &lcCAMPOAUX , 22 , 2 ) )
					CASE LEFT(lcCAMPO,2) = 'QT'
						lcCONTEUDO	= ALLTRIM( STR( &lcCAMPOAUX , 22 , 3 ) )
					OTHERWISE
						lcCONTEUDO	= ALLTRIM( STR( &lcCAMPOAUX , 22 , 0 ) )
				ENDCASE
			CASE laFIELDS[lnXI,2] $ 'CM'
				lcCONTEUDO	= ALLTRIM( PADR( &lcCAMPOAUX ,128 ) )
			CASE laFIELDS[lnXI,2] = 'T'
				lcCONTEUDO	= ALLTRIM( TTOC( &lcCAMPOAUX ) )
			CASE laFIELDS[lnXI,2] = 'D'
				lcCONTEUDO	= ALLTRIM( DTOC( &lcCAMPOAUX ) )
		ENDCASE
		IF ISNULL(lcCONTEUDO)
			lcCONTEUDO = 'NULL'
		ENDIF
		lcAUX	= lcAUX + lcCAMPO + ' : ' + lcCONTEUDO + CHR(13)+CHR(10)
	ENDFOR
	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		INSERT INTO TS_LIXEIRA
			( DS_TABELA, FK_ID, FK_USUARIO, DH_EXCLUSAO, DS_CONTEUDO, DH_INCLUSAO )
		VALUES
			(<<TABELA>>, <<PK_ID>>, <<USUARIO>>, <<HOJE>>, <<REGISTRO>>, <<HOJE>> )
	ENDTEXT
	lcCOMANDO = STRTRAN( lcCOMANDO, CHR(13)+CHR(10)	, ' ' )
	lcCOMANDO = STRTRAN( lcCOMANDO, CHR(09)			, '' )
	lcCOMANDO = STRTRAN( lcCOMANDO, '<<TABELA>>'	, XX(tcDELTAB) )
	lcCOMANDO = STRTRAN( lcCOMANDO, '<<PK_ID>>'		, XX(tuDELPK) )
	lcCOMANDO = STRTRAN( lcCOMANDO, '<<USUARIO>>'	, XX(goCONEXAO.FK_USUARIO) )
	lcCOMANDO = STRTRAN( lcCOMANDO, '<<HOJE>>'		, D2SQL(DATE(),'HOJE') )
	lcCOMANDO = STRTRAN( lcCOMANDO, '<<REGISTRO>>'	, XX(lcAUX) )

	USE IN TMPLIXEIRA
	IF NOT EMPTY(lcARQVOL)
		SELE &lcARQVOL
	ENDIF

RETURN(lcCOMANDO)

PROC LOGSQLERRO
***************
LPARAMETERS tcTAB, tcERRN, tcERRC, tcSINTAXE
	LOCAL lcLINERRO, lcFILEERRO, lcENTER AS STRING
	lcENTER = CHR(13)+CHR(10)
	lcFILEERRO = 'ETC\ERROS.SQL'
	TRY 
		lcLINERRO = '<HORA>'+TTOC(DATETIME())+SYS(0)+'<\HORA>'+lcENTER
		=STRTOFILE(lcLINERRO,lcFILEERRO,1)
		lcLINERRO = '<TABELA>'+UPPER(tcTAB)+'<\TABELA>'+lcENTER
		=STRTOFILE(lcLINERRO,lcFILEERRO,1)
		lcLINERRO = '<ERRO>'+ALLTRIM(tcERRN)+'='+ALLTRIM(tcERRC)+'<\ERRO>'+lcENTER
		=STRTOFILE(lcLINERRO,lcFILEERRO,1)
		lcLINERRO = '<SINTAXE>'+lcENTER
		=STRTOFILE(lcLINERRO,lcFILEERRO,1)
		lcLINERRO = tcSINTAXE+lcENTER
		=STRTOFILE(lcLINERRO,lcFILEERRO,1)
		lcLINERRO = '<\SINTAXE>'+lcENTER+lcENTER+lcENTER
		=STRTOFILE(lcLINERRO,lcFILEERRO,1)
	CATCH
	ENDTRY
RETURN

PROC NEWUSER
************
*INICIAR TABELA DE USUÁRIOS QUE ESTÁ VAZIA
	LOCAL lcCOMANDO AS String
	
	lcCOMANDO="SELECT COUNT(1) AS QTDUSU FROM TS_USUARIOS"
	IF 'MYSQL' $ UPPER(goCONEXAO.DRIVER) &&&  LINHA ALTERADA (20/01/2006)
		lcCOMANDO="SELECT SUM(1) AS QTDUSU FROM TS_USUARIOS"
	ENDIF
	=PesquisaSQL(lcCOMANDO,'TMPCONUSU')
	
	
	IF TMPCONUSU.QTDUSU=0
		IF SIMOUNAO('Não existe nenhum usuário cadastrado no sistema, deseja iniciar a base de usuários?','Iniciar usuários',2)
			* GRUPO
			** CRIANDO GRUPO INICIAL DE SUPERVISOR
			lcCOMANDO1="SELECT * FROM TS_GRUPOS WHERE PK_ID=[[SUPERVISOR]]"
			lcCOMANDO1=STRTRAN(lcCOMANDO1,'[[SUPERVISOR]]',IIF(goCONEXAO.TAMANHOGRUPO=1,XX('S'),XX('SSS')))
			=PESQUISASQL(lcCOMANDO1,'TMPCONGRU')
			IF RECCOUNT('TMPCONGRU') = 0
				SELE TMPCONGRU
				SCATTER MEMVAR BLANK
				M.PK_ID=IIF(goCONEXAO.TAMANHOGRUPO=1,'S','SSS')
				M.DS_GRUPO='SUPERVISOR'
				SELE TMPCONGRU
				APPEND BLANK
				GATHER MEMVAR
				DO ATUSQL WITH 'A','TS_GRUPOS'
			ENDIF
			* USUÁRIO
			* CRIANDO USUÁRIO INICIAL DE ADMIN
			lcCOMANDO="SELECT * FROM TS_USUARIOS WHERE PK_ID=-1"
			=PesquisaSQL(lcCOMANDO,'TMPCONUSU')
			SELE TMPCONUSU
			SCATTER MEMVAR BLANK
			M.DS_LOGIN='ADMIN'
			M.DS_SENHA=CRIPTAR('ADMIN')
			M.FK_GRUPO=IIF(goCONEXAO.TAMANHOGRUPO=1,'S','SSS')
			M.DS_EMPDIREITO='TODAS'
			
			* CASO TENHA AUTENTICACAO
			IF goAPLICATIVO.AUTENTICALOGIN == 'ON'
				goAPLICATIVO.myZIP.INIT()
				goAPLICATIVO.myZIP.OPENLIB('VFPENCRYPTION.FLL')
				M.DS_AUTENTICACAO = STRCONV(goAPLICATIVO.myZIP.HASH(M.DS_SENHA+IIF(goCONEXAO.TAMANHOGRUPO=1,'S','SSS'),5),13)
			ENDIF
			
			SELE TMPCONUSU
			APPEND BLANK
			GATHER MEMVAR
			DO ATUSQL WITH 'A','TS_USUARIOS'
			DO MENS WITH 'Base de dados de usuários foi reiniciada. Utilize a senha de administrador do sistema:'+CHR(13)+CHR(13)+;
			'usuário=ADMIN '+CHR(13)+;
			'senha=ADMIN'+CHR(13)+;
			'grupo=Supervisor'
			RETURN(.T.)
		ENDIF
	ENDIF
RETURN(.F.)

FUNC POEIMG
***********
LPARAMETERS tcIMG
	LOCAL lcRETORNO, lcIMAGENS AS String
	STORE '' TO lcIMAGENS
	
	*#FLAT - CASO SEJA PASSADA EXTENSÃO, O SISTEMA MANTERÁ
	IF EMPTY(JUSTEXT(tcIMG))
		lcRETORNO = ALLTRIM(tcIMG)+'.BMP'
	ELSE 
		lcRETORNO = ALLTRIM(tcIMG)
	ENDIF  
	
	* IMAGENS DEFAULT 
	TEXT TO lcIMAGENS NOSHOW PRETEXT 15
		.ACTION.EXPORT.FILTRAN.FILTRAR0.FILTRAR1.PKFILTRO.INDEX.PRINT.REFRESH.VIEW.CMDREFRESH.CMDCONTEXTO.CMDEXPORTAR.CMDFILTRAR.CMDIMPRIMIR.CMDINDEXAR.CMDLIMPARFILTRO.CMDPKFILTRAR.
		.CMDREFRESH_DISABLED.CMDCONTEXTO_DISABLED.CMDEXPORTAR_DISABLED.CMDFILTRAR_DISABLED.CMDIMPRIMIR_DISABLED.CMDINDEXAR_DISABLED.CMDLIMPARFILTRO_DISABLED.CMDPKFILTRAR_DISABLED.
		.ARROW_LEFT.ARROW_RIGHT.CMDFILTROCHEIO.HELP.HELPFLAT.
	ENDTEXT
	
	* IMAGENS COMPILADAS NO EXE
	IF '.'+JUSTSTEM(tcIMG)+'.' $ lcIMAGENS 
		IF _SCREEN.Width<=1000
			* IMAGENS REDUZIDAS
			lcRETORNO = STRTRAN(lcRETORNO,'.','2.')
		ENDIF
	ELSE
		* IMAGENS NÃO COMPILADAS
		lcRETORNO = 'IMAGES\'+lcRETORNO
	ENDIF

RETURN(lcRETORNO)
FUNC CPFEDITADO
***************
LPARAMETERS tnCPFCGC, tcPESSOA
	IF TYPE('tnCPFCGC') <> 'N'
		tnCPFCGC	= 0
	ENDIF
	IF EMPTY(tnCPFCGC)
		RETURN(SPACE(18))
	ENDIF
	IF TYPE('tcPESSOA') <> 'C'
		tcPESSOA	= ''
	ENDIF
	IF EMPTY(tcPESSOA)
		tcPESSOA	= 'J'
	ENDIF

	LOCAL lcCPFEDITADO, lcAUX, lcCPFBRUTO, lcCPFZEROS AS String
	STORE SPACE(18) TO lcCPFEDITADO
	STORE '' TO lcAUX, lcCPFBRUTO, lcCPFZEROS

	IF tcPESSOA = 'J'
		lcCPFZEROS		= STRZERO(tnCPFCGC,14)
		lcCPFEDITADO	= PADR( TRANS(lcCPFZEROS,'@R XX.XXX.XXX/XXXX-XX'),18 )
	ELSE
		lcCPFZEROS		= STRZERO(tnCPFCGC,11)
		lcCPFEDITADO	= PADR( TRANS(lcCPFZEROS,'@R XXX.XXX.XXX-XX'),14 )
	ENDIF
RETURN(lcCPFEDITADO)

PROC CARGAFERIADOS
******************
*GRAVA NO goAPLICATIVO STRING COM FERIADOS SEPARADOS POR VIRGULA E SEPARA FIXOS DE VARIAVEIS COM '<DIV>'
*EX. ',01/05/1990,25/12/1990, <DIV> ,27/02/2006,19/02/2007,'
	LOCAL lcCOMANDO, lcFERIADOS AS STRING
	STORE '' TO lcCOMANDO, lcFERIADOS
	
	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		SELECT
			DT_FERIADO,
			TG_PERIODO
		FROM
			TB_FERIADOS
		ORDER BY
			TG_PERIODO DESC, DT_FERIADO
	ENDTEXT
	=PesquisaSQL(lcCOMANDO,"TMPSYSFERIADO")
	
	SELE TMPSYSFERIADO
	GO TOP
	
	SCAN WHILE NOT EOF() AND TG_PERIODO=2 && SOMENTE FERIADOS FIXOS
		IF EMPTY(lcFERIADOS)
			lcFERIADOS=','+DTOC(DT_FERIADO)
		ELSE
			lcFERIADOS=lcFERIADOS+','+DTOC(DT_FERIADO)
		ENDIF
	ENDSCAN
	lcFERIADOS = lcFERIADOS + ', <DIV> ,'
	SCAN WHILE NOT EOF() AND TG_PERIODO=1 && SOMENTE FERIADOS VARIAVEIS
		lcFERIADOS=lcFERIADOS+DTOC(DT_FERIADO)+','
	ENDSCAN
	
	USE IN TMPSYSFERIADO

	goAPLICATIVO.FERIADOS=lcFERIADOS
ENDPROC

PROC CARGASYSTEMTABLES
**********************
* GRAVA NO goAPLICATIVO STRING COM TABELAS SEPARADOS POR #
* EX. #TB_CADUNICO#TB_EMPRESAS#TB_PRODUTOS#
	
	* LE TODAS AS TABELAS DO SISTEMA
	DO LERTABLES WITH '%'
	
	IF NOT USED('TMPTABLES')
		RETURN
	ENDIF
	
	LOCAL lcTABLES AS String
	STORE '#' TO lcTABLES
	
	* MONTA STRING COM O NOME DAS TABELAS
	SELE TMPTABLES
	GO TOP
	SCAN WHILE NOT EOF()
		lcTABLES = lcTABLES + ALLTRIM(UPPER(DS_TABLENAME))+'#'
	ENDSCAN
	lcTABLES = lcTABLES + '#'
	
	USE IN TMPTABLES
	
	goAPLICATIVO.SYSTEMTABLES=lcTABLES
	
ENDPROC

PROC VTABLEEXIST
****************
LPARAMETERS tcTABLE

	IF TYPE('tcTABLE') <> 'C'
		tcTABLE	= ''
	ENDIF
	IF EMPTY(tcTABLE)
		RETURN(.F.)
	ENDIF 
	
	LOCAL llRET AS Logical
	STORE .F. TO llRET
	
	* VERIFICA EXISTENCIA DA TABELA
	IF '#'+ALLTRIM(UPPER(tcTABLE))+'#' $ goAPLICATIVO.SYSTEMTABLES
		llRET = .T.
	ENDIF
	
	RETURN(llRET)
ENDPROC

PROC VDIAUTIL
*************
LPARAMETERS tdUTIL
*  RETORNA 	 1 = SE FOR DIA ÚTIL
*  			 0 = SE FOR FINAL DE SEMANA
* 			-1 = SE FOR FERIADO
* 			-2 = DATA INVÁLIDA
*			-3 = TABELA DE FERIADOS NÃO FOI CARREGADA
	* tdUTIL	= DATA A SER VERIFICADA
	
	LOCAL lcUTIL, lcFERIADO, lcFIXO, lcVARIAVEL, lcPERGUNTA AS STRING
	LOCAL I AS Integer 
	STORE '' TO lcUTIL, lcFERIADO, lcFIXO, lcVARIAVEL, lcPERGUNTA
	STORE 0 TO I
	
	IF TYPE('tdUTIL')='T'
		tdUTIL=TTOD(tdUTIL)
	ENDIF
	
	IF TYPE('tdUTIL')<>'D'
		RETURN(-2)
	ENDIF
	
	IF goAPLICATIVO.TESTE	&& MENSAGEM SÓ APARECE NA BASE DE TESTE
		IF EMPTY(goAPLICATIVO.FERIADOS)
			TEXT TO lcPERGUNTA NOSHOW PRETEXT 6
				A tabela de feriados não foi carregada neste aplicativo.
				Deseja carregá-la agora?
				
				(Obs. esta mensagem só é exibida na base de teste PWI)
			ENDTEXT
			IF SIMOUNAO(lcPERGUNTA,'Carregar feriados',1)
				DO CARGAFERIADOS
			ELSE
				RETURN(-3)
			ENDIF
		ENDIF
	ENDIF
	IF ALLTRIM(STR(DOW(tdUTIL))) $ '1,7' && FIM DE SEMANA
		RETURN(0)
	ENDIF
	lcUTIL=DTOC(tdUTIL)
	
	lcFIXO=STREXTRACT(goAPLICATIVO.FERIADOS,'','<DIV>')
	* VERIFICA SE É UM FERIADO FIXO (EX. NATAL)
	FOR I =1 TO OCCURS(',',lcFIXO)
		lcFERIADO=STREXTRACT(lcFIXO, ',' , ',' ,I)
		* VERIFICA SE O ANO INICIAL DO FERIADO É VÁLIDO
		IF SUBSTR(lcUTIL,1,6) $ lcFERIADO
			IF YEAR(tdUTIL)>=VAL(SUBSTR(lcFERIADO,7,4))
				RETURN(-1)
			ENDIF
		ENDIF
	ENDFOR
	
	* VERIFICA SE É UM FERIADO VARIÁVEL (EX. CARNAVAL)
	lcVARIAVEL=STREXTRACT(goAPLICATIVO.FERIADOS,'<DIV>','')
	FOR I =1 TO OCCURS(',',lcVARIAVEL)
		lcFERIADO=STREXTRACT(lcVARIAVEL, ',' , ',' ,I)
		IF lcUTIL == lcFERIADO
			RETURN(-1)
		ENDIF
	ENDFOR
RETURN(1)

PROC PROXUTIL
**************
* RETORNA PROXIMO DIA UTIL
LPARAMETERS tdUTIL, tnDIAS
*		tdUTIL = DATA INICIAL
*		tnDIAS = QUANTIDADE DE DIAS PARA AVANÇAR OU RETROCEDER (OPICIONAL, DEFAULT=1)
	LOCAL lnOK,lnSCAPE,lnTIP AS Integer
	LOCAL ldPROXUTIL AS Date
	STORE 0 TO lnSCAPE,lnOK,lnTIP
	
	IF TYPE('tdUTIL')='T'
		tdUTIL=TTOD(tdUTIL)
	ENDIF
	IF TYPE('tdUTIL')<>'D'
		RETURN
	ENDIF
	ldPROXUTIL=tdUTIL
	
	IF TYPE('tnDIAS')<>'N'
		tnDIAS=1
	ENDIF
	IF EMPTY(tnDIAS)
		tnDIAS=1
	ENDIF
	IF tnDIAS<0
		lnTIP=-1 && DIAS PARA TRAZ
		tnDIAS = tnDIAS * -1
	ELSE
		lnTIP=1
	ENDIF
	
	DO WHILE lnOK<tnDIAS AND lnSCAPE<1000
		lnSCAPE = lnSCAPE + 1 && PROTEÇÃO CONTRA LOOP INFINITO
		
		ldPROXUTIL = ldPROXUTIL + lnTIP
		lnRET=VDIAUTIL(ldPROXUTIL)
		IF lnRET=-3 &&STRING DE FERIADOS NÃO FOI CARREGADA
			RETURN(NULL)
		ENDIF
		lnOK = lnOK + MAX(0,lnRET)
	ENDDO
RETURN(ldPROXUTIL)

PROC CONTARUTEIS
****************
* CONTAR QUANTOS DIAS ÚTEIS HÁ EM UM PERÍODO
* OBS: NÃO PODE CONTAR OS DOIS EXTREMOS, POR CAUSA DISTO
* NÃO CONSIDERA A PRIMEIRA "PONTA" = DIA INICIAL
LPARAMETERS tdINI, tdFIN
    LOCAL lnDIAS, lnI AS Integer
    lnDIAS = 0
    FOR lnI = 1 TO 10000
        ldNOW = tdINI + lnI
        IF ldNOW>tdFIN
            EXIT
        ENDIF
        IF VDIAUTIL(ldNOW)=1
            lnDIAS = lnDIAS + 1
        ENDIF
    ENDFOR
RETURN(lnDIAS)

FUNC NOMESGRAFICOS
******************
* - RELAÇÃO DE NOME E NÚMEROS DOS POSSÍVEIS GRÁFICOS DO COMPONENTE OWC10
	LOCAL lcNOMES AS String
	STORE '' TO lcNOMES

	TEXT TO lcNOMES NOSHOW PRETEXT 7
		00 - COLUNAS AGRUPADAS
		01 - COLUNAS EMPILHADAS
		02 - COLUNAS 100% EMPILHADAS
		46 - COLUNAS 3D
		47 - COLUNAS 3D AGRUPADAS
		48 - COLUNAS 3D EMPILHADAS
		49 - COLUNAS 3D 100% EMPILHADAS
		03 - BARRAS AGRUPADAS
		04 - BARRAS EMPILHADAS
		05 - BARRAS 100% EMPILHADAS
		50 - BARRAS 3D
		51 - BARRAS 3D AGRUPADAS
		52 - BARRAS 3D EMPILHADAS
		53 - BARRAS 3D 100% EMPILHADAS
		06 - LINHAS
		07 - LINHAS COM MARCADORES
		08 - LINHAS EMPILHADAS
		09 - LINHAS EMPILHADAS COM MARCADORES
		10 - LINHAS 100% EMPILHADAS
		11 - LINHAS 100% EMPILHADS COM MARCADORES
		12 - LINHAS SUAVES
		13 - LINHAS SUAVES COM MARCADORES
		14 - LINHAS SUAVES EMPILHADAS
		15 - LINHAS SUAVES EMPILHADAS COM MARCADORES
		16 - LINHAS SUAVES 100% EMPILHADAS
		17 - LINHAS SUAVES 100% EMPILHADAS COM MARCADORES
		54 - LINHAS 3D
		55 - LINHAS 3D SOBREPOSTAS
		56 - LINHAS 3D EMPILHADAS
		57 - LINHAS 3D 100% EMPILHADAS
		18 - PIZZA
		19 - PIZZA DESTACADA
		20 - PIZZA EMPILHADA
		58 - PIZZA 3D
		59 - PIZZA 3D DESTACADA
		32 - ROSCA
		33 - ROSCA DESTACADA
		29 - ÁREA
		30 - ÁREA EMPILHADA
		31 - ÁREA 100% EMPILHADA
		60 - ÁREA 3D
		61 - ÁREA 3D EMPILHADA
		62 - ÁREA 3D 100% EMPILHADA
		34 - RADAR SEM MARCADORES
		35 - RADAR
		36 - RADAR PREENCHIDO
		37 - RADAR COM LINHAS SUAVES E SEM MARCADORES
		38 - RADAR COM LINHAS SUAVES E MARCADORES
	ENDTEXT
RETURN(lcNOMES)

FUNC VERIFICAR
	LPARAMETERS tcVALOR AS String

	LOCAL lcRETURN,lcACENTO AS String
	LOCAL lnCONT AS Integer

	lcRETURN = ''
	lcACENTO = 'ÄÃÀÁÉÈÊÍÓÔÚÜÇ¹³²°'

	FOR lnCONT = 1 TO LEN(ALLTRIM(tcVALOR))
		IF (ASC(SUBSTR(tcVALOR,lnCONT,1))>=32 AND ASC(SUBSTR(tcVALOR,lnCONT,1))<=126) OR SUBSTR(tcVALOR,lnCONT,1) $ lcACENTO
			lcRETURN = lcRETURN + SUBSTR(tcVALOR,lnCONT,1)
		ENDIF
	ENDFOR

RETURN(lcRETURN)

PROC LERTABLES
**************
LPARAMETERS tcNAME AS STRING
	IF TYPE('tcNAME') <> 'C'
		tcNAME	= ''
	ENDIF

	LOCAL lcCOMANDO AS String
	IF USED('TMPTABLES')
		USE IN TMPTABLES
	ENDIF
	DO CASE
		CASE goCONEXAO.BANCO = 'POS'
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT 
					TABLENAME AS DS_TABLENAME
				FROM 
					pg_tables
				WHERE
					UPPER(TABLENAME) LIKE '[[TABLENAME]]'
				ORDER BY
					DS_TABLENAME
			ENDTEXT			

		CASE goCONEXAO.BANCO = 'ORA'
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT 
					TABLE_NAME AS DS_TABLENAME
				FROM
					USER_TABLES
				WHERE
					UPPER (TABLE_NAME) LIKE '[[TABLENAME]]'
				ORDER BY
					DS_TABLENAME
			ENDTEXT						

		CASE 'SQL SERVER' $ UPPER(goCONEXAO.DRIVER)
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					UPPER(NAME) AS DS_TABLENAME
				FROM
					SYSOBJECTS
				WHERE
					TYPE = 'U'
					AND NAME LIKE '[[TABLENAME]]'
				ORDER BY
					DS_TABLENAME
			ENDTEXT

		CASE goCONEXAO.BANCO = 'MYS'
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					TABLE_NAME AS DS_TABLENAME
				FROM
					VW_TS_TABLES
				WHERE
				 	TABLE_NAME LIKE '[[TABLENAME]]'
				 ORDER BY
				 	TABLE_NAME 
			ENDTEXT

		OTHERWISE
			* NÃO TRAZ NADA, APENAS MONTA CURSOR VAZIO PARA MANTER COMPATIBILIDADE
			CREATE CURSOR TMPTABLES (DS_TABLENAME C(50))
	ENDCASE
	lcCOMANDO = STRTRAN(lcCOMANDO,'[[TABLENAME]]',UPPER(ALLTRIM(tcNAME)))
	=PESQUISASQL(lcCOMANDO,'TMPTABLES')
RETURN

PROC LERCOLUMNS
**************
LPARAMETERS tcDS_TIPO, tcDS_NOME,tcCONFIGS AS STRING
* TIPO = (TABELA/COLUNA)
* NOME = (NOME DA TABELA OU COLUNA)
* CONFIGS = CONFIGURAÇÕES 

	IF TYPE('tcDS_TIPO') <> 'C'
		tcDS_TIPO	= ''
	ENDIF
	IF EMPTY(tcDS_TIPO)
		RETURN
	ENDIF
	IF TYPE('tcDS_NOME') <> 'C'
		tcDS_NOME	= ''
	ENDIF
	IF EMPTY(tcDS_NOME)
		RETURN
	ENDIF
	IF TYPE('tcCONFIGS') <> 'C'
		tcCONFIGS	= ''
	ENDIF
	IF EMPTY(tcCONFIGS)
		tcCONFIGS='' 
	ENDIF 

	LOCAL lcCOMANDO, lcAUXTAB, lcAUXCOL, lcCONDICAO, lcUNIVERSO AS String
	STORE '' TO lcCOMANDO, lcAUXTAB, lcAUXCOL, lcCONDICAO, lcUNIVERSO 

	tcDS_NOME = UPPER(tcDS_NOME)
	tcCONFIGS = UPPER(tcCONFIGS)
	lcUNIVERSO = ALLTRIM(STREXTRACT(tcCONFIGS,'UNIVERSO=',';',1))
	
	* (S0MENTE SQLSERVER)
	IF EMPTY(lcUNIVERSO)
		lcUNIVERSO = 'T'
	ENDIF
	
	IF USED('TMPCOLUMNS')
		USE IN TMPCOLUMNS
	ENDIF
	DO CASE
		CASE goCONEXAO.BANCO = 'POS'
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT 
					UPPER(TABLE_NAME) AS DS_TABELA,
					UPPER(COLUMN_NAME) AS DS_CAMPO,
					DATA_TYPE AS DS_TIPO,
					COALESCE(CASE WHEN DATA_TYPE = 'numeric' THEN NUMERIC_PRECISION ELSE CHARACTER_MAXIMUM_LENGTH END,0) AS VL_TAMANHO,
					COALESCE(NUMERIC_SCALE,0) AS VL_PRECISAO
				FROM
					INFORMATION_SCHEMA.COLUMNS
				WHERE
					[[CONDICAO]]
					AND TABLE_SCHEMA = 'public'
			ENDTEXT
			lcAUXTAB	= 'UPPER(TABLE_NAME)'
			lcAUXCOL	= 'UPPER(COLUMN_NAME)'

		CASE goCONEXAO.BANCO = 'ORA'
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					TABELA.TABLE_NAME AS DS_TABELA,
					COLUNA.COLUMN_NAME AS DS_CAMPO,
					COLUNA.DATA_TYPE AS DS_TIPO,
					COALESCE(CASE WHEN COLUNA.DATA_TYPE = 'NUMBER' THEN COLUNA.DATA_PRECISION ELSE COLUNA.DATA_LENGTH END,0) AS VL_TAMANHO,
					COALESCE(COLUNA.DATA_SCALE,0) AS VL_PRECISAO
				FROM
					USER_TABLES TABELA
					LEFT JOIN ALL_TAB_COLUMNS COLUNA ON COLUNA.TABLE_NAME=TABELA.TABLE_NAME
				WHERE
					[[CONDICAO]]
			ENDTEXT		
			lcAUXTAB	= 'TABELA.TABLE_NAME'
			lcAUXCOL	= 'COLUNA.COLUMN_NAME'

		CASE 'SQL SERVER' $ UPPER(goCONEXAO.DRIVER) OR 'SQL NATIVE CLIENT' $ UPPER(goCONEXAO.DRIVER)
			IF lcUNIVERSO == 'T'
				TEXT TO lcCOMANDO NOSHOW PRETEXT 7
					SELECT
						TABELA.NAME AS DS_TABELA,
						COLUNA.NAME AS DS_CAMPO,
						TIPO.NAME AS DS_TIPO,
						COALESCE(CASE WHEN TIPO.NAME = 'numeric' THEN COLUNA.XPREC ELSE COLUNA.LENGTH END,0) AS VL_TAMANHO,
						COALESCE(COLUNA.XSCALE,0) AS VL_PRECISAO
					FROM
						SYSOBJECTS TABELA
						LEFT JOIN SYSCOLUMNS COLUNA ON COLUNA.ID=TABELA.ID
						LEFT JOIN SYSTYPES TIPO ON TIPO.XTYPE=COLUNA.XTYPE
					WHERE
						[[CONDICAO]]
						AND TABELA.XTYPE='u'
						AND TABELA.NAME<>'dtproperties'
						AND TIPO.NAME<>'sysname'
				ENDTEXT
			ENDIF
			
			IF lcUNIVERSO == 'V'
				TEXT TO lcCOMANDO NOSHOW PRETEXT 7
					SELECT
						TABELA.NAME AS DS_TABELA,
						COLUNA.NAME AS DS_CAMPO,
						TIPO.NAME AS DS_TIPO,
						COALESCE(CASE WHEN TIPO.NAME = 'numeric' THEN COLUNA.XPREC ELSE COLUNA.LENGTH END,0) AS VL_TAMANHO,
						COALESCE(COLUNA.XSCALE,0) AS VL_PRECISAO
					FROM
						SYSOBJECTS TABELA
						LEFT JOIN SYSCOLUMNS COLUNA ON COLUNA.ID=TABELA.ID
						LEFT JOIN SYSTYPES TIPO ON TIPO.XTYPE=COLUNA.XTYPE
					WHERE
						[[CONDICAO]]
						AND TABELA.XTYPE='v'
						AND TABELA.NAME<>'dtproperties'
						AND TIPO.NAME<>'sysname'
				ENDTEXT
			ENDIF
			
			IF 'V' $ lcUNIVERSO AND 'T' $ lcUNIVERSO 
				TEXT TO lcCOMANDO NOSHOW PRETEXT 7
					SELECT
						TABELA.NAME AS DS_TABELA,
						COLUNA.NAME AS DS_CAMPO,
						TIPO.NAME AS DS_TIPO,
						COALESCE(CASE WHEN TIPO.NAME = 'numeric' THEN COLUNA.XPREC ELSE COLUNA.LENGTH END,0) AS VL_TAMANHO,
						COALESCE(COLUNA.XSCALE,0) AS VL_PRECISAO
					FROM
						SYSOBJECTS TABELA
						LEFT JOIN SYSCOLUMNS COLUNA ON COLUNA.ID=TABELA.ID
						LEFT JOIN SYSTYPES TIPO ON TIPO.XTYPE=COLUNA.XTYPE
					WHERE
						[[CONDICAO]]
						AND TABELA.NAME<>'dtproperties'
						AND TIPO.NAME<>'sysname'
				ENDTEXT
			ENDIF
			
			lcAUXTAB	= 'TABELA.NAME'
			lcAUXCOL	= 'COLUNA.NAME'
			
		CASE goCONEXAO.BANCO = 'MYS'
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					TABLE_NAME AS DS_TABELA,
					COLUMN_NAME AS DS_CAMPO,
					DATA_TYPE AS DS_TIPO,
					COALESCE(CASE WHEN DATA_TYPE IN ('double', 'decimal') THEN NUMERIC_PRECISION ELSE CHARACTER_MAXIMUM_LENGTH END,0) AS VL_TAMANHO,
					COALESCE(NUMERIC_SCALE,0) AS VL_PRECISAO
				FROM
					VW_TS_COLUMNS
				WHERE
					[[CONDICAO]]
			ENDTEXT
			lcAUXTAB	= 'TABLE_NAME'
			lcAUXCOL	= 'COLUMN_NAME'

		OTHERWISE
			* NÃO TRAZ NADA, APENAS MONTA CURSOR VAZIO PARA MANTER COMPATIBILIDADE
			CREATE CURSOR TMPTABLES (DS_TABELA C(50), DS_COLUNA C(50), DS_TIPO C(50), VL_TAMANHO N(14,0), VL_PRECISAO N(14,0))

	ENDCASE
	lcCONDICAO	= ' LIKE ' + XX( tcDS_NOME )
	IF tcDS_TIPO = 'TAB'
		lcCONDICAO	= lcAUXTAB + lcCONDICAO
	ELSE
		lcCONDICAO	= lcAUXCOL + lcCONDICAO
	ENDIF
	lcCOMANDO = STRTRAN( lcCOMANDO, '[[CONDICAO]]', lcCONDICAO )
	=PESQUISASQL(lcCOMANDO,'TMPCOLUMNS')
RETURN

PROC GRAVARLOGSYS
*****************
* GRAVA LOG DE SISTEMA
	IF EMPTY(lcALIASFOX)
		RETURN
	ENDIF

	LOCAL loSYS AS Object
	LOCAL lcCOMANDO, lcCAMPOS, lcVALORES AS String
	LOCAL lnXI AS Integer
	loSYS	= CREATEOBJECT('EMPTY')

	* ESTRUTURA VAZIA DO LOG
	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		SELECT
			*
		FROM
			[[TABELA_LOG]]
		WHERE
			PK_ID IS NULL
	ENDTEXT
	lcCOMANDO	= STRTRAN(lcCOMANDO, '[[TABELA_LOG]]', 'LG_'+tcTABELA)
	=PESQUISASQL(lcCOMANDO,'TMPLOGSYS')

	SELE &lcALIASFOX
	SCATTER NAME loSYS MEMO
	=ADDPROPERTY( loSYS, 'FK_USUARIOLOGSYS', goCONEXAO.FK_USUARIO )
	=ADDPROPERTY( loSYS, 'TG_ACAOLOGSYS', tcACTION )

	SELE TMPLOGSYS
	APPEND BLANK
	GATHER NAME loSYS MEMO

	STORE '' TO lcCAMPOS, lcVALORES
	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		INSERT INTO [[TABELA_LOG]]
			( [[CAMPOS]] )
		VALUES
			( [[VALORES]] )
	ENDTEXT
	lcCOMANDO	= STRTRAN(lcCOMANDO, '[[TABELA_LOG]]', 'LG_'+tcTABELA)
	SELE TMPLOGSYS
	FOR lnXI = 1 TO FCOUNT()
		SELE TMPLOGSYS
		lcCAMPOS	= lcCAMPOS + ', ' + FIELD(lnXI)
		IF ALLTRIM(UPPER(FIELD(lnXI))) = 'DH_LOGSYS'
			lcVALORES	= lcVALORES + ', ' + D2SQL(DATE(), 'HOJE' )
		ELSE
			lcVALORES	= lcVALORES + ', ' + XX( EVALUATE( 'TMPLOGSYS.' + FIELD(lnXI) ) )
		ENDIF
	ENDFOR
	lcCAMPOS	= SUBSTR( lcCAMPOS, 3 )
	lcVALORES	= SUBSTR( lcVALORES,3 )
	lcCOMANDO	= STRTRAN( lcCOMANDO, '[[CAMPOS]]', lcCAMPOS )
	lcCOMANDO	= STRTRAN( lcCOMANDO, '[[VALORES]]', lcVALORES )
	=EXECUTASQL(lcCOMANDO)

	USE IN TMPLOGSYS
	SELE &lcALIASFOX

RETURN

PROC RETORNAIMAGEM
******************
LPARAMETERS tcTABELA AS String, tuPK_ID AS Variant, tcEXTENSAO AS String, tcCOMPLEMENTO AS String

	IF EMPTY(tcTABELA)
		RETURN('')
	ENDIF
	IF EMPTY(tuPK_ID)
		RETURN('')
	ENDIF
	IF VARTYPE(tcEXTENSAO) <> 'C'
		tcEXTENSAO = 'JPG'
	ENDIF
	IF VARTYPE(tcCOMPLEMENTO) <> 'C'
		tcCOMPLEMENTO = ''
	ENDIF
	IF ALLTRIM(UPPER(tcEXTENSAO)) == 'GIF'
		tcEXTENSAO = 'GIF' && FORÇANDO GIF PARA TER CERTEZA DE QUE NÃO TEM ESPAÇOS
	ELSE
		tcEXTENSAO = 'JPG'
	ENDIF
	
	LOCAL lcPK_ID AS String
	LOCAL lnXI, lnQTD AS Integer
	LOCAL lcRETORNO, lcSQL, lcTEMPFILE, lcCONDICAO AS String
	STORE '' TO lcRETORNO, lcCONDICAO
	DIMENSION laARQUIVOS[1]

	IF NOT EMPTY(tcCOMPLEMENTO)
		lcCONDICAO = lcCONDICAO + ' AND DS_COMPLEMENTO='+XX(tcCOMPLEMENTO)
	ENDIF
	
	IF VARTYPE(tuPK_ID) = 'N'
		lcPK_ID = ALLTRIM(STR(tuPK_ID))
	ELSE
		lcPK_ID = tuPK_ID
	ENDIF
	IF RETORNASET('IMAGEM.BD','C',1) = 'ON'
		TEXT TO lcSQL NOSHOW PRETEXT 7
			SELECT
				PK_ID,
				HX_IMAGEM
			FROM
				TS_IMAGENS
			WHERE
				DS_TABELA = [[TABELA]]
				AND FK_ORIGEM = [[PK_ID]]
				[[CONDICAO]]
			ORDER BY
				DS_COMPLEMENTO
		ENDTEXT
		lcSQL = STRTRAN(lcSQL,'[[TABELA]]',XX(tcTABELA))
		lcSQL = STRTRAN(lcSQL,'[[PK_ID]]',XX(lcPK_ID))
		lcSQL = STRTRAN(lcSQL,'[[CONDICAO]]',lcCONDICAO)
		=PESQUISASQL(lcSQL,'TMPSYSIMAGES')
		SELE TMPSYSIMAGES
		GO TOP
		SCAN WHILE NOT EOF()
			lcTEMPFILE = TEMPFILE(tcEXTENSAO)
			IF STRTOFILE(STRCONV(HX_IMAGEM,14),lcTEMPFILE) < 1
				DO MENS WITH 'Erro para salvar imagem temporária.'
				RETURN('')
			ENDIF
			lcRETORNO = lcRETORNO + lcTEMPFILE + CHR(13)
		ENDSCAN
		IF USED('TMPSYSIMAGES')
			USE IN TMPSYSIMAGES
		ENDIF
	ELSE
		lnQTD = ADIR(laARQUIVOS, goAPLICATIVO.PATHDOCVIEW + 'GDI_' + tcTABELA + '_' + lcPK_ID + '_*.' + tcEXTENSAO)
		FOR lnXI = 1 TO lnQTD
			lcRETORNO = lcRETORNO + goAPLICATIVO.PATHDOCVIEW + laARQUIVOS[lnXI,1] + CHR(13)
		ENDFOR
	ENDIF
RETURN( lcRETORNO )

PROC MINHAESTRUTURAORG
**********************
LPARAMETERS tcESTRUTURA AS String

	IF VARTYPE(tcESTRUTURA) <> 'C'
		tcESTRUTURA = ''
	ENDIF

	LOCAL lnXI AS Integer
	LOCAL lcRETORNO AS String
	STORE '' TO lcRETORNO 

	lcESTRUTURA = TIRANONUM(tcESTRUTURA)
	FOR lnXI = 2 TO LEN(lcESTRUTURA) STEP 2
		lcRETORNO = lcRETORNO + ",'" + SUBSTR(lcESTRUTURA, 1, lnXI) + "'"
	ENDFOR
	lcRETORNO = SUBSTR(lcRETORNO,2)
RETURN (lcRETORNO)

PROC CALLFORM
*************
LPARAMETERS tcMACRO AS String

	IF VARTYPE(tcMACRO) <> 'C'
		tcMACRO = ''
	ENDIF

	IF NOT EMPTY(tcMACRO)
		&tcMACRO
	ENDIF
RETURN

PROC VERERROCONEXAO
****************
* TRATA ERRO DE CONEXÃO COM BANCO DE DADOS OU SERVIDOR (PROBLEMAS DE REDE)
* RETORNA .T. SE É UM ERRO DE CONEXÃO
LPARAMETERS tuERRO1 AS Variant, tuERRO2 AS Variant, tuERRO3 AS Variant
	LOCAL llRETORNO AS Logical
	STORE .F. TO llRETORNO
	
	LOCAL lcERRO1, lcERRO2, lcERRO3 AS String
	DO CASE
		CASE VARTYPE(tuERRO1) = 'C'
			lcERRO1 = tuERRO1
		CASE VARTYPE(tuERRO1) = 'N'
			lcERRO1 = ALLTRIM(STR(tuERRO1))
		OTHERWISE
			lcERRO1 = ''
	ENDCASE
	DO CASE
		CASE VARTYPE(tuERRO2) = 'C'
			lcERRO2 = tuERRO2
		CASE VARTYPE(tuERRO2) = 'N'
			lcERRO2 = ALLTRIM(STR(tuERRO2))
		OTHERWISE
			lcERRO2 = ''
	ENDCASE
	DO CASE
		CASE VARTYPE(tuERRO3) = 'C'
			lcERRO3 = tuERRO3
		CASE VARTYPE(tuERRO3) = 'N'
			lcERRO3 = ALLTRIM(STR(tuERRO3))
		OTHERWISE
			lcERRO3 = ''
	ENDCASE
	

	DO CASE
	
		CASE goCONEXAO.BANCO = 'SQL'
			IF (lcERRO1 == '08S01' AND lcERRO2 == '11') OR;
			   (lcERRO1 == '08S01' AND lcERRO2 == '0') OR;
			   (lcERRO1 == '01000' AND lcERRO2 == '10054') OR;
			   (lcERRO1 == '01000' AND lcERRO2 == '65534') OR;
			   (lcERRO1 == '01000' AND lcERRO2 == '10053') OR;
			   (lcERRO1 == '01000' AND lcERRO2 == '64') OR;
			   (lcERRO1 == '1526' AND lcERRO2 == '0') OR;
			   ('CONNECTIONREAD' $ UPPER(lcERRO1)) OR;
			   ('CONNECTIONREAD' $ UPPER(lcERRO3))
				llRETORNO = .T.
			ENDIF
			
		CASE goCONEXAO.BANCO = 'DBC'
				llRETORNO = .F.

		CASE goCONEXAO.BANCO = 'POS'
			IF lcERRO1 == '08S01' AND lcERRO2 == '27'
				llRETORNO = .T.
			ENDIF
			
		CASE goCONEXAO.BANCO = 'ORA'
			IF lcERRO2 == '3113' OR lcERRO2 == '3114' OR lcERRO2 == '12571'
				llRETORNO = .T.
			ENDIF
		
		CASE goCONEXAO.DRIVER = 'MYS'
			IF	(lcERRO1 == '08S01' AND lcERRO2 == '2006') OR;
				(UPPER(lcERRO1) $ 'LOST CONNECTION TO MYSQL SERVER DURING QUERY') OR;
				(lcERRO1 == '37000' AND lcERRO2 == '1064') OR;
				(lcERRO1 == 'S1000' AND lcERRO2 == '1045') OR;
				(lcERRO1 == 'S1000' AND lcERRO2 == '1242') OR;
				(lcERRO1 == 'S1000' AND lcERRO2 == '1582') OR;
				(lcERRO1 == '37000' AND lcERRO2 == '1305')
				llRETORNO = .T.
			ENDIF

		OTHERWISE
			llRETORNO = .F.
	ENDCASE
	
	LOCAL lcMACRO AS String
	
	* VERIFICA SE É ERRO DE REDE E SE DEVE OU NÃO REPORTAR ERRO DE CONEXÃO
*!*		IF llRETORNO AND RETORNASET('REDE.DIAGNOSTICO','C',1) == 'ON'
*!*			* MESMO SENDO ERRO DE CONEXÃO MUDA RETORNO PARA FORÇAR REPORTAR ERRO
*!*			llRETORNO = .F.
*!*			IF FILE('SYS_DIAGNOSTICOREDE.FXP')
*!*				lcMACRO = 'DO SYS_DIAGNOSTICOREDE.FXP'
*!*				&lcMACRO
*!*			ENDIF
*!*		ENDIF	
RETURN(llRETORNO)

PROC REPETIRQUERY
*****************
*TENTA RE-EXECUTAR UMA QUERY NO BANCO APÓS UMA QUEDA DE CONEXÃO
	* EXECUTA COMANDO NA BASE
	LOCAL lnSQLOK AS INTEGER
	lnSQLOK = SQLEXEC(goCONEXAO.ALCA,goCONEXAO.LASTCOMMAND,goCONEXAO.LASTCURSOR)
	RETURN lnSQLOK
RETURN

PROC ENCERRARFORCADO
********************
* FINALIZA O APLICATIVO QUANDO NÃO HÁ MAIS COMO CONECTAR
	ON SHUTDOWN
	IF TYPE('_SCREEN.oSTATUSBAR')='O'
		_SCREEN.RemoveObject('oSTATUSBAR')
	ENDIF
	CLEAR WINDOWS
	CLOSE DATA
	SET PROCEDURE TO
	CLEAR EVENTS
	SET PATH TO
	CANCEL
RETURN

PROC VALIDARIE
***************
LPARAMETERS tcINS AS String, tcUF AS String, tnMENS AS Integer

	IF VARTYPE(tcINS) <> 'C'
		tcINS = ''
	ENDIF
	IF VARTYPE(tnMENS) <> 'N'
		tnMENS = 1
	ENDIF

	PRIVATE plINSEST AS Logical
	STORE .F. TO plINSEST
	
	LOCAL lcMACRO AS String

	tcOBJETO = 'IE_VERIF'

	tcOBJETO	= FORCEEXT(tcOBJETO, 'FXP')
	lcDIRETORIO	= 'OBJETOS\'
	lcARQUIVO	= lcDIRETORIO + tcOBJETO

	IF goAPLICATIVO.TESTE AND goAPLICATIVO.VOLPEPADRAO = 1
			
		* REGRA: PRIMEIRO PROCURA NA PASTA TEMP, DEPOIS NA PASTA CUSTOM, DEPOIS NA PASTA STOB.
		DO CASE
			CASE FILE(FORCEPATH(tcOBJETO,goAPLICATIVO.PATHVOLPETEMP+lcDIRETORIO))
				* USA DA PASTA TEMP
				lcARQUIVO = FORCEPATH(tcOBJETO,goAPLICATIVO.PATHVOLPETEMP+lcDIRETORIO)
				
			CASE FILE(lcDIRETORIO+tcOBJETO)
				* USA O DA MESMA PASTA
				lcARQUIVO = lcDIRETORIO+tcOBJETO
				
			OTHERWISE
				* USA DA PASTA STOB
				lcARQUIVO = FORCEPATH(tcOBJETO, goAPLICATIVO.PATHVOLPEPADRAO+lcDIRETORIO)
				
		ENDCASE
	ENDIF

	IF FILE(lcARQUIVO)
		lcMACRO = "DO VERIFICAIE IN " + lcARQUIVO + " WITH tcINS, tcUF, tnMENS"
		&lcMACRO
	ENDIF
RETURN(plINSEST)

PROC BUSCAPKID
**************
LPARAMETERS toGRADE AS Grid
    IF VARTYPE(toGRADE) <> 'O'
		RETURN(.F.)
    ENDIF
    
    * SOMENTE IRÁ FUNCIONAR COM A SUPERGRADE
    IF UPPER(ALLTRIM(toGRADE.Class)) <> 'SUPERGRADE'
		RETURN(.F.)
    ENDIF
    
    LOCAL lcCONDFIXA AS String
    LOCAL lnPK_ID AS Integer
    lcCONDFIXA = toGRADE.mySQLCONDFIXA
    lnPK_ID = INT(VAL(INPUTBOX('Informe o número','Localizar por número','0')))

	IF EMPTY(lnPK_ID)
		RETURN(.F.)
    ENDIF
    
    * SELECIONA TEMPORÁRIA PARA PEGAR PK_ID 
    toGRADE.mySQLCONDFIXA = 'PK_ID = ' + XX(lnPK_ID)
    toGRADE.hmyCMDSQL()

    * VOLTA CONDIÇÃO QUE ESTAVA ANTERIORMENTE
    toGRADE.mySQLCONDFIXA = lcCONDFIXA
RETURN(.T.)

PROC COMPILARENDERECO
*********************
LPARAMETERS tcEND AS String
	LOCAL lcXML, lcCHAR, lcAUX, lcTIPOENDERECO, lcLOGRADOURO, lcNUMERO, lcCOMPLEMENTO, lcERRO, lcTIPOENDERECOAUX AS String
	LOCAL lnXI, lnQTCHAR AS Integer
	LOCAL llTIPOENDERECO

	STORE '' TO lcXML,lcCHAR,lcAUX,lcTIPOENDERECO,lcLOGRADOURO,lcNUMERO,lcCOMPLEMENTO,lcERRO, lcTIPOENDERECOAUX 
	STORE 0 TO lnXI,lnQTCHAR
	STORE .T. TO llTIPOENDERECO
	
	tcEND = NVL(tcEND,'')
	
	IF TYPE('tcEND') <> 'C'
		tcEND   = ''
	ENDIF

	tcEND		= ALLTRIM( tcEND)
	lnQTCHAR	= LEN( tcEND)
	tcEND		= tcEND +  ' '          && PARA EVITAR QUE PERCA O ÚLTIMO CARACTÉR
	
	* TESTANDO DE ENDEREÇO TEM TIPO DE LOGRADOURO
	lcTIPOENDERECOAUX = ALLTRIM(SUBSTR(tcEND,1,at(',',tcEND)-1))
	IF ' ' $ lcTIPOENDERECOAUX or '.' $ lcTIPOENDERECOAUX 
		llTIPOENDERECO = .T.
	ELSE
		llTIPOENDERECO = .F.
	ENDIF

	* PASSANDO POR TODOS OS CARACTERES PARA IDENTIFICAR DELIMITADORES
	FOR lnXI = 1 TO lnQTCHAR
		lcCHAR  = SUBSTR( tcEND, lnXI, 1)
		DO CASE
			CASE EMPTY( lcTIPOENDERECO) AND llTIPOENDERECO 
			&& TRATA TIPO DE ENDEREÇO
				DO CASE
					CASE lcCHAR $ '. ' && VERIFICA SE É UM CARACTER DELIMITADOR
						lcTIPOENDERECO  = lcAUX
						lcAUX           = ''
					CASE (lnXI=lnQTCHAR) && ESTÁ NO ÚLTIMO CARACTER
						lcTIPOENDERECO  = lcAUX + lcCHAR
					OTHERWISE
						lcAUX   = lcAUX + lcCHAR
				ENDCASE
			CASE EMPTY( lcLOGRADOURO)
			&& TRATA LOGRADOURO
				DO CASE
					CASE lcCHAR $ ',' && VERIFICA SE É UM CARACTER DELIMITADOR
						lcLOGRADOURO    = lcAUX
						lcAUX       	= ''
					CASE (lnXI=lnQTCHAR)    && ESTÁ NO ÚLTIMO CARACTER
						lcLOGRADOURO    = lcAUX + lcCHAR
					OTHERWISE
						lcAUX   		= lcAUX + lcCHAR
				ENDCASE
			CASE EMPTY( lcNUMERO)
			&& TRATA LOGRADOURO
				DO CASE
					CASE lcCHAR $ '- ' && VERIFICA SE É UM CARACTER DELIMITADOR
						lcNUMERO        = lcAUX
						lcAUX           = ''
					CASE (lnXI=lnQTCHAR) && ESTÁ NO ÚLTIMO CARACTER
						lcNUMERO        = lcAUX + lcCHAR
					OTHERWISE
						lcAUX   = lcAUX + lcCHAR
				ENDCASE
			OTHERWISE
				lcCOMPLEMENTO   = SUBSTR( tcEND, lnXI)
				EXIT FOR
		ENDCASE
	ENDFOR

	* TRATANDO RETORNO
	lcTIPOENDERECO  = STRTRAN(ALLTRIM(lcTIPOENDERECO),'  ',' ')
	lcLOGRADOURO    = STRTRAN(ALLTRIM(lcLOGRADOURO),'  ',' ')
	lcNUMERO		= STRTRAN(ALLTRIM(lcNUMERO),'  ',' ')
	lcCOMPLEMENTO   = STRTRAN(ALLTRIM(lcCOMPLEMENTO),'  ',' ')

	* VERIFICANDO SE EXISTE ERRO NO ENDEREÇO
	IF (EMPTY(lcTIPOENDERECO) AND llTIPOENDERECO )OR EMPTY(lcLOGRADOURO) OR EMPTY(lcNUMERO)
		lcERRO  = '1'
	ELSE
		lcERRO  = '0'
	ENDIF

	* MONTANDO RESPOSTA ( XML )     
	TEXT TO lcXML NOSHOW PRETEXT 7
	        <erro>[[ERRO]]</erro>
	        <tipoendereco>[[TIPOENDERECO]]</tipoendereco>
	        <logradouro>[[LOGRADOURO]]</logradouro>
	        <numero>[[NUMERO]]</numero>
			<complemento>[[COMPLEMENTO]]</complemento>
	ENDTEXT
	lcXML   = STRTRAN(lcXML, '[[ERRO]]',lcERRO)
	lcXML   = STRTRAN(lcXML, '[[TIPOENDERECO]]', EVL(lcTIPOENDERECO,' '))
	lcXML   = STRTRAN(lcXML, '[[LOGRADOURO]]', EVL(lcLOGRADOURO,' '))
	lcXML   = STRTRAN(lcXML, '[[NUMERO]]', EVL(lcNUMERO,' '))
	lcXML   = STRTRAN(lcXML, '[[COMPLEMENTO]]', EVL(lcCOMPLEMENTO,' '))

	RETURN(lcXML)
ENDPROC

FUNC TIRANOALF
**************
LPARAMETERS tcSUJA AS String
	IF VARTYPE(tcSUJA) <> 'C'
		tcSUJA	= ''
	ENDIF
	tcSUJA = UPPER(tcSUJA)

	LOCAL I AS INTEGER
	LOCAL lcLETRA, lcLIMPA AS STRING
	LOCAL lcCARACSOK AS STRING
	lcCARACSOK = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 '
	lcLIMPA = ''
	FOR I = 1 TO LEN(tcSUJA)
		lcLETRA = SUBS(tcSUJA,I,1)
		IF NOT lcLETRA $ lcCARACSOK
			LOOP
		ENDIF
		lcLIMPA = lcLIMPA + lcLETRA
	ENDFOR
RETURN(lcLIMPA)

PROC VERERROCONSTRAINT
***********************
* VERIFICA SE ERRO FOI OCASIONADO DEVIDO A CONSTRAINT DE DEPÊNDENCIA, REGISTROS PAIS COM FILHOS
* RETORNA .T. SE É UM ERRO DE CONSTRAINT
LPARAMETERS taERRO

	LOCAL llRETORNO AS Logical
	STORE .F. TO llRETORNO

	LOCAL lvITEM1, lvITEM2, lvITEM3, lvITEM4, lvITEM5 AS Variant
	STORE '' TO lvITEM1, lvITEM2, lvITEM3, lvITEM4, lvITEM5 
	
	lvITEM1 = EVALUATE('taERRO[1]')
	lvITEM2 = EVALUATE('taERRO[2]')
	lvITEM3 = EVALUATE('taERRO[3]')
	lvITEM4 = EVALUATE('taERRO[4]')
	lvITEM5 = EVALUATE('taERRO[5]')
	
	DO CASE
		CASE goCONEXAO.BANCO = 'DBC'
			llRETORNO = .F.

		CASE goCONEXAO.BANCO = 'POS'
			IF lvITEM4 == 'HY000' AND 'UPDATE' $ UPPER(lvITEM2) AND 'DELETE' $ UPPER(lvITEM2) AND 'VIOLATES FOREIGN KEY CONSTRAINT' $ UPPER(lvITEM2)
				llRETORNO = .T.
			ENDIF

		CASE goCONEXAO.BANCO = 'ORA'
			IF lvITEM1 = 1526 AND lvITEM5 = 2292
				llRETORNO = .T.
			ENDIF
		
		CASE 'SQL SERVER' $ UPPER(goCONEXAO.DRIVER)
			IF lvITEM1 = 1526 AND lvITEM4 == '23000' AND lvITEM5 = 547
				llRETORNO = .T.
			ENDIF
	ENDCASE
RETURN(llRETORNO)

PROC CARREGARALARME
*******************
	goAPLICATIVO.CARREGARALARME()
RETURN

PROC EXECUTARALARME
*******************
	goAPLICATIVO.EXECUTARALARME()
RETURN

PROC ALERTARTASKBAR
*******************
	DECLARE INTEGER SetForegroundWindow IN user32 INTEGER hwnd
	SetForegroundWindow(_SCREEN.HWnd)
RETURN

PROC CHAMAFORM
**************
LPARAMETERS tcOBJETO, tcATRIBUTOS, tuPARAMETRO1, tuPARAMETRO2, tuPARAMETRO3, tuPARAMETRO4, tuPARAMETRO5
	* INICIALIZADOR DE FORM'S
	* - PARAMETROS - *
	* tcOBJETO				- NOME DO FORM A SER EXECUTADO
	* tcATRIBUTOS			- STRING COM INFORMAÇÕES SOBRE INICIALIZAÇÃO DO FORM
	*						- CONTEUDO (MODAL, NOREAD, NOSHOW)
	* tuPARAMETRO1, ...5	- PARAMETROS PARA SEREM ENCAMINHADOS AO FORM CHAMADO
	* - RETORNO - *
	* luRETORNO				- NO CASO DE FORM'S MODAIS, RETORNA VALOR PARA O FORM ANTERIOR

	IF TYPE('tcOBJETO') <> 'C'
		tcOBJETO	= ''
	ENDIF
	IF EMPTY(tcOBJETO)
		RETURN
	ENDIF
	IF TYPE('tcATRIBUTOS') <> 'C'
		tcATRIBUTOS	= ''
	ENDIF
	tcOBJETO	= ALLTRIM(UPPER(tcOBJETO))
	tcATRIBUTOS	= ALLTRIM(UPPER(tcATRIBUTOS))

	LOCAL lcCOMANDO, lcEXTRAS, lcARQUIVO AS String
	LOCAL lnXI AS Integer
	LOCAL luRETORNO

	STORE '' TO lcCOMANDO, lcEXTRAS, lcARQUIVO

	* NOME DO FORM PARA SER CHAMADO
	* FORÇANDO EXTENSÃO DO ARQUIVO PARA SCT
	tcOBJETO	= FORCEEXT(tcOBJETO, 'SCT')
	lcARQUIVO	= tcOBJETO

	* GUARDA NOME DO FORMULÁRIO NA PROPRIEDADE DO APLICATIVO
	** PARA CERTIFICAR QUE O FORM FOI CHAMADO PELO CHAMAFORM
	IF goAPLICATIVO.WAWTESTE = 1
		goAPLICATIVO.WAWCALLEDFORM = JUSTSTEM(lcARQUIVO)
	ENDIF

	* SOMENTE COMPARA ARQUIVOS NO MODO WAWATIVO LIGADO
	IF goAPLICATIVO.WAWATIVO = 1
		* NÃO É NECESSÁRIO COMPARAR ARQUIVOS "SYSTEM" POIS ESTÃO COMPILADOS NO EXECUTÁVEL
		IF NOT 'SYSTEM_' == UPPER(LEFT(tcOBJETO,7))
			lcARQUIVO = WAW_COMPARAR(tcOBJETO)
			IF EMPTY(lcARQUIVO)
				RETURN
			ENDIF
		ENDIF
	ENDIF

	* TESTANDO QUANTIDADE DE PARAMETROS PASSADOS
	FOR lnXI = 1 TO PCOUNT() -2
		lcEXTRAS	= lcEXTRAS + ', tuPARAMETRO' + STR(lnXI,1)
	ENDFOR
	lcEXTRAS	= SUBSTR( lcEXTRAS, 3 )
	IF NOT EMPTY(lcEXTRAS)
		lcEXTRAS	= ' WITH ' + lcEXTRAS
	ENDIF
	IF 'NOSHOW' $ tcATRIBUTOS
		lcEXTRAS	= lcEXTRAS + ' NOSHOW'
	ENDIF
	IF 'NOREAD' $ tcATRIBUTOS
		lcEXTRAS	= lcEXTRAS + ' NOREAD'
	ENDIF
	IF 'MODAL' $ tcATRIBUTOS
		lcEXTRAS	= lcEXTRAS + ' TO luRETORNO'
	ENDIF

	* AMBIENTE DE TESTES E SEJA UM VOLPE PADRAO
	IF goAPLICATIVO.TESTE AND goAPLICATIVO.VOLPEPADRAO = 1
		* PARA JOBS VERIFICA SE JOB EXISTE NA PASTA MESMO SENDO VOLPE PADRÃO
		IF goAPLICATIVO.JOB_STILLRUN AND NOT FILE(lcARQUIVO)
			lcARQUIVO = goAPLICATIVO.PATHVOLPEPADRAO + lcARQUIVO
		ELSE
		
			* REGRA: PRIMEIRO PROCURA NA PASTA TEMP, DEPOIS NA PASTA CUSTOM, DEPOIS NA PASTA STOB.
			DO CASE
				CASE FILE(FORCEPATH(lcARQUIVO,goAPLICATIVO.PATHVOLPETEMP ))
					* USA DA PASTA TEMP
					lcARQUIVO = FORCEPATH(lcARQUIVO,goAPLICATIVO.PATHVOLPETEMP)
					
				CASE FILE(lcARQUIVO)
					* USA O DA MESMA PASTA
					
				OTHERWISE
					* USA DA PASTA STOB
					lcARQUIVO = FORCEPATH(lcARQUIVO,goAPLICATIVO.PATHVOLPEPADRAO)
					
			ENDCASE

		
*!*				IF NOT '#'+JUSTSTEM(tcOBJETO)+'#' $ goAPLICATIVO.FORMSPERSONAL AND NOT 'SYSTEM_' == UPPER(LEFT(lcARQUIVO,7))
*!*					lcARQUIVO = goAPLICATIVO.PATHVOLPEPADRAO + lcARQUIVO
*!*				ENDIF
		ENDIF
	ENDIF

	lcARQUIVO	= FORCEEXT( lcARQUIVO, 'SCX' )	
	lcCOMANDO	= 'DO FORM ' + lcARQUIVO + lcEXTRAS
	&lcCOMANDO

RETURN(luRETORNO)

PROC CHAMAFXP
*************
LPARAMETERS tcOBJETO, tcATRIBUTOS, tuPARAMETRO1, tuPARAMETRO2, tuPARAMETRO3, tuPARAMETRO4, tuPARAMETRO5
	* INICIALIZADOR DE FORM'S
	* - PARAMETROS - *
	* tcOBJETO				- NOME DO OBJETO A SER EXECUTADO
	* tcATRIBUTOS			- SEM DEFINIÇÕES POR ENQUANTO
	* tuPARAMETRO1, ...5	- PARAMETROS PARA SEREM ENCAMINHADOS AO FORM CHAMADO
	* - RETORNO - *
	* luRETORNO				- RETORNA QUALQUER VALOR DO FXP CHAMADO

	LOCAL lcARQUIVO, lcDIRETORIO AS String
	STORE '' TO lcARQUIVO, lcDIRETORIO
	
	IF TYPE('tcOBJETO') <> 'C'
		tcOBJETO	= ''
	ENDIF
	IF EMPTY(tcOBJETO)
		RETURN
	ENDIF
	IF TYPE('tcATRIBUTOS') <> 'C'
		tcATRIBUTOS	= ''
	ENDIF
	tcOBJETO	= ALLTRIM(UPPER(tcOBJETO))
	tcATRIBUTOS	= ALLTRIM(UPPER(tcATRIBUTOS))

	tcOBJETO	= FORCEEXT(tcOBJETO, 'FXP')
	lcDIRETORIO	= 'OBJETOS\'
	lcARQUIVO	= lcDIRETORIO + tcOBJETO
	
	* AMBIENTE DE TESTES E É VOLPE PADRAO
	IF goAPLICATIVO.TESTE AND goAPLICATIVO.VOLPEPADRAO = 1
			
		* REGRA: PRIMEIRO PROCURA NA PASTA TEMP, DEPOIS NA PASTA CUSTOM, DEPOIS NA PASTA STOB.
		DO CASE
			CASE FILE(FORCEPATH(tcOBJETO,goAPLICATIVO.PATHVOLPETEMP+lcDIRETORIO))
				* USA DA PASTA TEMP
				lcARQUIVO = FORCEPATH(tcOBJETO,goAPLICATIVO.PATHVOLPETEMP+lcDIRETORIO)
				
			CASE FILE(lcDIRETORIO+tcOBJETO)
				* USA O DA MESMA PASTA
				lcARQUIVO = lcDIRETORIO+tcOBJETO
				
			OTHERWISE
				* USA DA PASTA STOB
				lcARQUIVO = FORCEPATH(tcOBJETO, goAPLICATIVO.PATHVOLPEPADRAO+lcDIRETORIO)
				
		ENDCASE
	ENDIF
	
	LOCAL lcCOMANDO, lcEXTRAS AS String
	LOCAL lnXI AS Integer
	LOCAL luRETORNO

	STORE '' TO lcCOMANDO, lcEXTRAS

	* QUANDO WAWATIVO - FAZ DOWNLOAD DO ARQUIVO
	IF goAPLICATIVO.WAWATIVO = 1
		tcOBJETO	= JUSTFNAME( tcOBJETO )
		lcARQUIVO	= WAW_COMPARAR(tcOBJETO)
		IF EMPTY(lcARQUIVO)
			RETURN
		ENDIF
	ENDIF

	* TESTANDO QUANTIDADE DE PARAMETROS PASSADOS
	FOR lnXI = 1 TO PCOUNT() - 2
		lcEXTRAS	= lcEXTRAS + ', tuPARAMETRO' + STR(lnXI,1)
	ENDFOR
	lcEXTRAS	= SUBSTR( lcEXTRAS, 3 )
	IF NOT EMPTY(lcEXTRAS)
		lcEXTRAS	= ' WITH ' + lcEXTRAS
	ENDIF

	* MATA REFÊNCIA DO FXP NA MEMÓRIA
	CLEAR PROGRAM
	
	lcCOMANDO	= 'DO ' + lcARQUIVO + lcEXTRAS
	&lcCOMANDO

RETURN(luRETORNO)


FUNC WAW_COMPARAR
****************
LPARAMETERS tcARQUIVO AS String, tlNAOEXIBIRMSG AS Logical

	* COMPARADOR DE ARQUVOS NA PASTA CORRENTE COM O ARQUIVO DO BANCO DE DADOS, ATUALIZANDO O ARQUIVO LOCAL SE NECESSÁRIO.
	IF TYPE('tcARQUIVO') <> 'C'
		tcARQUIVO	= ''
	ENDIF
	IF EMPTY(tcARQUIVO)
		RETURN('')
	ENDIF

	tcARQUIVO	= ALLTRIM(UPPER(tcARQUIVO))

	LOCAL lcARQUIVO, lcCOMANDO, lcDS_HASHLOCAL, lcMENS AS String
	LOCAL llBAIXARARQUIVO, llERRO AS Logical

	STORE '' TO lcARQUIVO, lcCOMANDO, lcDS_HASHLOCAL
	STORE .F. TO llBAIXARARQUIVO, llERRO

	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		SELECT
			DS_FILENAME,
			DS_PASTA,
			TG_FORMATO,
			DS_HASH
		FROM
			WAW_ARQUIVO
		WHERE
			DS_FILENAME=[[DS_FILENAME]]
	ENDTEXT
	lcCOMANDO = STRTRAN( lcCOMANDO, '[[DS_FILENAME]]', XX(tcARQUIVO) )
	=PESQUISASQL(lcCOMANDO,'WAWARQ')

	* NÃO ENCONTROU O FORM NA TABELA DE ARQUIVOS
	IF RECCOUNT('WAWARQ') <= 0
		TEXT TO lcMENS NOSHOW PRETEXT 3
			Problemas para fazer download do objeto!

			Causas possíveis:
			Upload não realizado

			------------------
			OBJETO: ([[DS_ARQUIVO]])
			------------------
		ENDTEXT
		lcMENS	= STRTRAN( lcMENS, '[[DS_ARQUIVO]]', tcARQUIVO )
		IF NOT tlNAOEXIBIRMSG
			DO MENS WITH lcMENS
		ENDIF
		RETURN( '' )
	ENDIF

	* LENDO ARQUIVO LOCAL PARA SABER ESTADO DO HASH
	lcDS_HASHLOCAL 	= ''
	lcARQUIVO		= ADDBS(ALLTRIM(UPPER(WAWARQ.DS_PASTA))) + tcARQUIVO
	IF NOT FILE(lcARQUIVO)
		llBAIXARARQUIVO	= .T.
	ELSE
		TRY 
			lcDS_HASHLOCAL = ALLTRIM(STRCONV(goAPLICATIVO.myZIP.HASHFILE(lcARQUIVO), 13))
		CATCH
			llERRO = .T.
		ENDTRY
	
		IF llERRO AND NOT tlNAOEXIBIRMSG
			DO MENS WITH 'ATENÇÃO! Não foi possível efetuar comparação de arquivo!'
		ENDIF
		
		IF lcDS_HASHLOCAL <> ALLTRIM(WAWARQ.DS_HASH)
			llBAIXARARQUIVO	= .T.
		ENDIF
	ENDIF
	USE IN WAWARQ

	IF llBAIXARARQUIVO
		DO ESPERANDO WITH 'Atualizando versão do objeto...'
		IF NOT WAW_BAIXARARQUIVO( tcARQUIVO, tlNAOEXIBIRMSG )
			lcARQUIVO	= ''
		ENDIF
		WAIT CLEAR
	ENDIF
RETURN( lcARQUIVO )

FUNC WAW_BAIXARARQUIVO
*********************
LPARAMETERS tcARQUIVO AS String, tlNAOEXIBIRMSG AS Logical
	* ATUALIZADOR DE ARQUIVOS VINDOS DO BANCO DE DADOS
	IF TYPE('tcARQUIVO') <> 'C'
		tcARQUIVO	= ''
	ENDIF
	IF EMPTY(tcARQUIVO)
		RETURN
	ENDIF
	tcARQUIVO	= ALLTRIM(UPPER(tcARQUIVO))

	LOCAL lcARQUIVO, lcARQZIP, lcARQNOVO AS String
	LOCAL lcCOMANDO, lcEXTENSAO, lcPATH, lcCONTEUDO, lcMENS AS String
	LOCAL lnXI AS Integer

	STORE '' TO lcCOMANDO, lcEXTENSAO, lcPATH, lcARQUIVO

	lcEXTENSAO	= JUSTEXT(tcARQUIVO)
	FOR lnXI = 1 TO 10
		lcCOMANDO	= 'SELECT * FROM WAW_ARQUIVO WHERE DS_FILENAME=' + XX(tcARQUIVO)
		=PESQUISASQL(lcCOMANDO,'WAWARQ')
		IF LEN(ALLTRIM(WAWARQ.HX_CONTEUDO)) = WAWARQ.QT_BYTES
			EXIT
		ENDIF
	ENDFOR
	IF LEN(ALLTRIM(WAWARQ.HX_CONTEUDO)) <> WAWARQ.QT_BYTES
		TEXT TO lcMENS NOSHOW PRETEXT 3
			Problemas para atualizar versão do objeto!
			
			Causas possíveis:
			Upgrade incompleto

			------------------
			OBJETO: ([[DS_ARQUIVO]])
			------------------
		ENDTEXT
		lcMENS	= STRTRAN( lcMENS, '[[DS_ARQUIVO]]', tcARQUIVO )
		IF NOT tlNAOEXIBIRMSG
			DO MENS WITH lcMENS
		ENDIF
		RETURN(.F.)
	ENDIF

	* VERIFICA SE EXISTE A PASTA REPOSITÓRIO DO ARQUIVO
	lcPATH	= ADDBS(ALLTRIM(UPPER(WAWARQ.DS_PASTA)))
	IF NOT EMPTY(lcPATH)
		IF NOT DIRECTORY(lcPATH)
			MKDIR (lcPATH)
		ENDIF
	ENDIF
	lcARQUIVO	= lcPATH + tcARQUIVO
	lcARQZIP	= TEMPFILE('ZIP')
	lcCONTEUDO	= STRCONV(WAWARQ.HX_CONTEUDO,14)
	STRTOFILE( lcCONTEUDO, lcARQZIP )
	
	* TENTANDO ATUALIZAR ARQUIVO ANTIGO
	IF FILE(lcARQZIP)
		IF FILE(lcARQUIVO)
			TRY 
				DELETE FILE (lcARQUIVO)
			CATCH
			FINALLY
			ENDTRY
			IF FILE(lcARQUIVO)
				TEXT TO lcMENS NOSHOW PRETEXT 3
					Problemas para atualizar versão do objeto!
					
					Causas possíveis:
					Outra instância do Volpe aberta com o objeto em uso

					------------------
					OBJETO: ([[DS_ARQUIVO]])
					------------------
				ENDTEXT
				lcMENS	= STRTRAN( lcMENS, '[[DS_ARQUIVO]]', tcARQUIVO )
				DO MENS WITH lcMENS
				RETURN( .F. )
			ENDIF
		ENDIF
		TRY
			goAPLICATIVO.myZIP.PASSWORD	= 'k!@qf#$w%¨en&T*¹i²i³h£aY¢¬Ma/L?k'
			goAPLICATIVO.myZIP.UNZIPFILE(lcARQZIP , FULLPATH(lcPATH))
		CATCH
		FINALLY
		ENDTRY
		IF NOT FILE(lcARQUIVO)
			TEXT TO lcMENS NOSHOW PRETEXT 3
				Problemas para atualizar versão do objeto!

				Causas possíveis:
				Outra instância do Volpe aberta com o objeto em uso

				------------------
				OBJETO: ([[DS_ARQUIVO]])
				------------------
			ENDTEXT
			lcMENS	= STRTRAN( lcMENS, '[[DS_ARQUIVO]]', tcARQUIVO )
			DO MENS WITH lcMENS
			RETURN( .F. )
		ENDIF
	ENDIF
	* REFAZ A ROTINA AUTOMATICAMENTE PARA FORM'S E REPORT'S
	IF INLIST( lcEXTENSAO, 'SCT', 'FRT' )
		lcARQNOVO	= FORCEEXT( tcARQUIVO, STRTRAN(lcEXTENSAO,'T','X') )
		IF NOT WAW_BAIXARARQUIVO( lcARQNOVO )
			RETURN(.F.)
		ENDIF
	ENDIF
RETURN( .T. )

FUNC ARREDONDA
**************
LPARAMETERS tnVL_ORIGEM, tcDS_TIPO
	IF VARTYPE(tnVL_ORIGEM) <> 'N'
		tnVL_ORIGEM	= 0
	ENDIF
	IF EMPTY(tnVL_ORIGEM)
		RETURN(0)
	ENDIF
	IF VARTYPE(tcDS_TIPO) <> 'C'
		tcDS_TIPO	= ''
	ENDIF
	IF EMPTY(tcDS_TIPO)
		tcDS_TIPO	= 'PU'
	ENDIF
	LOCAL lnVL_RETORNO AS Number
	DO CASE
		CASE tcDS_TIPO = 'QT'
			* QTD. DE DECIMAIS DA PICTURE DE QUANTIDADE
			lnVL_RETORNO	= ROUND( tnVL_ORIGEM, goAPLICATIVO.QT_QTDECIMAIS )
		OTHERWISE
			* QTD. DE DECIMAIS DA PICTURE DE PREÇO UNITÁRIO
			lnVL_RETORNO	= ROUND( tnVL_ORIGEM, goAPLICATIVO.QT_PUDECIMAIS )
	ENDCASE
RETURN( lnVL_RETORNO )

PROC VMODULO
************
LPARAMETERS tcMODULO AS String

	LOCAL llRETORNO AS Logical
	STORE .F. TO llRETORNO
	
	LOCAL lnXI, lnOCCURS AS Integer

	LOCAL lcMODULO AS String
		
	IF VARTYPE(tcMODULO) <> 'C'
		tcMODULO = ''
	ENDIF
	
	tcMODULO = ','+tcMODULO+','
	lnOCCURS = OCCURS(',',tcMODULO)
	
	FOR lnXI = 1 TO lnOCCURS-1
		lcMODULO = STREXTRACT(tcMODULO, ',' , ',' , lnXI)
		IF NOT EMPTY(lcMODULO)
			IF '#'+lcMODULO+'#' $ goAPLICATIVO.MODULOSATIVOS
				llRETORNO = .T.
				EXIT
			ENDIF
		ENDIF
	ENDFOR
	
	RETURN(llRETORNO)
ENDPROC

PROC DESABILITARBOBJS
******************
LPARAMETERS toOBJETO AS Object

	LOCAL loSUB, loPAGINA AS Object
	LOCAL lcBASE, lcMODULO AS String
	STORE '' TO lcBASE, lcMODULO

	FOR EACH loSUB IN toOBJETO.CONTROLS

		lcBASE	= ALLTRIM( UPPER( loSUB.BASECLASS ) )

		DO CASE
			CASE lcBASE	= 'PAGEFRAME'
				FOR EACH loPAGINA IN loSUB.PAGES
					DO DESABILITARBOBJS WITH loPAGINA
				ENDFOR

			CASE lcBASE = 'CONTAINER'
				DO DESABILITARBOBJS WITH loSUB
			
			OTHERWISE
				* MUDA COR DE DESABILITADO PARA MELHORAR A APARÊNCIA
				IF lcBASE $ '|LABEL|TEXTBOX|'
					loSUB.DisabledForeColor = RGB(128,128,128)
				ENDIF

				IF VARTYPE(loSUB) = 'O' AND TYPE('loSUB.Enabled') = 'L'
					loSUB.Enabled = .F.
				ENDIF
		ENDCASE
	ENDFOR
RETURN

PROC MONTAPAGEDESKTOP
*********************
LPARAMETERS toPAGE AS Page
		LOCAL lnTOPO, lnTOPOINI, lnMARGEMINI, lnMARGEMPULO, lnWIDTH, lnHEIGHT,lnQUEBRATALHO, lnGUIAFALSA  AS Integer
		LOCAL lcSUPERVISOR AS String 

		lnTOPOINI    	= IIF(goAPLICATIVO.TITULOCOLUNA=1,25,0)
		lnMARGEMINI  	= IIF(goAPLICATIVO.FLUXOMODULO=1,25,0)
		lnMARGEMPULO 	= 156 
		lnQUEBRATALHO	=0
		lnGUIAFALSA 	= 0
		
		*#FLAT - MARGEM ENTRE COLUNAS MAIOR 
		IF goAPLICATIVO.FLAT = 1 
			lnMARGEMPULO = 125 &&lnMARGEMPULO = lnMARGEMPULO + 20
		ENDIF 
	
		LOCAL lcXML, lcGI AS String
		STORE '' TO lcXML, lcGI
		
		IF EMPTY(toPAGE.Tag)
			RETURN
		ENDIF

		lcXML = toPAGE.Tag

		=XMLTOCURSOR(lcXML,'TMPSYSXML')
		
		* LIMPA PARA NÃO REFAZER GUIA
		toPAGE.Tag = ''
		
		* DEPENDENDO DO TAMANHO DO CAMPO DE GRUPO A SIGLA DE SUPERVISOR É DIFERENTE
		lcSUPERVISOR = IIF(goCONEXAO.TAMANHOGRUPO=1,'S','SSS')
		
		SELE TMPSYSXML
		GO TOP
		SCAN WHILE NOT EOF()
			llTEMDIREITO	= .F.
			IF NOT lcSUPERVISOR $ goCONEXAO.GRUPO
				* NÃO É SUPERVISOR, TEM QUE VERIFICAR DIREITOS
				IF TMPSYSXML.TG_GUIAHOME = 1
                 	llTEMDIREITO  = .T.
	            ELSE
            	    llTEMDIREITO  = VERIFGRUPOS(GOCONEXAO.GRUPO,TMPSYSXML.DS_DIREITOS)
				ENDIF
			ELSE
				llTEMDIREITO	= .T.
			ENDIF
			IF NOT llTEMDIREITO
				LOOP
			ENDIF
			* GUIA
			IF TMPSYSXML.NR_TIPO=0
				* NR_TIPO = 0	: GUIA
				*			1	: ROTINA CHAMADA NA GUIA
				*			2	: ROTINA CHAMADA POR OUTRAS ROTINAS (NÃO APARECE NA GUIA)

				* MONTA NOVA PÁGINA
				loPAGE = toPAGE
				loPAGE.CAPTION = ALLTRIM(TMPSYSXML.DS_TITULO)
				
				* FUNDO BRANCO DA PAGINA COM SCROLLBARS
				loPAGE.NewObject('scntBRANCO','CTL32_SCONTAINER','RESCLASS')				
				
				WITH loPAGE.scntBRANCO
					*#FLAT - CONFIGURA CONTAINER
					IF goAPLICATIVO.FLAT = 1 
						.ctlscrollbars 	= 0 && SEM SCROLLBAR
						.TOP			= 120 - 20
						.LEFT			= 10
						.WIDTH			= .PARENT.PARENT.WIDTH-25
						.HEIGHT			= .PARENT.PARENT.PAGEHEIGHT-120-10 + 20 &&135 INICIO DA AREA + 10 ESPAÇAMENTO
					ELSE
						.TOP			= 5
						.LEFT			= 2
						.WIDTH			= .PARENT.PARENT.WIDTH-10
						.HEIGHT		= .PARENT.PARENT.PAGEHEIGHT-10
					ENDIF 
					
					* CONFIGURAÇÕES COMUNS 
					.ANCHOR		= 0
					.VISIBLE	= .F.
			  
			   
									  
											
					.BACKCOLOR	= RGB(255,255,255)
					.ANCHOR		= 1+2+4+8
				ENDWITH
				STORE 0 TO lnATALHO, lnQTMARGEM, lnMAXHEIGHT
				lnMARGEM = lnMARGEMINI 
				lnTOPO = lnTOPOINI
				
				* ADICIONANDO OBJETO DE SELEÇÃO
				loPAGE.scntBRANCO.scrollarea.AddObject('shpSEL', "SHAPE")
				
				*#FLAT - MARCAÇÃO DE ÍCONE SELECIONADO 
				IF goAPLICATIVO.FLAT = 1 
					loPAGE.scntBRANCO.scrollarea.shpSEL.Curvature	= 0		
				ELSE 
					loPAGE.scntBRANCO.scrollarea.shpSEL.Curvature	= 20	
				ENDIF
				
				loPAGE.scntBRANCO.scrollarea.shpSEL.BackColor	= RGB(224,244,255) && ALTERARGB(loPAGE.BACKCOLOR,125)
				loPAGE.scntBRANCO.scrollarea.shpSEL.BorderColor	= RGB(97,176,233) && loPAGE.BACKCOLOR			  

				* IMAGEM DO FUNDO DO TITULO
				IF goAPLICATIVO.TITULOCOLUNA=1
					*#FLAT - NÃO ADICIONAR FUNDO ÀS COLUNAS 
					IF goAPLICATIVO.FLAT = 0
						lcIMGPAGE = 'imgPAGE'+ALLTRIM(STR(toPAGE.PageOrder))

						loPAGE.scntBRANCO.scrollarea.AddObject(lcIMGPAGE, "IMAGE")
						loIMAGECOL = loPAGE.scntBRANCO.scrollarea.&lcIMGPAGE

						loIMAGECOL.VISIBLE	= .T.
						loIMAGECOL.Stretch	= 2
						loIMAGECOL.LEFT		= lnMARGEM
						loIMAGECOL.Picture	= 'IMAGES\FUNDO.JPG'
						loIMAGECOL.WIDTH	= loPAGE.scntBRANCO.Width - 20
						loIMAGECOL.HEIGHT	= 22
					ENDIF 
				ENDIF

				STORE 'ZZZ' TO lcGI
				LOOP
			ENDIF
			IF TMPSYSXML.NR_TIPO<>1
				LOOP
			ENDIF
			
			lnATALHO	= lnATALHO + 1
			lcMENU		= "cntOP"+ALLTRIM(STR(lnATALHO))

			*#FLAT - CASO ESTEJA NO LAYOUT FLAT BUSCA EM PASTA PRÓPRIA DE ACORDO COM CAMPO NA TS_MODULOS
			IF goAPLICATIVO.FLAT = 1 
				
				* CASO ÍCONE NÃO SEJA INFORMADO CARREGA ÍCONE DEFAULT 
				IF EMPTY(TMPSYSXML.DS_ICONE)
					IF goAPLICATIVO.TESTE OR goAPLICATIVO.WAWATIVO = 0 
						lcPICTURE	= "ICONFLAT\PIN.PNG"
					ELSE 
						lcPICTURE	= "ICONES\PIN.PNG"
					ENDIF 
				ELSE 
					* ICONES FLAT.PNG
					IF goAPLICATIVO.TESTE OR goAPLICATIVO.WAWATIVO = 0 
						lcPICTURE	= "ICONFLAT\"+ALLTRIM(JUSTSTEM(NVL(TMPSYSXML.DS_ICONE,'')))+'.PNG'	
					ELSE 
						lcPICTURE	= "ICONES\"+ALLTRIM(JUSTSTEM(NVL(TMPSYSXML.DS_ICONE,'')))+'.PNG'	
					ENDIF 
				ENDIF 
				
			ELSE 
				IF goAPLICATIVO.IMGDESKTOP = 1 
					&& .PNG
					IF NOT EMPTY(ALLTRIM(NVL(TMPSYSXML.DS_ICONEPNGCUSTOM,'')))
						&& ÍCONE CUSTOM - COMUMENTE USADO NO MYREPORTS
						lcPICTURE	= "ICONES\"+ALLTRIM(NVL(TMPSYSXML.DS_ICONEPNGCUSTOM,''))+'.PNG'
					ELSE
						&& ÍCONE DEFAUTL - USA NOME DA ROTINA
						lcPICTURE	= "ICONES\"+ALLTRIM(NVL(TMPSYSXML.DS_ROTINA,''))+'.PNG'
					ENDIF
				ELSE
					* OUTROS = .ICO
					lcPICTURE	= "ICONES\"+ALLTRIM(NVL(TMPSYSXML.DS_ROTINA,''))+'.ICO'
				ENDIF 
			ENDIF
			
			IF lnATALHO>1
				*#FLAT - ESPAÇAMENTO ENTRE ÍCONES
				IF goAPLICATIVO.FLAT = 1 
					lnTOPO = lnTOPO + 100
				ELSE 
					lnTOPO = lnTOPO + IIF(_SCREEN.WIDTH<1000,40,50)
				ENDIF			
			ENDIF
			
			lnCOUNTICONPAGE = INT((loPAGE.scntBRANCO.Height - lnTOPOINI + 15) / 100) 

			lnMAXHEIGHT	= MAX( SYSMETRIC(22)-(SYSMETRIC(9)*3)-(goDESKTOP.PAGINAS.HEIGHT-goDESKTOP.PAGINAS.PAGEHEIGHT)-90, lnTOPO )
			IF TMPSYSXML.DS_GI <> lcGI OR (GOAPLICATIVO.FLAT = 1 AND lnQUEBRATALHO = lnCOUNTICONPAGE) 
				IF TMPSYSXML.DS_GI <> lcGI
					lnQUEBRATALHO = 0
				ENDIF
			    
				lnMARGEM		= lnMARGEM + IIF(lcGI='ZZZ',0,lnMARGEMPULO)
				lcGI			= TMPSYSXML.DS_GI
								  
				lnTOPO			= lnTOPOINI
				lnQTMARGEM		= lnQTMARGEM + 1
				lcAUX			= 'linPAG'+STRZERO(lnQTMARGEM,2)
								
				*#FLAT
				IF lnQUEBRATALHO = lnCOUNTICONPAGE
					lnGUIAFALSA 	= lnGUIAFALSA +  1
					lnQUEBRATALHO 	= 0
				ELSE
					lnGUIAFALSA 	= 0
				ENDIF
				
				lcTITCOLUNA 	= 'lblCOLUNA'+lcGI+ALLTRIM(TRANSFORM(lnGUIAFALSA))
				
				*#FLAT - OBJETO NÃO EXISTE NO LAYOUT  
				IF goAPLICATIVO.FLAT = 0 
					loPAGE.scntBRANCO.scrollarea.AddObject(lcAUX , "LINE")
					WITH loPAGE.scntBRANCO.scrollarea.&lcAUX
						.TOP			= .PARENT.TOP
						.PARENT.HEIGHT	= lnMAXHEIGHT

						IF goAPLICATIVO.TITULOCOLUNA = 1
							.HEIGHT			= 22
							.LEFT			= lnMARGEM + lnMARGEMPULO - 2
						ELSE
							.HEIGHT			= lnMAXHEIGHT
							.LEFT			= lnMARGEM - 2

							loPAGE.scntBRANCO.ScrollArea.SetAll( 'Anchor', 0, 'Line' )
							loPAGE.scntBRANCO.ScrollArea.SetAll( 'Anchor', 5, 'Line' )
						ENDIF

						.WIDTH			= 0
						.VISIBLE		= .T.
						.BORDERCOLOR	= RGB(200,200,200)
					ENDWITH
				ENDIF 

				
				* LABEL COM TITULO DA COLUNA
				IF goAPLICATIVO.TITULOCOLUNA = 1
					loPAGE.scntBRANCO.scrollarea.AddObject(lcTITCOLUNA , "LABEL")
					loLABEL = loPAGE.scntBRANCO.scrollarea.&lcTITCOLUNA
																							   
					loLABEL.VISIBLE		= .T.
					loLABEL.BACKSTYLE 	= 0
					loLABEL.AUTOSIZE 	= .F.
					
					* VERIFICA SE NÃO É GUIA FALSA (CONTINUAÇÃO DA ANTERIOR)
					IF lnGUIAFALSA = 0
						loLABEL.CAPTION 	= ALLTRIM( IIF(EMPTY(TMPSYSXML.DS_GINOME),'Coluna',TMPSYSXML.DS_GINOME) )			   
					ELSE
						loLABEL.CAPTION 	= ''										
					ENDIF
										
					*#FLAT - CONFIGURA TÍTULO DO HEADER 
					IF goAPLICATIVO.FLAT = 1 
						loLABEL.FONTNAME	= 'Segoe UI Semilight'
						loLABEL.FONTSIZE	= 8										
						loLABEL.FORECOLOR	= RGB(50,50,50)					
						loLABEL.FONTBOLD	= .T.
						loLABEL.TOP			= 5
						loLABEL.LEFT 		= lnMARGEM&&+11
						loLABEL.Width		= 125&&150
						
						* SE FOR
						IF lnGUIAFALSA >= 1
							lcTITCOLUNAAUX = STRTRAN(lcTITCOLUNA,ALLTRIM(TRANSFORM(lnGUIAFALSA)),'0')
							loLABELAUX 				= loPAGE.scntBRANCO.scrollarea.&lcTITCOLUNAAUX 
							loLABELAUX.AUTOSIZE 	= .F.
							loLABELAUX.WIDTH		= (125 * (lnGUIAFALSA + 1)) &&(175 * (lnGUIAFALSA + 1))
							loLABELAUX.ALIGNMENT 	= 2

							*#FLAT -  CASO GUIA TENHA CONTINUAÇÃO NÃO HÁ NECESSIDADE DE ALTERAR FORTAMAÇÃO  
							IF LEN(loLABELAUX.CAPTION) > 21
								loLABELAUX.WordWrap		= .F.
								loLABELAUX.Top			= 5
								loLABELAUX.Height 		= 18
							ENDIF 
						ELSE 
							*#FLAT - ALTERA FORMATAÇÃO CASO ULTRAPASSE 20 CARACTERES  
							IF LEN(loLABEL.CAPTION) > 21
								loLABEL.WordWrap	= .T.
								loLABEL.Top			= -1
								loLABEL.Height 		= 36
							ENDIF 
						ENDIF
					ELSE
						loLABEL.FONTNAME	= 'ARIAL'
						loLABEL.FONTSIZE	= 8										
						loLABEL.FORECOLOR	= RGB(255,255,255)	
						loLABEL.FONTBOLD	= .F.
						loLABEL.TOP			= 3
						loLABEL.LEFT 		= lnMARGEM-2
						loLABEL.Width		= 152
					ENDIF 
					
					loLABEL.Alignment	= 2
				ENDIF´
				
				*#FLAT - ADICIONA HEADER ÀS COLUNAS 
				IF goAPLICATIVO.FLAT = 1 			
					lcHEADER = 'shpHEADER' + ALLTRIM(lcGI) + ALLTRIM(TRANSFORM(lnGUIAFALSA))
					loPAGE.scntBRANCO.scrollarea.AddObject(lcHEADER,'Shape')
					lcHEADER = 'loPAGE.scntBRANCO.scrollarea.' + lcHEADER  
								
					WITH &lcHEADER AS Shape 
						.Visible 		= .T. 
						.BackColor		= RGB(125,76,224)
						.BorderColor	= loPAGE.BackColor &&RGB(125,76,224)
						.BorderWidth	= 0
						.height			= 2
						.left			= lnMARGEM + 2 + 10
						.top			= 25
						.width			= 100 &&**
						IF lnGUIAFALSA >= 1
							.LEFT = .LEFT - 50
							.width = .width + 50
						ENDIF 
					ENDWITH 
				ENDIF
			ENDIF

			loPAGE.scntBRANCO.scrollarea.AddObject(lcMENU , "MEUATALHO") 
			
			lnQUEBRATALHO = lnQUEBRATALHO + 1 
			WITH loPAGE.scntBRANCO.scrollarea. &lcMENU
				
				*# FLAT - CONFIGURAÇÕES DO ATALHO 
				IF goAPLICATIVO.FLAT = 1 
					lcAUX = 'loPAGE.scntBRANCO.scrollarea.' + ALLTRIM(lcMENU)
					WITH &lcAUX 
						.Width 					= 100 &&**
						.Height 				= 90 +10 &&+ 15 
						.lblDS_ROTINA.AutoSize	= .F.
						.lblDS_ROTINA.Alignment = 2 && CENTER 
						.lblDS_ROTINA.FontName 	= goAPLICATIVO.FLATFONT2
						.lblDS_ROTINA.FontSize	= 9 
						.lblDS_ROTINA.ForeColor = RGB(0,0,160)
						.lblDS_ROTINA.Height 	= 30 + 15 
						.lblDS_ROTINA.Width 	= 100&&150
						.lblDS_ROTINA.WordWrap 	= .T.
						.lblDS_ROTINA.Top		= 55 - 3 &&60
						.lblDS_ROTINA.Left 		= 0
						
						.imgICONE.Stretch 		= 1
						.imgICONE.Top			= 2
						.imgICONE.Left			= 25&&50
						.imgICONE.Width 		= 50
						.imgICONE.Height		= 50  
					ENDWITH 					
					
					* ESPAÇO EM BRANCO DOS PRIMEIROS ICONES
					.LEFT			= lnMARGEM + 11
					.WIDTH			= 100&&150
				ELSE	
					* ESPAÇO EM BRANCO DOS PRIMEIROS ICONES
					.LEFT			= lnMARGEM + 3
					.WIDTH			= 146
				ENDIF 
			
				
				.TOP			= lnTOPO + 7
						  
				  

				.myTITULO		= ALLTRIM(TMPSYSXML.DS_TITULO)
				.myTIPTITULO	= TMPSYSXML.DS_TIPTITULO
				.myNOMEDOPAI	= TMPSYSXML.DS_NOMEDOPAI
				.myROTINA		= ALLTRIM(TMPSYSXML.DS_ROTINA)+'.SCX'
				.myPARAMETRO	= ALLTRIM(TMPSYSXML.DS_PARAMETROS)

				.myPICTURE		= lcPICTURE
				
				.VISIBLE		= .T.

				.myAMBIENTAR()

				lnWIDTH		= .WIDTH + .LEFT + 1
				lnHEIGHT	= .HEIGHT + .TOP + 1
				
				IF lnWIDTH + 1 > loPAGE.scNTBRANCO.myWIDTH
					loPAGE.scNTBRANCO.myWIDTH = lnWIDTH + 1
				ENDIF

				IF lnHEIGHT > loPAGE.scNTBRANCO.myHEIGHT
					IF lnMAXHEIGHT > lnHEIGHT
						loPAGE.scNTBRANCO.myHEIGHT = lnMAXHEIGHT
					ELSE
						loPAGE.scNTBRANCO.myHEIGHT = lnHEIGHT
					ENDIF
				ENDIF

			ENDWITH

			loPAGE.scntBRANCO.ScrollArea.Refresh()

		ENDSCAN

		IF USED('TMPSYSXML')
			USE IN TMPSYSXML
		ENDIF

		* AJUSTANDO IMAGEM DE FUNDO
		IF goAPLICATIVO.TITULOCOLUNA = 1
			*#FLAT - LAYOUT NÃO POSSUI COMPONENTE 
			IF goAPLICATIVO.FLAT = 0 	
				loIMAGECOL.WIDTH	= MAX(loPAGE.scntBRANCO.Width,loPAGE.scntBRANCO.scROLLAREA.Width) - 1
			ENDIF 	
		ENDIF

		loPAGE.scntBRANCO.Visible	= .T.
			
		*#FLAT BOTÕES DE SCROLL
		* PROJEÇÃO DE QUANTIDADE DE PÁGINAS TOTAIS E PROJETA SCROLL PARA NÃO QUEBRAR PÁGINA NO MEIO
		IF GOAPLICATIVO.FLAT = 1
			
			* PROPRIEDADES PARA CONTROLE DE PAGINAÇÃO
			loPAGE.AddProperty('myPAGEATU')
			loPAGE.AddProperty('myPAGETOT')
			loPAGE.myPAGEATU = 1
			
			* CRIA BOTÃO DE SCROL >>
			loPAGE.newObject('cmdAVANCAR','BOTAOSCROLL')
			WITH loPAGE.cmdAVANCAR
				.Visible = .T.
				.Top = 90 - 18
				.Left = .Parent.Parent.Width - 40
				.Height = 24
				.Width	= 24
				.Stretch = 1
				.Tag = 'AVANÇAR'
			ENDWITH
			
			lnWIDTHPAGE = loPAGE.SCNTBRANCO.Width
			lnWIDTHSCROLL = loPAGE.SCNTBRANCO.SCROLLAREA.Width
			lnPAGES = 1
			IF lnWIDTHSCROLL > lnWIDTHPAGE
				lnPAGES = INT((lnWIDTHSCROLL/lnWIDTHPAGE)) + IIF(MOD(lnWIDTHSCROLL,lnWIDTHPAGE)>=1,1,0)
			ENDIF
			loPAGE.scNTBRANCO.myWIDTH = (lnWIDTHPAGE+25) * lnPAGES
			loPAGE.SCNTBRANCO.SCROLLAREA.Width = loPAGE.scNTBRANCO.myWIDTH
			
			* ALIMENTA PROPRIEDADE COM TODAS DE PÁGINAS
			loPAGE.myPAGETOT = lnPAGES
			
			lnXL = 1
			* ADICIONA LABELS COM QUANTIDADE DE PÁGINAS
			FOR lnXL = 1 TO lnPAGES
				lcLABEL = 'lblPAGENO'+ALLTRIM(TRANSFORM(lnXL))
				loPAGE.NewObject(lcLABEL,'LABELSCROLL')
				lcLABEL = 'loPAGE.' +lcLABEL
				loLABEL = &lcLABEL
				WITH loLABEL
					.Visible = .T.
					.Top = 70
					.Left = .Parent.Parent.Width - 58 - (20*(lnPAGES-lnXL))
					.AutoSize = .T.
					.BackStyle = 0
					.ForeColor = RGB(255,255,255)
					.Caption = ALLTRIM(TRANSFORM(lnXL))
					.FontName = GOAPLICATIVO.FLATFONT1
					.FontSize = 14
					* INCIALMENTE SOMENTE LABEL DA PAGINA 1, FICA NEGRITO
					IF lnXL = 1
						.FontBold = 1
					ENDIF
				ENDWITH
			ENDFOR
			
			* CRIA BOTÃO DE SCROL <<
			loPAGE.newObject('cmdVOLTAR','BOTAOSCROLL')
			WITH loPAGE.cmdVOLTAR
				.Visible = .T.
				.Top = 90 - 18
				.Left = .Parent.Parent.Width - 51 - (20*(lnPAGES+1))
				.Height = 24
				.Width	= 24
				.Stretch = 1
				.Tag = 'VOLTAR'
			ENDWITH
		ENDIF
		loPAGE.Activate()
ENDPROC


PROC GRAVALOGJOB
****************
LPARAMETERS tcDS_ROTINA AS String

	IF VARTYPE(tcDS_ROTINA) <> 'C'
		RETURN
	ENDIF
	
	LOCAL loREGJOB AS Object
	=PESQUISASQL('SELECT * FROM TS_LOGS WHERE 1=2','TMPSYSJOB')
	SELE TMPSYSJOB
	SCATTER NAME loREGJOB
		loREGJOB.FK_USUARIO = goCONEXAO.FK_USUARIO
		loREGJOB.DH_LOG		= DATASERVER()
		loREGJOB.DS_ROTINA	= tcDS_ROTINA
		loREGJOB.TG_ACAO	= '!'
		loREGJOB.DS_OBJETOPK= ''
		loREGJOB.DS_TABELA	= ''
		loREGJOB.DS_OBS		= 'VOLPE EXECUTANDO EM MODO JOB'
		SELE TMPSYSJOB
		APPEND BLANK
	GATHER NAME loREGJOB
	* GRAVANDO LOG DO JOB EXECUTADO
	DO ATUSQL WITH 'A','TS_LOGS'
	IF USED('TMPSYSJOB')
		USE IN TMPSYSJOB
	ENDIF
RETURN

PROC CARREGARNFE
****************
LPARAMETERS tcNFE AS String
* RECEBE COMO PARÂMETRO NOME DA VERSÃO DA NFE UTILIZADA

	LOCAL llRETORNO, llATUALIZAR AS Logical
	STORE .F. TO llRETORNO, llATUALIZAR
	LOCAL lcNFE, lcNFETEMP, lcVERSAO AS String
	STORE '' TO lcNFE, lcNFETEMP, lcVERSAO
	
	lcNFE = UPPER(tcNFE)
	
	IF VARTYPE(lcNFE) <> 'C'
		lcNFE = ''
	ENDIF

	IF EMPTY(lcNFE)
		RETURN(.F.)
	ENDIF
	
	lcNFETEMP = TEMPFILE('APP')
	
	* NÃO EXISTE CLASSE NFE ENTÃO CARREGA NA SCREEN
	IF TYPE('_SCREEN.NFE') <> 'O'
		llATUALIZAR = .T.
	ELSE
		IF TYPE('_SCREEN.NFE.VERSAO') <> 'C'
			llATUALIZAR = .T.
		ELSE
			lcVERSAO = STREXTRACT(lcNFE,'V','.APP')
			* VERIFICA VERSÃO DO APP, É DIFERENTE ENTÃO ATUALIZA
			IF NOT _SCREEN.NFE.VERSAO == lcVERSAO
				llATUALIZAR = .T.
			ENDIF
		ENDIF
	ENDIF

	IF llATUALIZAR
		* NÃO É WAW ENTÃO COPIA CLASSE PARA MAQUINA LOCAL
		IF goAPLICATIVO.WAWATIVO = 0
			TRY 
				COPY FILE (lcNFE) TO (lcNFETEMP)
			CATCH
			ENDTRY
			* CONSEGUIU COPIAR ARQUIVO ENTÃO UTILIZA
			IF FILE(lcNFETEMP)
				lcNFE = lcNFETEMP
			ENDIF
		ENDIF
		
		* CASO CONTRÁRIO UTILIZA APP DA REDE
		TRY
			DO (tcNFE)
		CATCH
		ENDTRY
	ENDIF
	
	IF TYPE('_SCREEN.NFE') = 'O'
		lcVERSAO = STREXTRACT(tcNFE,'V','.APP')
		IF _SCREEN.NFE.VERSAO == lcVERSAO
			llRETORNO = .T.
		ENDIF
	ENDIF

	RETURN(llRETORNO)
ENDPROC

PROC SENDMAIL
*************
LPARAMETERS toOBJEMAIL, tnMODOSILENCIO
* PARAMETROS :	toOBJEMAIL(VER FUNC OBJEMAIL) - OBJETO QUE CONTÉM AS PROPRIEDADES:
*			  	DS_MENSPADRAO		= MENSAGEM PADRÃO A SER USADA NA MENSAGEM (OBRIGATÓRIO)
*			  	DS_DESTINATARIOS	= DESTINATÁRIO DA MENSAGEM 
*			  	DS_DESTINATARIOSCC	= DESTINATÁRIO CC DA MENSAGEM 
*			  	DS_DESTINATARIOSCCO	= DESTINATÁRIO CCO DA MENSAGEM 
*			  	DS_OBS				= OBSERVAÇÃO NO CORPO DA MENSAGEM 
*			  	DS_ID				= ID DO REGISTRO DE ENVIO (EX: NR_PEDIDO, PK_ID...)
*				tnMODOSILENCIO (1/0)= MODO SILENCIO (NÃO CHAMA FORM DE CONFIRMAÇÃO)

	IF TYPE('toOBJEMAIL.DS_DESTINATARIOS') <> 'C'
		toOBJEMAIL.DS_DESTINATARIOS= ''	
	ENDIF
	
	IF TYPE('toOBJEMAIL.DS_DESTINATARIOSCC') <> 'C'
		toOBJEMAIL.DS_DESTINATARIOSCC= ''	
	ENDIF
	
	IF TYPE('toOBJEMAIL.DS_DESTINATARIOSCCO') <> 'C'
		toOBJEMAIL.DS_DESTINATARIOSCCO= ''	
	ENDIF
	
	IF TYPE('toOBJEMAIL.DS_MENSPADRAO') <> 'C'
		toOBJEMAIL.DS_MENSPADRAO = ''
	ENDIF
	
	IF TYPE('toOBJEMAIL.DS_MENSEDITADA') <> 'C'
		toOBJEMAIL.DS_MENSEDITADA = ''
	ENDIF
	
	IF TYPE('tnMODOSILENCIO') <> 'N'
		tnMODOSILENCIO = 0	
	ENDIF
	
	IF EMPTY(toOBJEMAIL.DS_DESTINATARIOS) AND EMPTY(toOBJEMAIL.DS_DESTINATARIOSCC) AND EMPTY(toOBJEMAIL.DS_DESTINATARIOSCCO)
		DO MENS WITH 'Destinatário(s) da mensagem não informado(s) corretamente.'
		RETURN (.F.)
	ENDIF
	
	IF EMPTY(toOBJEMAIL.DS_MENSPADRAO)
		DO MENS WITH 'Mensagem padrão não informada corretamente.'
		RETURN (.F.)
	ENDIF
	
	IF FILE('P:\SYSTEM\PWICLASS.VCX')
		LOCAL loMAIL AS CNTSENDMAIL OF P:\SYSTEM\PWICLASS
	ELSE
		LOCAL loMAIL AS CNTSENDMAIL OF \TESTESVF\PLATA\SYSTEM\PWICLASS
	ENDIF
	
	PRIVATE loMAIL
	
	* CARREGA CLASSE DE EMAIL
	* NECESSÁRIO UTILIZAR CALLFORM DEVIDO O REFOX
	ADDPROPERTY(_SCREEN, 'CNTSENDMAIL')
	CALLFORM(" _SCREEN.CNTSENDMAIL = CREATEOBJECT('cntSENDMAIL') ")
	loMAIL = _SCREEN.CNTSENDMAIL
	REMOVEPROPERTY(_SCREEN,'CNTSENDMAIL')
	
	* SETA PROPRIEDADES
	loMAIL.myDESTINATARIOS 		= ALLTRIM(LOWER(toOBJEMAIL.DS_DESTINATARIOS))
	loMAIL.myDESTINATARIOSCC	= ALLTRIM(LOWER(toOBJEMAIL.DS_DESTINATARIOSCC))
	loMAIL.myDESTINATARIOSCCO	= ALLTRIM(LOWER(toOBJEMAIL.DS_DESTINATARIOSCCO))
	loMAIL.myMENSAGEMPADRAO		= ALLTRIM(UPPER(toOBJEMAIL.DS_MENSPADRAO))
	loMAIL.myOBS				= toOBJEMAIL.DS_OBS
	loMAIL.myID					= toOBJEMAIL.DS_ID
	loMAIL.myMENSAGEMEDITADA	= toOBJEMAIL.DS_MENSEDITADA
	loMAIL.myANEXOS				= toOBJEMAIL.DS_CAMINHOANEXO
	loMAIL.myLOGEMAIL			= toOBJEMAIL.TG_LOGEMAIL
	loMAIL.myREMETENTE			= toOBJEMAIL.DS_REMETENTE
	
	* MODO SILENCIO
	IF tnMODOSILENCIO >0
		loMAIL.myMODOSILENCIO = .T.
	ENDIF

	* ENVIA EMAIL
	llRETORNO = loMAIL.MYPOSTAR()
	
	* PROPRIEDADE PARA DELETAR OS ANEXOS DA PASTA EM QUE FOI CRIADO;
	  E PROTEÇÃO PARA NÃO FICAR SEGURANDO O ANEXO.
	IF NOT EMPTY(loMAIL.myANEXOS)
		loMAIL.cntPOSTARMAIL1.myCDOMESSAGE.Attachments.DeleteAll()
	ENDIF
	
	RETURN llRETORNO
	
ENDPROC

PROC OBJEMAIL
****************	
	LOCAL loRET AS Object
	loRET = CREATEOBJECT('EMPTY')
	=ADDPROPERTY(loRET,'DS_MENSPADRAO'      )
	=ADDPROPERTY(loRET,'DS_DESTINATARIOS'   )
	=ADDPROPERTY(loRET,'DS_DESTINATARIOSCC' )
	=ADDPROPERTY(loRET,'DS_DESTINATARIOSCCO')
	=ADDPROPERTY(loRET,'DS_OBS'         ,' ')
	=ADDPROPERTY(loRET,'DS_ID'          ,' ')
	=ADDPROPERTY(loRET,'DS_EXTRA'       ,' ')
	=ADDPROPERTY(loRET,'DS_MENSEDITADA' ,' ')
	=ADDPROPERTY(loRET,'DS_CAMINHOANEXO',' ')
	=ADDPROPERTY(loRET,'TG_LOGEMAIL'	,0)
	=ADDPROPERTY(loRET,'DS_REMETENTE'	,0)
	RETURN(loRET)
ENDPROC

PROC OBJIMPRESSAO
****************	
	LOCAL loRET AS Object
	loRET = CREATEOBJECT('EMPTY')
	=ADDPROPERTY(loRET, 'DS_DESTINATARIOS', '')
	=ADDPROPERTY(loRET, 'DS_DESTINATARIOSCC', '')
	=ADDPROPERTY(loRET, 'DS_DESTINATARIOSCCO', '')
	=ADDPROPERTY(loRET, 'DS_ASSUNTO', '')
	=ADDPROPERTY(loRET, 'TG_FORMATOMSG', 0)
	=ADDPROPERTY(loRET, 'DS_CORPO', '')
	RETURN(loRET)
ENDPROC

PROC CRIAROBJETO
*******************
* ROTINA UTILIZADA PARA CRIAÇÃO DE CLASSES QUE SE ENCONTRAM DENTRO DO EXE COM REFOX
LPARAMETERS tcOBJ AS String
	* RETORNA OBJETO CRIADO
	RETURN( CREATEOBJECT(tcOBJ) )
ENDPROC

FUNC CALC_CDKEY
***************
* RECEBE CD-KEY COM NO MÍNIMO 4 BLOCOS E CALCULA QUINTO BLOCO (DÍGITOS VERIFICADORES)
* PADRÃO ADOTADO: XXXX-XXXX-XXXX-XXXX-VVVV

LPARAMETERS tcKEY

IF VARTYPE(tcKEY) <> 'C'
	tcKEY = ''
ENDIF

tcKEY = PADR(tcKEY,20)

LOCAL lnSOMA, lnRESTO AS Integer
lnSOMA = 0
LOCAL lcDV, lcDV1 AS STRING
lcDV = ''

FOR lnI = 1 TO LEN(tcKEY)
	IF MOD(lnI,5)=0
		lnRESTO = MOD(lnSOMA+LEN(lcDV)+1,10)
		lcDV1 = STR( lnRESTO ,1)
		lcDV = lcDV + lcDV1
		lnSOMA = 0
		LOOP
	ENDIF
	lnSOMA = lnSOMA + ASC( SUBSTR(tcKEY,lnI,1) ) + lnI
ENDFOR

RETURN lcDV

FUNC VALIDA_CDKEY
*****************
LPARAMETERS lcCHAVE
	IF ALLTRIM(lcCHAVE) == PADR('REGISTROINVALIDO9999',20)
		* CHAVE DE AREA DE DESENVOLVIMENTO PWI (NÃO DEVE SER DIVULGADO)
		IF goAPLICATIVO.TESTE=.T.
			RETURN(.T.)
		ENDIF
		IF FILE('P:\SYSTEM\SYSTEM_LOGIN.SCX') OR FILE('\TESTESVF\PLATA\SYSTEM\SYSTEM_LOGIN.SCX')
			RETURN(.T.)
		ENDIF
	ENDIF
	LOCAL llOK AS LOGICAL
	llOK = .F.
	LOCAL lcDV1, lcDV2 AS String
	lcDV1 = SUBSTR(lcCHAVE,21,4)
	lcDV2 = CALC_CDKEY(lcCHAVE)
	IF lcDV1==lcDV2
		llOK = .T.
	ENDIF
RETURN(llOK)

********************
FUNC LOCK_VERIFICAR
*******************
* VERIFICAR SE UMA AÇÃO ESTÁ BLOQUEADA PARA EXECUÇÃO OU NÃO
* RETORNA (PK=LIVRE OU 0=BLOQUEADA)
LPARAMETERS lcACAO
	
	LOCAL lcCOMANDO,ldINICIO AS String
	LOCAL lnCONTLIN,lnPk_id  AS Integer
	LOCAL ltHORA AS Time   
	LOCAL llRESULT AS Logical 
	STORE .F. TO llRESULT
	
	* CASO NÃO TENHA A TABELA TS_LOCK NO SISTEMA RETORNA 1 (SÓ PARA NÃO BLOQUEAR ROTINA)
	DO LERTABLES WITH 'TS_LOCK'
	SELE TMPTABLES
	IF RECCOUNT('TMPTABLES') <= 0
		RETURN(1)
	ENDIF
	
	IF NOT TYPE('lcACAO') $ 'C'
		RETURN(0)
	ENDIF

	IF EMPTY(lcACAO)
		RETURN(0)
	ENDIF
	lcACAO = ALLTRIM(UPPER(lcACAO))
	************************************************
	*VERIFICA SE EXISTE ESTA AÇÃO
	TEXT TO LCCOMANDO NOSHOW PRETEXT 7
		SELECT
			LOC.*,
			COALESCE(USU.DS_LOGIN,'USUÁRIO-INDETERMINADO') AS DS_KKLOGIN
		FROM TS_LOCK LOC
		LEFT JOIN TS_USUARIOS USU ON USU.PK_ID = LOC.FK_USUARIO
		WHERE LOC.DS_ACAO = [ACAO]
	ENDTEXT
	lcCOMANDO = STRTRAN(lcCOMANDO,'[ACAO]',XX(lcACAO))
	=PESQUISASQL(lcCOMANDO,'TMPVERACAO')
	
	lnCONTLIN = RECCOUNT()
	IF lnCONTLIN = 0  
		* SE NÃO EXISTE, CRIA REGISTRO DE CONTROLE

		SELE TMPVERACAO
		APPEND BLANK
		REPLACE DS_ACAO WITH lcACAO
		DO ATUSQL WITH 'A','TS_LOCK','UPDATE=YES','DS_ACAO'
		RETURN(TMPVERACAO.PK_ID)
	ENDIF

	************************************************
	*SE AÇÃO ESTIVER SENDO USADA, ALERTA AO USUARIO QUEM ESTÁ USANDO E RETORNA 0
	ldINICIO = TMPVERACAO.DH_INICIO
	 
	IF NOT ISNULL(LDINICIO)

		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			ACESSO NEGADO NO MOMENTO.
			AÇÃO: [ACAO]
			
			Não é permitido efetuar esta operação agora, pois está sendo executada em outra estação de trabalho.'
			Está sendo utilizada por: 
			Usuário do sistema: [SISTEMA]
			Usuário da rede: [REDE]
			Máquina: [MAQUINA]
			Data e Hora : [HORA]
		ENDTEXT
	 
	 	lcCOMANDO = STRTRAN(lcCOMANDO,'[SISTEMA]',	XX(TMPVERACAO.DS_KKLOGIN))
		lcCOMANDO = STRTRAN(lcCOMANDO,'[REDE]',		XX(TMPVERACAO.DS_LOGINREDE))
		lcCOMANDO = STRTRAN(lcCOMANDO,'[MAQUINA]',	XX(TMPVERACAO.DS_MAQUINA))
		lcCOMANDO = STRTRAN(lcCOMANDO,'[ACAO]',		XX(TMPVERACAO.DS_ACAO))
		lcCOMANDO = STRTRAN(lcCOMANDO,'[HORA]',		TTOC(TMPVERACAO.DH_INICIO))
		DO MENS WITH lcCOMANDO
		RETURN(0)
	ENDIF
	
RETURN(TMPVERACAO.PK_ID)	

****************	
FUNC LOCK_LIMPAR
****************
* LIMPA O LOCK DE UMA AÇÃO
LPARAMETERS lnACAO
	LOCAL LCCOMANDO,lcUSUATUAL,lcUSUBD AS STRING
	
	* CASO NÃO TENHA A TABELA TS_LOCK NO SISTEMA RETORNA 1 (SÓ PARA NÃO BLOQUEAR ROTINA)
	DO LERTABLES WITH 'TS_LOCK'
	SELE TMPTABLES
	IF RECCOUNT('TMPTABLES') <= 0
		RETURN(1)
	ENDIF
	
	IF NOT TYPE('lnACAO') $ 'N'
		RETURN(-1)
	ENDIF

	IF lnACAO <= 0
		RETURN(-1)
	ENDIF
	
	***************************************
	*LIMPAR A AÇÃO.
	TEXT TO LCCOMANDO NOSHOW PRETEXT 7
		UPDATE 
			TS_LOCK 
		SET 
			DH_INICIO = NULL,
			DS_MAQUINA = NULL,
			DS_LOGINREDE =NULL,
			FK_USUARIO = 0
		WHERE 
			PK_ID=[PK_ID]
	ENDTEXT
	LCCOMANDO = STRTRAN(LCCOMANDO,'[PK_ID]',XX(lnACAO))
	EXECUTASQL(LCCOMANDO)
RETURN(1)

*****************
FUNC LOCK_INICIAR
*****************
* INICIA UM LOCK DA AÇÃO NO SISTEMA
LPARAMETERS lnACAO
	LOCAL lcREDE,lcMAQUINA,lcLOGIN,LCCOMANDO AS STRING
	
	* CASO NÃO TENHA A TABELA TS_LOCK NO SISTEMA RETORNA 1 (SÓ PARA NÃO BLOQUEAR ROTINA)
	DO LERTABLES WITH 'TS_LOCK'
	SELE TMPTABLES
	IF RECCOUNT('TMPTABLES') <= 0
		RETURN(1)
	ENDIF
	 
	IF NOT TYPE('lnACAO') $ 'N'
		RETURN(-1)
	ENDIF

	IF lnACAO = 0
		RETURN(-1)
	ENDIF

	*************************************************
	*VERIFICA SE EXISTE 
	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		SELECT
			LOC.DS_ACAO
			,lOC.PK_ID
			,COALESCE(USU.DS_LOGIN,'USUÁRIO-INDETERMINADO') DS_KKLOGIN
			,LOC.DS_MAQUINA
			,LOC.DS_LOGINREDE
			,LOC.DH_INICIO
		FROM 
			TS_LOCK LOC
		LEFT JOIN TS_USUARIOS USU ON 
			USU.PK_ID = LOC.FK_USUARIO
		WHERE 
			LOC.PK_ID = [PK_ID]
	ENDTEXT

	lcCOMANDO = STRTRAN(lcCOMANDO,'[PK_ID]',XX(lnACAO))
	=PESQUISASQL(lcCOMANDO,'TMPINIACAO')

	*************************************************
	* SE DH_INICIO NÃO ESTIVER NULLO, RETORNA -1
	IF RECCOUNT()= 0
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			ACESSO NEGADO NO MOMENTO.
			AÇÃO: [ACAO]
			
			Não é permitido efetuar esta operação agora, pois está sendo executada em outra estação de trabalho.'
			Está sendo utilizada por: 
			Usuário do sistema: [SISTEMA]
			Usuário da rede: [REDE]
			Máquina: [MAQUINA]
			Data e Hora : [HORA]
		ENDTEXT
	 
	 	lcCOMANDO = STRTRAN(lcCOMANDO,'[SISTEMA]',	XX(TMPINIACAO.DS_KKLOGIN))
		lcCOMANDO = STRTRAN(lcCOMANDO,'[REDE]',		XX(TMPINIACAO.DS_LOGINREDE))
		lcCOMANDO = STRTRAN(lcCOMANDO,'[MAQUINA]',	XX(TMPINIACAO.DS_MAQUINA))
		lcCOMANDO = STRTRAN(lcCOMANDO,'[ACAO]',		XX(TMPINIACAO.DS_ACAO))
		lcCOMANDO = STRTRAN(lcCOMANDO,'[HORA]',		TTOC(TMPINIACAO.DH_INICIO))
		DO mens WITH 'LOCK: Não existe este ID'
		RETURN(-1)
	ENDIF

	IF NOT ISNULL(TMPINIACAO.DH_INICIO)
		RETURN(-1)
	ENDIF		

	*************************************************
	*INCIA AÇÃO (ATUALIZA NO BD)
	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		
		UPDATE 
			TS_LOCK 
		SET 
			DH_INICIO = GETDATE(),
			DS_MAQUINA = [MAQUINA],
			DS_LOGINREDE =[REDE],
			FK_USUARIO = [USUARIO]
		WHERE 
			PK_ID = [PK_ID]
	ENDTEXT

	   lcREDE = '#' + SYS(0) + '#'
	lcMAQUINA = ALLTRIM(STREXTRACT(lcREDE,'#','#',1))
	  lcLOGIN = ALLTRIM(STREXTRACT(lcREDE,'#','#',2))   
	lcCOMANDO = STRTRAN(lcCOMANDO,'[MAQUINA]',XX(lcMAQUINA))
	lcCOMANDO = STRTRAN(lcCOMANDO,'[REDE]',XX(lcLOGIN))
	lcCOMANDO = STRTRAN(lcCOMANDO,'[USUARIO]',XX(GOCONEXAO.FK_USUARIO))
	lcCOMANDO = STRTRAN(lcCOMANDO,'[PK_ID]',XX(lnACAO))
	=EXECUTASQL(lcCOMANDO)
RETURN(1)

FUNC WAW_SUBIRARQUIVO
**********************************
* SOBE ARQUIVO PARA BANCO DE DADOS
LPARAMETERS tcARQUIVO AS String , tcPATH AS String
* tcARQUIVO - ARQUIVO A SER CARREGADO NA WAW_ARQUIVO
* tcPATH	- CAMPO QUE INDICA PASTA ONDE O ARQUIVO VAI SER BAIXADO

	LOCAL lcCONTEUDO, lcCOMANDO, lcFILENAME, lcACAO, lcHASH, lcTEMPFILE AS String
	STORE '' TO lcCONTEUDO, lcCOMANDO, lcFILENAME, lcACAO, lcHASH, lcTEMPFILE

	IF TYPE('tcARQUIVO') <> 'C'
		tcARQUIVO = ''
	ENDIF
		
	IF TYPE('tcPATH') <> 'C'
		tcPATH = ''
	ENDIF 

	tcPATH = UPPER(tcPATH)

	IF EMPTY(tcARQUIVO)
		DO MENS WITH 'Nenhum arquivo foi indicado para upload.'
		RETURN(.F.)
	ENDIF

	* VERIFICA SE O ARQUIVO EXISTE
	IF NOT FILE(tcARQUIVO)
		DO MENS WITH 'Falha no processo de upload, o arquivo não foi encontrado.'+CHR(13)+;
					 'Arquivo: ' + ALLTRIM(tcARQUIVO)
		RETURN(.F.)
	ENDIF
	
	DO ESPERANDO WITH 'Fazendo upload...'

	* VERIFICA SE VFPENCRYPTION FOI CARREGADA(PARA RETIRAR O HASH DO ARQUIVO)
	IF NOT goAPLICATIVO.myZIP.LOADVFPENCRYPTION
		goAPLICATIVO.myZIP.OpenLib('VFPENCRYPTION.FLL')
	ENDIF

	lcFILENAME 	= JUSTFNAME(tcARQUIVO)
	lcHASH 		= ALLTRIM(GOAPLICATIVO.myZIP.HASHFILE(FULLPATH(tcARQUIVO))) && CRIANDO HASH DO ARQUIVO
	lcHASH 		= STRCONV(lcHASH,13)

	lcTEMPFILE = GETENV("TEMP")+'\'+SYS(2015)+'.ZIP'
	IF FILE(lcTEMPFILE)
		DELETE FILE (lcTEMPFILE)
	ENDIF
				
	* ZIPANDO ARQUIVO
	goAPLICATIVO.myZIP.PASSWORD 	= ''
	goAPLICATIVO.myZIP.PASSWORD 	= 'k!@qf#$w%¨en&T*¹i²i³h£aY¢¬Ma/L?k'
	goAPLICATIVO.myZIP.FILES 		= tcARQUIVO
	goAPLICATIVO.myZIP.ZIPFILE(lcTEMPFILE)

	* TRANSFORMA P/ 64 BITS
	lcCONTEUDO = STRCONV(FILETOSTR(lcTEMPFILE),13)

	* VERIFICA SE ARQUIVO JÁ EXISTE NA BASE DE DADOS DO SISTEMA.
	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		SELECT
			*
		FROM WAW_ARQUIVO 
		WHERE DS_FILENAME = [DS_FILENAME]
	ENDTEXT
	lcCOMANDO	= STRTRAN( lcCOMANDO, '[DS_FILENAME]', XX(lcFILENAME) )
	=PESQUISASQL(lcCOMANDO,'TMPWAWARQUIVO')

	IF RECCOUNT('TMPWAWARQUIVO') >0
		* SE ENCONTRAR JA EXISTE A ROTINA NA BASE DE DADOS APENAS ALTERA
		lcACAO = 'M'
	ELSE
		* SE NAO ENCONTRAR INCLUI A ROTINA NA BASE DE DADOS
		lcACAO = 'A'
	ENDIF

	* MONTA CURSOR
	SELE TMPWAWARQUIVO
	SCATTER NAME loREG BLANK MEMO
	loREG.PK_ID				= TMPWAWARQUIVO.PK_ID
	loREG.HX_CONTEUDO 		= lcCONTEUDO
	loREG.DS_FILENAME		= lcFILENAME
	loREG.DS_PASTA			= tcPATH
	loREG.DS_HASH			= lcHASH
	loREG.TG_FORMATO		= IIF( JUSTEXT(lcFILENAME) $ 'KRN',1,0 )
	loREG.QT_BYTES			= LENC(lcCONTEUDO)
	loREG.TG_OBRIGATORIO	= 1

	SELE TMPWAWARQUIVO
	APPEND BLANK
	GATHER NAME loREG MEMO
	DO ATUSQL WITH lcACAO,'WAW_ARQUIVO'
	
	DO FIMESPERANDO
RETURN(.T.)

FUNC MONTAIN
************
* FUNCAO QUE TRAZ TODOS OS CODIGOS DE UM CURSOR SEPARADOS POR VIRGULA
************
LPARAMETERS tcCURSOR, tcCAMPO

	LOCAL lcRETORNO, lcMACRO AS String
	LOCAL lnREG AS Integer
	 
	STORE '' TO lcRETORNO, lcMACRO
	STORE 0 TO lnREG

	lcMACRO = tcCURSOR + '.' + tcCAMPO

	SELE &tcCURSOR
	IF NOT EOF() AND NOT BOF()
		lnREG = RECNO(tcCURSOR)
	ENDIF

	GO TOP
	SCAN WHILE NOT EOF(tcCURSOR)
		luAUX=&lcMACRO
		IF EMPTY(luAUX)
			LOOP
		ENDIF
		 
		IF TYPE(lcMACRO)='N'
			IF !VIRGULAR(TRANSFORM(luAUX)) $ lcRETORNO+','
		  		lcRETORNO = lcRETORNO + ',' + TRANSFORM(&lcMACRO)
			ENDIF
		ENDIF
		 
		IF TYPE(lcMACRO)='C'
			IF !VIRGULAR(XX(luAUX)) $ lcRETORNO +','
		 		lcRETORNO = lcRETORNO + "," + XX(&lcMACRO)
			ENDIF
		ENDIF
	ENDSCAN
	
	IF NOT EMPTY(lnREG)
		GO lnREG
	ENDIF

	lcRETORNO = SUBSTR(lcRETORNO,2)
	IF EMPTY(lcRETORNO)
		lcRETORNO="''"
	ENDIF

RETURN lcRETORNO

FUNC VERIFGRUPOS
****************
* FUNÇÃO QUE VERIFICA SE O GRUPO ESTÁ CONTIDO NA OUTRA STRING
****************
	LPARAMETERS tcGRUPOS, tcVERIFICAR, tnSUPERVISOR
	
	LOCAL lnQTDGRUPOS AS Integer 
	LOCAL lcGRUPO AS String 
	
	IF VARTYPE(tnSUPERVISOR) <> 'N'
		* POR DEFAULT ELE OLHA SE É SUPERVISOR
		tnSUPERVISOR = 1
	ENDIF
	
	* DE ACORDO COM O TAMANHO DO CAMPO DE GRUPOS É FEITO DE UMA FORMA OU DE OUTRA
	DO CASE
		CASE goCONEXAO.TAMANHOGRUPO = 1
			lnQTDGRUPOS = LEN(ALLTRIM(tcGRUPOS))
			FOR lnXI = 1 TO lnQTDGRUPOS
				lcGRUPO = SUBSTR(tcGRUPOS,lnXI,1)
				IF tnSUPERVISOR = -1
					IF lcGRUPO $ tcVERIFICAR
						RETURN(.T.)
					ENDIF
				ELSE
					IF 'S' $ lcGRUPO OR lcGRUPO $ tcVERIFICAR
						RETURN(.T.)
					ENDIF
				ENDIF
			ENDFOR
			
		CASE goCONEXAO.TAMANHOGRUPO = 3
			lnQTDGRUPOS = OCCURS(',',tcGRUPOS) + 1
			FOR lnXI = 1 TO lnQTDGRUPOS
				lcGRUPO = STREXTRACT(VIRGULAR(tcGRUPOS),',',',',lnXI)
				lcGRUPO = ALLTRIM(lcGRUPO)
				IF tnSUPERVISOR  = -1
					IF lcGRUPO $ VIRGULAR(tcVERIFICAR)
						RETURN(.T.)
					ENDIF
				ELSE
					IF 'SSS' $ lcGRUPO OR lcGRUPO $ VIRGULAR(tcVERIFICAR)
						RETURN(.T.)
					ENDIF
				ENDIF
			ENDFOR
			
	OTHERWISE
		RETURN(.F.)
	ENDCASE	

	RETURN(.F.)
ENDFUNC

PROC COMPARARTABELA
*******************
LPARAMETERS tcTAB1, tcTAB2

	IF TYPE('tcTAB1') <> 'C'
		tcTAB1 = ''
	ENDIF
	
	IF TYPE('tcTAB2') <> 'C'
		tcTAB2 = ''
	ENDIF	
	
	IF EMPTY(tcTAB1) OR EMPTY(tcTAB2)
		RETURN(.F.)
	ENDIF

	LOCAL lcCOMANDO,lcTYPE  AS STRING	
	
	* CARREGA ESTRUTURA TABELA DE ORIGEM
	TEXT TO lcCOMANDO NOSHOW TEXTMERGE PRETEXT 7
		SP_COLUMNS <<XX(tcTAB1)>>
	ENDTEXT
	=PESQUISASQL(lcCOMANDO,'TMPTAB1')

	* CARREGA ESTRUTURA TABELA DESTINO
	TEXT TO lcCOMANDO NOSHOW TEXTMERGE PRETEXT 7
		SP_COLUMNS <<XX(tcTAB2)>>
	ENDTEXT
	=PESQUISASQL(lcCOMANDO,'TMPTAB2')
	
	* CORRIGINDO TAMANHO DO CAMPO COLUMN_NAME (TAMANHO MUITO GRANDE PARA INDEXAR)
	SELECT CAST(COLUMN_NAME AS CHAR(80)) AS DS_COLUMN, * FROM TMPTAB1 INTO CURSOR TMPTAB1 READW
	SELECT CAST(COLUMN_NAME AS CHAR(80)) AS DS_COLUMN, * FROM TMPTAB2 INTO CURSOR TMPTAB2 READW
	
	SELE TMPTAB1
	INDEX ON UPPER(ALLTRIM(DS_COLUMN)) TO TEMPFILE()
	SELE TMPTAB2
	INDEX ON UPPER(ALLTRIM(DS_COLUMN)) TO TEMPFILE()
	
	* CRIA CURSOR COM RESUMO
	TEXT TO lcCOMANDO NOSHOW PRETEXT 15
		CREATE CURSOR TMPRESUMO(
			DS_COLUMN		C(30),
			DS_TYPE			C(15),
			NR_PRECISION	I,
			NR_SCALE		I,
			TG_NULL			N(1),
			TG_TIPO			C(1),
			DS_OBS			C(15),
			DS_SCRIPT		M(4)
		)
	ENDTEXT
	&lcCOMANDO
	
	* COMPARAR TABELAS
	SELE TMPTAB1
	GO TOP
	SCAN WHILE NOT EOF('TMPTAB1')
		SELE TMPTAB2
		SEEK UPPER(ALLTRIM(TMPTAB1.COLUMN_NAME))
		
		* SE A COLUNA EXISTIR COMPARA O TIPO E TAMANHO
		IF FOUND()
			LOCAL llALT AS Logical
			STORE .F. TO llALT
			
			DO CASE
				* CASO O TIPO DE DADOS FOR DIFERENTE
				CASE ALLTRIM(UPPER(TMPTAB1.TYPE_NAME)) # ALLTRIM(UPPER(TMPTAB2.TYPE_NAME))
					llALT = .T.
				* CASO O TAMANHO DO CAMPO FOR DIFERENTE
				CASE NVL(TMPTAB1.PRECISION,0) # NVL(TMPTAB2.PRECISION,0)
					llALT = .T.
				* CASE AS CASAS DECIMAIS FOREM DIFERENTES
				CASE NVL(TMPTAB1.SCALE,0) # NVL(TMPTAB2.SCALE,0)
					llALT = .T.
				OTHERWISE
					llALT = .F.
			ENDCASE
			
			* SE A COLUNA ESTIVER DIFERENTE ADICIONA NO RESUMO
			IF llALT
				lcTYPE = UPPER(ALLTRIM(TMPTAB1.TYPE_NAME))
				lcTYPE = IIF(lcTYPE=='INT','INTEGER',lcTYPE)
				
				SELE TMPRESUMO 
				SCATTER NAME loREG MEMO
					loREG.TG_TIPO		= 'M'
					loREG.DS_COLUMN		= UPPER(ALLTRIM(TMPTAB1.COLUMN_NAME))
					loREG.DS_TYPE		= lcTYPE
					loREG.NR_PRECISION	= NVL(TMPTAB1.PRECISION,0)
					loREG.NR_SCALE		= NVL(TMPTAB1.SCALE,0)
					loREG.TG_NULL		= TMPTAB1.NULLABLE
					loREG.DS_OBS		= 'ALTERAR COLUNA'
					loREG.DS_SCRIPT		= SCRIPT_CAMPO(loREG,tcTAB2)
				SELE TMPRESUMO 
				APPEND BLANK
				GATHER NAME loREG MEMO
			ENDIF
		ELSE	
			lcTYPE = UPPER(ALLTRIM(TMPTAB1.TYPE_NAME))
			lcTYPE = IIF(lcTYPE=='INT','INTEGER',lcTYPE)
				
			* SE A COLUNA NÃO EXISTIR ADICIONA NO RESUMO
			SELE TMPRESUMO
			SCATTER NAME loREG MEMO
				loREG.TG_TIPO		= 'M'
				loREG.DS_COLUMN		= UPPER(ALLTRIM(TMPTAB1.COLUMN_NAME))
				loREG.DS_TYPE		= lcTYPE
				loREG.NR_PRECISION	= NVL(TMPTAB1.PRECISION,0)
				loREG.NR_SCALE		= NVL(TMPTAB1.SCALE,0)
				loREG.TG_NULL		= TMPTAB1.NULLABLE
				loREG.DS_OBS		= 'NOVA COLUNA'
				loREG.DS_SCRIPT		= SCRIPT_CAMPO(loREG,tcTAB2)
			SELE TMPRESUMO
			APPEND BLANK
			GATHER NAME loREG MEMO
		ENDIF
	ENDSCAN
ENDPROC

PROC SCRIPT_CAMPO
******************
LPARAMETERS toCAMPO,tcTABLE
	
	DO CASE
		CASE toCAMPO.DS_TYPE $ 'CHAR,VARCHAR,NCHAR,NVARCHAR'
			lcCAMPO = ALLTRIM(toCAMPO.DS_COLUMN)+' '+toCAMPO.DS_TYPE+'('+TRANSFORM(toCAMPO.NR_PRECISION)+')'
			
		CASE toCAMPO.DS_TYPE $ 'NUMERIC,DECIMAL'
			lcCAMPO = ALLTRIM(toCAMPO.DS_COLUMN)+' '+toCAMPO.DS_TYPE+'('+TRANSFORM(toCAMPO.NR_PRECISION)+','+TRANSFORM(toCAMPO.NR_SCALE)+')'

		OTHERWISE
			lcCAMPO = ALLTRIM(toCAMPO.DS_COLUMN)+' '+toCAMPO.DS_TYPE
	ENDCASE
	
	* PERMISSÃO DE NULO
	IF toCAMPO.TG_NULL = 0
		lcCAMPO = lcCAMPO + ' NOT NULL '
	ENDIF
	
	* COMO PADRAO "PK_" É ADD COMO CHAVE PRIMARIA
	IF 'PK_' $ toCAMPO.DS_COLUMN
		lcCAMPO = lcCAMPO+ ' PRIMARY KEY '
	ENDIF
	
	DO CASE	
		* ADICIONANDO COLUNA
		CASE toCAMPO.DS_OBS = 'NOVA COLUNA'
			TEXT TO lcCOMANDO NOSHOW TEXTMERGE PRETEXT 7
				ALTER TABLE <<UPPER(tcTABLE)>> ADD
					<<lcCAMPO>>
			ENDTEXT

		* ATUALIZANDO COLUNA EXISTENTE
		CASE toCAMPO.DS_OBS = 'ALTERAR COLUNA'
			TEXT TO lcCOMANDO NOSHOW TEXTMERGE PRETEXT 7
				ALTER TABLE <<UPPER(tcTABLE)>> ALTER COLUMN
					<<lcCAMPO>>
			ENDTEXT

			* ALTER NÃO PODE CONTAR COMANDOS DE PRIMARY KEY NEM NOT NULL
			lcCOMANDO = STRTRAN(lcCOMANDO, ' PRIMARY KEY ','')
			lcCOMANDO = STRTRAN(lcCOMANDO, ' NOT NULL ','')
		OTHERWISE
			lcCOMANDO = ''
	ENDCASE
	lcComando = LOWER(lcComando)
	RETURN(lcCOMANDO)
ENDPROC

FUNC RETORNAGRUPOS
******************
LPARAMETERS tcPARAMETRO
***********************************************
* tcPARAMETRO - NOME DO PARAMETRO NA TS_MODULOS
***********************************************
	IF VARTYPE(tcPARAMETRO) <> 'C'
		RETURN('')
	ENDIF
	
	LOCAL 		lcCOMANDO,lcGRUPOS,lcCONTEUDO AS String
	STORE '' TO lcCOMANDO,lcGRUPOS,lcCONTEUDO
	
	LOCAL 		lnCONT AS Number
	STORE 0 TO	lnCONT
	
	* SELECIONANDO O REGISTRO PARA TRATAMENTO
	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		SELECT
			DS_DIREITOS
		FROM
			TS_MODULOS
		WHERE
			DS_ROTINA = [[DS_ROTINA]]
	ENDTEXT
	lcCOMANDO = STRTRAN(lcCOMANDO,'[[DS_ROTINA]]',XX(tcPARAMETRO))
	=PESQUISASQL(lcCOMANDO,'TMPGRUPOS')

	IF RECCOUNT('TMPGRUPOS') <= 0
		USE IN TMPGRUPOS
		RETURN(lcGRUPOS)
	ENDIF
	
	lcGRUPOS = ALLTRIM(TMPGRUPOS.DS_DIREITOS)

	USE IN TMPGRUPOS
RETURN(lcGRUPOS)

PROC SALVARGRUPOS
*****************
LPARAMETERS tcPARAMETRO,tcCONTEUDO
*************************************************
* tcPARAMETRO	- NOME DO PARAMETRO NA TS_MODULOS
* tcCONTEUDO	- CONTEÚDO DO PARAMETRO
*************************************************
	IF VARTYPE(tcPARAMETRO) <> 'C'
		RETURN(.F.)
	ENDIF
	IF VARTYPE(tcCONTEUDO) <> 'C'
		RETURN(.F.)
	ENDIF

	LOCAL		lcCOMANDO,lcACAO AS String
	STORE '' TO lcCOMANDO,lcACAO
	
	tcPARAMETRO = ALLTRIM(tcPARAMETRO)
	tcCONTEUDO	= ALLTRIM(tcCONTEUDO)

	* BUSCANDO REGISTRO PARA TRATAMENTO
	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		SELECT
			*
		FROM
			TS_MODULOS
		WHERE
			DS_ROTINA = [[DS_ROTINA]]
	ENDTEXT
	lcCOMANDO = STRTRAN(lcCOMANDO,'[[DS_ROTINA]]',XX(tcPARAMETRO))
	=PESQUISASQL(lcCOMANDO,'TMPGRUPOS')

	SELE TMPGRUPOS
	IF RECCOUNT() <= 0
		APPEND BLANK
		SCATTER NAME loREG MEMO
		
		loREG.NR_TIPO		= 2
		loREG.NR_POSICAO	= 100
		loREG.DS_ROTINA		= tcPARAMETRO
		loREG.DS_TITULO		= tcPARAMETRO
		loREG.DS_TIPTITULO	= tcPARAMETRO
		loREG.DS_NOMEDOPAI	= IIF(EMPTY(STREXTRACT(tcPARAMETRO,'','_')),STREXTRACT(tcPARAMETRO,'','.'),STREXTRACT(tcPARAMETRO,'','_'))
		lcACAO				= 'A'
	ELSE
		* SO ATUALIZA SE O CONTEÚDO(GRUPOS) FOI ALTERADO
		IF tcCONTEUDO == ALLTRIM(TMPGRUPOS.DS_DIREITOS)
			USE IN TMPGRUPOS
			RETURN(.F.) && ou .T. ??
		ENDIF
		
		SCATTER NAME loREG MEMO
		lcACAO = 'M'
	ENDIF
	
	DO CASE
		CASE goCONEXAO.TAMANHOGRUPO = 1
			IF OCCURS(',',tcCONTEUDO) <> 0
				USE IN TMPGRUPOS
				RETURN(.F.)
			ENDIF
		
		CASE goCONEXAO.TAMANHOGRUPO = 3
			IF MOD(LEN(STRTRAN(tcCONTEUDO,',','')),3) <> 0
				USE IN TMPGRUPOS
				RETURN(.F.)
			ENDIF

			IF LEFT(tcCONTEUDO,1) = ','
				tcCONTEUDO = SUBSTR(tcCONTEUDO,2)
			ENDIF
	ENDCASE
	
	loREG.DS_DIREITOS = tcCONTEUDO
	
	GATHER NAME loREG MEMO
	
	=ATUSQL(lcACAO,'TS_MODULOS')
	
	USE IN TMPGRUPOS
RETURN(.T.)

PROC VEERROTRATADO_RAIZ
LPARAMETERS taERRO
******************
* FUNÇÃO CRIADA NO MENURAIZ APENAS PARA NÃO "DAR ERRO" QUANDO GERAR O NOVO EXE
* MOTIVO : FUNÇÃO DEVE FICAR NO SYS_FUNCOES
	RETURN(EVALUATE('VEERROTRATADO(@taERRO)'))
ENDPROC

PROC OSINFO
***********
	LOCAL lnOS AS Integer
	LOCAL lcRETORNO, lcNOME AS String
	
	TEXT TO lcRETORNO NOSHOW PRETEXT 7
		<nome>[NOME]</nome>
		<numero>[NUMERO]</numero>
	ENDTEXT
	
	* VERIFICANDO VERSÃO DO SISTEMA OPERACIONAL
	lnOS = ( Val(Os(3)) * 1000000 + Val(Os(4)) * 10000 + Val(Os(8)) * 100 + Val(Os(9)) )

	DO CASE
		CASE lnOS = 4000000
			lcNOME = 'WINDOWS 95'
		CASE lnOS = 4100000
			lcNOME = 'WINDOWS 98'
		CASE lnOS = 5000000
			lcNOME = 'WINDOWS 2K'
		CASE lnOS = 5000100
			lcNOME = 'WIN2DOWS 2K SP1'
		CASE lnOS = 5000200
			lcNOME = 'WINDOWS 2K SP2'
		CASE lnOS = 5000300
			lcNOME = 'WINDOWS 2K SP3'
		CASE lnOS = 5000400
			lcNOME = 'WINDOWS 2K SP4'
		CASE lnOS = 5010000
			lcNOME = 'WINDOWS XP'
		CASE lnOS = 5010100
			lcNOME = 'WINDOWS XP SP1'
		CASE lnOS = 5010200
			lcNOME = 'WINDOWS XP SP2'
		CASE lnOS = 5010300
			lcNOME = 'WINDOWS XP SP3'
		CASE lnOS = 5020000
			lcNOME = 'WINDOWS SERVER 2003'
		CASE lnOS = 5020100
			lcNOME = 'WINDOWS SERVER 2003 SP1'
		CASE lnOS = 5020200
			lcNOME = 'WINDOWS SERVER 2003 SP2'
		CASE lnOS = 6000000
			lcNOME = 'WINDOWS VISTA'
		CASE lnOS = 6000100
			lcNOME = 'WINDOWS VISTA SP1'
		CASE lnOS = 6000200
			lcNOME = 'WINDOWS VISTA SP2'
		CASE lnOS = 6010000
			lcNOME = 'WINDOWS 7'
		CASE lnOS = 6010100
			lcNOME = 'WINDOWS 7 SP1'
		CASE lnOS = 6020000
			lcNOME = 'WINDOWS 8'
		OTHERWISE
			lnOS		= -1
			lcNOME	= 'NÃO ENCONTRADO'
	ENDCASE
	
	lcRETORNO = STRTRAN(lcRETORNO, '[NOME]'		, ALLTRIM(lcNOME) )
	lcRETORNO = STRTRAN(lcRETORNO, '[NUMERO]'	, ALLTRIM(TRANSFORM(lnOS)) )
	
	RETURN(lcRETORNO)
ENDPROC

FUNC VECOMPLEXIDADE
*************************
*VERIFICA SE A SENHA DO USUÁRIO ESTÁ DENTRO DOS CRITÉRIOS ESTABELECIDOS NOS PARÂMETROS
*************************
LPARAMETERS tcSENHA
*tcSENHA = SENHA DIGITADA NA TELA DE LOGIN

	IF VARTYPE(tcSENHA) <> 'C'
		RETURN(.F.)
	ENDIF
	
	LOCAL lnTAMSENHA, lnTAMALF, lnTAMESP, lnTAMNUM, lnERRO, lnQTALF, lnQTNUM, lnQTESP AS Integer 
	STORE 0 TO lnTAMSENHA, lnTAMALF, lnTAMESP, lnTAMNUM, lnERRO, lnQTALF, lnQTNUM, lnQTESP
	LOCAL llRETURN AS Boolean
	LOCAL lcPALAVRASPROIBIDAS AS String 
	STORE '' TO lcPALAVRASPROIBIDAS
	llRETURN = .F.

	lnTAMSENHA 			= RETORNASET('SENHA.TAMANHOMINIMO','N',1)
	lnTAMALF			= RETORNASET('SENHA.CARACALF','N',1)
	lnTAMESP			= RETORNASET('SENHA.CARACESP','N',1)
	lnTAMNUM			= RETORNASET('SENHA.CARACNUM','N',1)
	lcPALAVRASPROIBIDAS = RETORNASET('SENHA.PALAVRASPROIBIDAS', 'C', 0)
	* REGRAS SÓ SÃO VALIDADAS SE HOUVER UM TAMANHO MINIMO ESTABELECIDO
	IF NOT EMPTY(lnTAMSENHA)
		* SEPARA QUANTIDADE DE CARACTERES / NÚMERICOS / ESPECIAIS
		lnQTALF = LEN(TIRANOALF(tcSENHA)) - LEN(TIRANONUM(tcSENHA))
		lnQTNUM = LEN(TIRANONUM(tcSENHA))
		lnQTESP = LEN(tcSENHA) - LEN(TIRANOALF(tcSENHA))

		IF lnTAMSENHA > 0 AND LEN(tcSENHA) < lnTAMSENHA
			lnERRO = lnERRO + 1
		ENDIF

		IF lnTAMALF > 0 AND lnQTALF < lnTAMALF
			lnERRO = lnERRO + 1
		ENDIF

		IF lnTAMESP > 0 AND lnQTESP < lnTAMESP
			lnERRO = lnERRO + 1
		ENDIF

		IF lnTAMNUM > 0 AND lnQTNUM < lnTAMNUM
			lnERRO = lnERRO + 1
		ENDIF

		* VALIDAR PALAVRAS PROÍBIDAS
		IF NOT EMPTY(lcPALAVRASPROIBIDAS)
			LOCAL lnQTPALAVRAS AS Integer 
			STORE 0 TO lnQTPALAVRAS 
			
			lcPALAVRASPROIBIDAS= ',' + STRTRAN(ALLTRIM(lcPALAVRASPROIBIDAS), CHR(10), '') + ','
			lcPALAVRASPROIBIDAS= STRTRAN(ALLTRIM(lcPALAVRASPROIBIDAS), CHR(13), '')

			lnQTPALAVRAS = OCCURS(',', ALLTRIM(lcPALAVRASPROIBIDAS))
			
			FOR lnXI = 1 TO lnQTPALAVRAS 
				IF NOT EMPTY(STREXTRACT(lcPALAVRASPROIBIDAS,',', ',',lnXI))
					IF ALLTRIM(UPPER(STREXTRACT(lcPALAVRASPROIBIDAS,',', ',',lnXI))) $ ALLTRIM(UPPER(ALLTRIM(tcSENHA)))
						lnERRO = lnERRO + 1
					ENDIF 
				ENDIF
			ENDFOR
		ENDIF 
	ENDIF	
	
	IF lnERRO > 0
		llRETURN = .F.
	ELSE 
		llRETURN = .T.
	ENDIF

	RETURN(llRETURN)

ENDFUNC

PROC STRINGSEMLIXO
******************
LPARAMETERS tcIN
	LOCAL lcOUT,lcSTRINGVALIDA AS String
	LOCAL lnXI as Integer
	
	STORE '' TO lcOUT,lcSTRINGVALIDA
	STORE 0 to lnXI
	
	IF TYPE('tcIN') <> 'C'
		RETURN tcIN
	ENDIF
	IF EMPTY(tcIN)
		RETURN tcIN
	ENDIF 
	lcSTRINGVALIDA = "	 !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþ" + CHR(34) + CHR(13) + CHR(10)
	
	* VERIFICANDO CHAR A CHAR
	FOR lnXI = 1 TO LEN( tcIN )
		IF SUBSTR(tcIN,lnXI,1) $ lcSTRINGVALIDA
			lcOUT	= lcOUT + SUBSTR(tcIN,lnXI,1)
		ENDIF
	ENDFOR
	
	RETURN lcOUT
ENDPROC

PROC COPIARDADO
***************
	LOCAL loOBJETO AS Object

	loOBJETO = SYS(1270)

	IF VARTYPE(loOBJETO) <> 'O'
		_CLIPTEXT = ''
		RETURN(.F.)
	ENDIF

	IF 'CNDT' $ TYPE('loOBJETO.VALUE')
		_CLIPTEXT = ''
		RETURN(.F.)
	ENDIF
	
	IF TYPE('loOBJETO.PasswordChar') = 'C' AND NOT EMPTY(loOBJETO.PasswordChar)
		_CLIPTEXT = ''
		RETURN(.F.)
	ENDIF 
	
	IF TYPE('loOBJETO.Visible') = 'L' AND NOT loOBJETO.Visible
		_CLIPTEXT = ''
		RETURN(.F.)
	ENDIF	
	
	TRY 
		_CLIPTEXT = ALLTRIM(TRANSFORM(loOBJETO.VALUE))
	CATCH
	ENDTRY
	
ENDPROC

PROC GERENCIAR_FAVORITOS
************************
	LPARAMETERS tcOBJETO AS String,tcPARAM AS Object, tcOPCAO AS String

	LOCAL lcCOMANDO, lcSCRIPT_DEL, lcTITULO_MOD AS String
	STORE '' TO lcCOMANDO, lcSCRIPT_DEL, lcTITULO_MOD
		
	IF EMPTY(tcOPCAO)
		RETURN
	ENDIF
	
	IF EMPTY(tcOBJETO)
		RETURN
	ENDIF
			
	IF TYPE('tcOPCAO') <> 'C'
		RETURN
	ENDIF
	
	IF TYPE('tcOBJETO') <> 'C'
		RETURN
	ENDIF

	IF TYPE('tcPARAM') <> 'O'
		RETURN
	ENDIF
	
	lcTITULO_MOD = ALLTRIM(tcPARAM.myTITULO)
	
	DO CASE
	
		* ADICIONAR NOVO FAVORITO
		CASE tcOPCAO == 'ADD'
	
			* CONSULTAR TELAS
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT
					MOD.PK_ID,
					MOD.DS_ROTINA,
					CASE
						WHEN FAV.FK_ROTINA IS NOT NULL THEN 'S'
						WHEN FAV.FK_ROTINA IS NULL THEN 'N'
					END AS TG_SALVOFAV
				FROM TS_MODULOS MOD
				LEFT JOIN TS_FAVORITOS FAV ON FAV.FK_ROTINA = MOD.PK_ID
				AND FAV.FK_USUARIO = [FK_USUARIO]
				WHERE MOD.DS_ROTINA LIKE [DS_ROTINA]
			ENDTEXT
			lcCOMANDO	= STRTRAN( lcCOMANDO, '[DS_ROTINA]', XX(JUSTSTEM(tcOBJETO),"LIKE%") )
			lcCOMANDO	= STRTRAN( lcCOMANDO, '[FK_USUARIO]', XX(goCONEXAO.FK_USUARIO) )
			=PESQUISASQL(lcCOMANDO,'TMPSYSMODULOS')
					
			SELE TMPSYSMODULOS
			GO TOP
			
			* VERIFICAR SE FUNCIONALIDADE JÁ ESTÁ CADASTRADA NOS FAVORITOS DO USUARIO
			IF TMPSYSMODULOS.TG_SALVOFAV == 'S'
				DO MENS WITH 'O módulo já existe em seus favoritos.'
				RETURN
			ENDIF
			
			* ESTRUTURA TABELA DE MOD. FAVORITOS
			TEXT TO lcCOMANDO NOSHOW PRETEXT 7
				SELECT * FROM TS_FAVORITOS WHERE 1=2
			ENDTEXT
			=PESQUISASQL(lcCOMANDO,'TMPFAVORITOS')
			
			SELE TMPFAVORITOS
			GO TOP
			APPEND BLANK
			REPLACE TMPFAVORITOS.FK_USUARIO 	WITH goCONEXAO.FK_USUARIO	,;
					TMPFAVORITOS.FK_ROTINA 		WITH TMPSYSMODULOS.PK_ID	,;
					TMPFAVORITOS.DS_ROTINA 		WITH ALLTRIM(TMPSYSMODULOS.DS_ROTINA)
			
			* ADICIONAR NOVO FAVORITO
			SELE TMPFAVORITOS
			GO TOP
			DO ATUSQL WITH 'A','TS_FAVORITOS'
			
			IF SIMOUNAO('Rotina (' + UPPER(lcTITULO_MOD) + ') adicionado aos seus favoritos, deseja recarregar desktop?','Recarregar desktop',1)
				KEYBOARD '{CTRL+E}' 
			ENDIF
			
			USE IN TMPSYSMODULOS
			USE IN TMPFAVORITOS
	
		* REMOVER FAVORITO	
		CASE tcOPCAO == 'DEL'
			
			TEXT TO lcSCRIPT_DEL NOSHOW PRETEXT 7
				DELETE FROM TS_FAVORITOS WHERE FK_USUARIO = [FK_USUARIO] AND DS_ROTINA LIKE [DS_ROTINA]
			ENDTEXT
			lcSCRIPT_DEL	= STRTRAN( lcSCRIPT_DEL, '[FK_USUARIO]', XX(goCONEXAO.FK_USUARIO) )
			lcSCRIPT_DEL	= STRTRAN( lcSCRIPT_DEL, '[DS_ROTINA]', XX(JUSTSTEM(tcOBJETO),'LIKE%') )
			
			IF NOT SIMOUNAO('Confirma a remoção da rotina (' + UPPER(lcTITULO_MOD) + ') dos seus favoritos ?','Remover favorito',1)
				RETURN
			ENDIF
			
			=EXECUTASQL(lcSCRIPT_DEL)
			
			IF SIMOUNAO('Rotina (' + UPPER(lcTITULO_MOD) + ') removido dos seus favoritos, deseja recarregar desktop?','Recarregar desktop',1)
				KEYBOARD '{CTRL+E}'
			ENDIF
	ENDCASE
	
ENDPROC

FUNC FAVORITOS_GUIACOLUNA
*************************
	* VERIFICAR COLUNA DO ICONE DA GUIA DE FAVORITOS
	
	LPARAMETERS tnQT_ICONES AS Integer
	
	LOCAL lcRETORNO AS String
	STORE '' TO lcRETORNO
	
	LOCAL lnVL_LETRA AS Integer
	STORE 0 TO lnVL_LETRA
	
	IF TYPE('tnQT_ICONES') <> 'N'
		RETURN('')
	ENDIF
	
	IF EMPTY(tnQT_ICONES)
		RETURN('')
	ENDIF
	
	lnVL_LETRA = tnQT_ICONES * 10
	
	DO CASE
		CASE lnVL_LETRA = 10
			lcRETORNO = 'A'
		CASE lnVL_LETRA = 20
			lcRETORNO = 'B'
		CASE lnVL_LETRA = 30
			lcRETORNO = 'C'
		CASE lnVL_LETRA = 40
			lcRETORNO = 'D'
		CASE lnVL_LETRA = 50
			lcRETORNO = 'E'
		CASE lnVL_LETRA = 60
			lcRETORNO = 'F'		
		CASE lnVL_LETRA = 70
			lcRETORNO = 'G'
		CASE lnVL_LETRA = 80
			lcRETORNO = 'H'
		CASE lnVL_LETRA = 90
			lcRETORNO = 'I'
		CASE lnVL_LETRA = 100
			lcRETORNO = 'J'
		CASE lnVL_LETRA = 110
			lcRETORNO = 'L'
		CASE lnVL_LETRA = 120
			lcRETORNO = 'M'		
		CASE lnVL_LETRA = 130
			lcRETORNO = 'N'
		CASE lnVL_LETRA = 140
			lcRETORNO = 'O'
		CASE lnVL_LETRA = 150
			lcRETORNO = 'P'
		CASE lnVL_LETRA = 160
			lcRETORNO = 'Q'
		CASE lnVL_LETRA = 170
			lcRETORNO = 'R'
		CASE lnVL_LETRA = 180
			lcRETORNO = 'S'
		CASE lnVL_LETRA = 190
			lcRETORNO = 'T'
		CASE lnVL_LETRA = 200
			lcRETORNO = 'U'
		CASE lnVL_LETRA = 210
			lcRETORNO = 'V'
		CASE lnVL_LETRA = 220
			lcRETORNO = 'X'
		CASE lnVL_LETRA = 230
			lcRETORNO = 'Z'
		CASE lnVL_LETRA = 240
			lcRETORNO = 'W'
		CASE lnVL_LETRA = 250
			lcRETORNO = 'Y'
	ENDCASE
	
	RETURN lcRETORNO
ENDFUNC

FUNC CAMPOEXISTE AS logical
***************************
    LPARAMETERS NOMECAMPO AS STRING, NOMECURSOR AS STRING
     
    RETURN !EMPTY(FIELD(M.NOMECAMPO, M.NOMECURSOR)) 
ENDFUNC

FUNC VALIDAREGULAR
	PARAMETERS tcEXPRESSAO, tcENTRADA, tlCASESENSITIVE
	*** POR: EWERTON CARREIRA EM: 15/01/2016 ********************************************
	* PARAMETROS 																		*
	* tcEXPRESSAO = EXPRESSÃO REGULAR PARA VALIDAÇÃO									*
	* tcENTRADA = CONTEÚDO A SER VALIDADO												*
	* tlCASESENSITIVE = (.T./.F.) RECEBE SE É PARA CONSIDERAR O CASE SENSITIVE			*
	*************************************************************************************
	
	IF TYPE('tcEXPRESSAO') <> 'C'
		tcEXPRESSAO = ''
	ENDIF
	
	IF EMPTY(tcEXPRESSAO)
		RETURN(.F.)
	ENDIF

	IF TYPE('tcENTRADA') <> 'C'
		tcENTRADA = ''
	ENDIF
	
	tcENTRADA = ALLTRIM(tcENTRADA)
		
	IF EMPTY(tcENTRADA)
		RETURN(.F.)
	ENDIF
	
	* DEFAULT NÃO VALIDAR CASE SENSITIVE
	IF TYPE('tlCASESENSITIVE') <> 'L'
		tlCASESENSITIVE = .F.
	ENDIF

	LOCAL loREGEX AS Object
	TRY 
		loREGEX = NEWOBJECT('VBScript.RegExp')
	CATCH
		DO MENS WITH 'Impossível criar objeto de validação (VBSCript.RegExp).'+CHR(13)+'Entre em contato com o suporte técnico.'
		RETURN(.F.)
	FINALLY
	ENDTRY
	
	loREGEX.Pattern = tcEXPRESSAO
	loREGEX.IgnoreCase = NOT tlCASESENSITIVE
	
	LOCAL llRETORNO AS Boolean
	llRETORNO = loREGEX.Test(tcENTRADA)
	
	loREGEX = NULL
	RETURN(llRETORNO)
ENDFUNC

FUNC VALIDAEMAIL
	PARAMETERS tcEMAIL
	*** POR: EWERTON CARREIRA EM: 15/01/2016 ********************************************
	* PARAMETROS 																		*
	* tcEMAIL = EMAILS A SEREM VALIDADOS SEPARADOS POR ';'								*
	*************************************************************************************
	IF TYPE('tcEMAIL') <> 'C'
		tcEMAIL = ''
	ENDIF
	
	* EXPRESSÃO REGULAR PADRÃO PARA TESTE DE E-MAIL
	LOCAL lcPATTERNMAIL AS String 
	lcPATTERNMAIL = '^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})$'
	
	* VALIDAÇÃO
	LOCAL llRETORNO AS Boolean
	STORE .T. TO llRETORNO
	
	* FORÇANDO ; NO FINAL
	IF RIGHT(tcEMAIL,1) <> ';'
		tcEMAIL = tcEMAIL + ';'
	ENDIF

	* VÁRIOS EMAILS SEPARADOS POR ';'
	FOR lnXI = 1 TO OCCURS(';',tcEMAIL)
		llRETORNO = VALIDAREGULAR(lcPATTERNMAIL,ALLTRIM(STREXTRACT(';'+tcEMAIL,';',';',lnXI)),.F.)
		* SE ENCONTRAR ALGUM EMAIL INVÁLIDO NEM VALIDA O RESTANTE
		IF NOT llRETORNO 
			EXIT
		ENDIF
	ENDFOR
	
	RETURN(llRETORNO)
ENDFUNC

PROC LAC_ATIVACAOVOLPE
LPARAMETERS tnFORCARATIVACAOCOMPLETA AS Integer
	IF VARTYPE(tnFORCARATIVACAOCOMPLETA)<>'N'
		tnFORCARATIVACAOCOMPLETA = 0
	ENDIF
		
	*PARAMETRO PARA DESATIVAÇAO DA ATIVAÇÃO AUTOMATICA	
	lnDESATIVARATIVACAO = RETORNASET('VOLPELAC.DESATIVARATIVACAO','N',0)
	IF lnDESATIVARATIVACAO = 1 AND NVL(tnFORCARATIVACAOCOMPLETA,0) = 0
		RETURN .F.
	ENDIF
	IF goAPLICATIVO.TESTE AND NVL(tnFORCARATIVACAOCOMPLETA,0) = 0
		RETURN .F.
	ENDIF
	PRIVATE lnLAC_ALCACONEXAO,lnFK_SOFTWAREINSTALADOATIVACAO,lnDIFSECONDSSERVERLAC AS Integer
	LOCAL ldDATAPROXIMAATIVACAO AS Datetime
	LOCAL lcDS_DOMINIO AS STRING
	LOCAL ldDATAATUAL AS Datetime
	STORE 0 TO lnLAC_ALCACONEXAO,lnFK_SOFTWAREINSTALADOATIVACAO,lnDIFSECONDSSERVERLAC
	STORE '' TO lcDS_DOMINIO
	STORE TTOD(DATASERVER()) TO ldDATAATUAL
	
	IF (INLIST(NVL(ldDATAATUAL,CTOD('')),CTOD(''),CTOT('')) OR (NOT INLIST(TYPE('ldDATAATUAL'),'D','T')))
		ldDATAATUAL = DATE()
	ENDIF
	
	*VERIFICA SE EXISTE ZW DE DATA DA PROXIMA ATIVAÇÃO
	=PESQUISASQL("SELECT * FROM TS_PARAMETROS WHERE DS_PARAMETRO = 'VOLPELAC.DATAPROXIMAATIVACAO'",'TMPZWDT')
	IF RECCOUNT('TMPZWDT')=0
		*SE NÃO EXISTIR CRIA O PARAMETRO DE CONTROLE NO VOLPE
		SELE TMPZWDT
		SCATTER NAME loREG MEMO
			loREG.PK_ID			= 0
			loREG.DS_PARAMETRO	= 'VOLPELAC.DATAPROXIMAATIVACAO'
			loREG.DS_ASSUNTO	= 'VOLPE LAC'
			loREG.DS_DESCRICAO	= 'DATA DA PROXIMA ATIVACAO NO VOLPE LAC'
			loREG.TG_INICIO		= 1
			loREG.TG_DATATYPE	= 'C'
		APPEND BLANK
		GATHER NAME loREG MEMO
		DO ATUSQL WITH 'A','TS_PARAMETROS'
		*FORÇA A PRIMEIRA ATIVAÇÃO
		ldDATAPROXIMAATIVACAO = ldDATAATUAL
	ELSE
		ldDATAPROXIMAATIVACAO = CTOD(ALLTRIM(TMPZWDT.DS_CONTEUDO))
		IF NVL(ldDATAPROXIMAATIVACAO,CTOD(''))=CTOD('')
			*SE ESTIVER NULO OU COM CONTEUDO INVALIDO, FORÇA A ATIVAÇÃO
			ldDATAPROXIMAATIVACAO = ldDATAATUAL 
		ENDIF
	ENDIF
	*VERIFICA SE DEVE FAZER A ATIVAÇÃO
	IF ldDATAATUAL < ldDATAPROXIMAATIVACAO AND NVL(tnFORCARATIVACAOCOMPLETA,0) = 0
		*SE AINDA NÃO TIVER CHEGADO NA DATA, SAI SEM CONECTAR AO LAC
		RETURN .F.
	ENDIF
	DO ESPERANDO WITH 	'Efetuando a ativação do Volpe...'+CHR(13)+CHR(10)+;
						'Esse processo pode demorar alguns instantes, por favor aguarde e não encerre o sistema.'
	************************************
	*CONECTANDO AO BANCO DE DADOS DO LAC
	************************************
	TEXT TO lcSTRINGCONEXAOLAC NOSHOW PRETEXT 7
		DRIVER={SQL SERVER};
		SERVER=cloud08.pwi.com.br,2127;
		UID=userLAC_ATIVACAO;
		PWD=#Act!v@TI0n1403#l9a1c3!;
		DATABASE=volpelac
	ENDTEXT
	lnLAC_ALCACONEXAO = SQLSTRINGCONNECT(lcSTRINGCONEXAOLAC)
	IF lnLAC_ALCACONEXAO < 0
		*EM CASO DE PROBLEMA NA CONEXÃO
		*GRAVA LOG
		DO GRAVALOG WITH 'O',0,'',LEFT('Ocorreu um problema de comunicação com o sistema de ativação do Volpe(LAC).'+CHR(13)+CHR(10)+'Motivo:'+ALLTRIM(MESSAGE()),70),'ATIVAÇÃO VOLPE(LAC)'
		*PROGRAMA A PROXIMA TENTATIVA PARA 30 DIAS
		=SALVARSET('VOLPELAC.DATAPROXIMAATIVACAO',DTOC(ldDATAATUAL +30))
		WAIT CLEAR
		RETURN .F.
	ENDIF
	*FAZ A SELECT DE INFORMAÇÕES BASICAS PARA ATIVAÇÃO DO VOLPE
	TEXT TO lcSQL NOSHOW PRETEXT 7
		SELECT
			CAST( SERVERPROPERTY( 'Edition' ) AS varchar( 30 ) ) AS DS_EDITION,
			CAST(SERVERPROPERTY ('ServerName') AS VARCHAR(50)) AS DS_SERVIDOR,
			DB_NAME() AS DS_DBNAME,
			CAST(@@VERSION AS CHAR(26)) AS DS_VERSION,
			DB_ID() AS NR_BANCOID
	ENDTEXT
	lnRETORNO=SQLEXEC(goCONEXAO.ALCA,lcSQL,'TMPINFOBASI')
	IF lnRETORNO <= 0
		*EM CASO DE PROBLEMA NA SELECT
		*GRAVA LOG
		DO GRAVALOG WITH 'O',0,'',LEFT('Ocorreu um problema para consultar informações básicas para ativação do Volpe(LAC).'+CHR(13)+CHR(10)+'Motivo:'+ALLTRIM(MESSAGE()),70),'ATIVAÇÃO VOLPE(LAC)'
		*PROGRAMA A PROXIMA TENTATIVA PARA 30 DIAS
		=SALVARSET('VOLPELAC.DATAPROXIMAATIVACAO',DTOC(ldDATAATUAL +30))
		WAIT CLEAR
		RETURN .F.
	ENDIF
	*DOMINIO
	TRY
		loWSSHELL = CREATEOBJECT("WScript.Network")
		lcDS_DOMINIO = loWSSHELL.UserDomain
		loWSSHELL = NULL
	CATCH
		lcDS_DOMINIO = ''
	ENDTRY	
	*EXECUTANDO PROCEDURE DE ATIVAÇÃO DO BANCO DE DADOS
	TEXT TO lcSQL NOSHOW PRETEXT 7
		EXEC SPU_VOLPELAC_ATIVACAO [[NR_SERIE]],[[DS_SERVIDOR]],[[DS_SERVIDORID]],[[DS_DATABASE]],[[DS_MAQUINAUSUARIO]],[[DS_DOMINIOUSUARIO]]
	ENDTEXT
	lcSQL = STRTRAN(lcSQL,'[[NR_SERIE]]',XX(ALLTRIM(goAPLICATIVO.CD_KEY)))
	lcSQL = STRTRAN(lcSQL,'[[DS_SERVIDOR]]',XX(TMPINFOBASI.DS_SERVIDOR))
	lcSQL = STRTRAN(lcSQL,'[[DS_SERVIDORID]]',XX(''))
	lcSQL = STRTRAN(lcSQL,'[[DS_DATABASE]]',XX(TMPINFOBASI.DS_DBNAME))
	lcSQL = STRTRAN(lcSQL,'[[DS_MAQUINAUSUARIO]]',XX(ALLTRIM(SYS(0))))
	lcSQL = STRTRAN(lcSQL,'[[DS_DOMINIOUSUARIO]]',XX(lcDS_DOMINIO))
	lnRETORNO=SQLEXEC(lnLAC_ALCACONEXAO,lcSQL,'TMPATIVACAO')
	IF lnRETORNO <= 0 OR (NOT USED('TMPATIVACAO'))
		*EM CASO DE PROBLEMA NA CONEXÃO
		*GRAVA LOG
		DO GRAVALOG WITH 'O',0,'',LEFT('Ocorreu um problema na ativação do Volpe(LAC).'+CHR(13)+CHR(10)+'Motivo:'+ALLTRIM(MESSAGE()),70),'ATIVAÇÃO VOLPE(LAC)'
		*PROGRAMA A PROXIMA TENTATIVA PARA 7 DIAS(POIS CONSEGUIU CONECTAR POREM OCORREU UM ERRO NA PROCEDURE)
		=SALVARSET('VOLPELAC.DATAPROXIMAATIVACAO',DTOC(ldDATAATUAL +7))
		WAIT CLEAR
		RETURN .F.
	ENDIF
	SELE TMPATIVACAO
	GO TOP
	*PROGRAMANDO DATA DA PROXIMA ATIVAÇÃO AUTOMATICA DO VOLPE
	lnFK_SOFTWAREINSTALADOATIVACAO = NVL(TMPATIVACAO.FK_SOFTWAREINSTALADOATIVACAO,0)
	
	IF TYPE('TMPATIVACAO.NR_ATIVACAODIAS')='N'
		IF NVL(TMPATIVACAO.NR_ATIVACAODIAS,0)>0
			*PERIODO CONFIGURADO
			=SALVARSET('VOLPELAC.DATAPROXIMAATIVACAO',DTOC(ldDATAATUAL+NVL(TMPATIVACAO.NR_ATIVACAODIAS,0)))
		ELSE
			*PERIODO FIXO
			=SALVARSET('VOLPELAC.DATAPROXIMAATIVACAO',DTOC(ldDATAATUAL+60))		
		ENDIF
	ELSE
		*PERIODO FIXO
		=SALVARSET('VOLPELAC.DATAPROXIMAATIVACAO',DTOC(ldDATAATUAL+60))
	ENDIF
	***********************
	*RODANDO SCRIPTS PADRÃO
	***********************
	*CALCULANDO DIF. EM SEGUNDOS ENTRE OS SERVIDORES PARA CALCULO DE TEMPO DE EXECUÇÃO
	lnDIFSECONDSSERVERLAC = TMPATIVACAO.DH_DATASERVERATIVACAO - DATASERVER()
	IF TYPE('lnDIFSECONDSSERVERLAC')<>'N'
		lnDIFSECONDSSERVERLAC = 0
	ENDIF
	IF ISNULL(lnDIFSECONDSSERVERLAC)
		lnDIFSECONDSSERVERLAC = 0
	ENDIF
	
	TEXT TO lcSQL NOSHOW PRETEXT 7
		EXEC SPU_VOLPELAC_ATIVACAOSCRIPTCONSULTA [[FK_SOFTWAREINSTALADOATIVACAO]],[[FORCARATIVACAOCOMPLETA]]
	ENDTEXT
	lcSQL = STRTRAN(lcSQL,'[[FK_SOFTWAREINSTALADOATIVACAO]]',XX(lnFK_SOFTWAREINSTALADOATIVACAO))
	lcSQL = STRTRAN(lcSQL,'[[FORCARATIVACAOCOMPLETA]]',XX(tnFORCARATIVACAOCOMPLETA ))
	lnRETORNO=SQLEXEC(lnLAC_ALCACONEXAO,lcSQL,'TMPATIVACAOSCRIPT')
	IF lnRETORNO <= 0 OR (NOT USED('TMPATIVACAOSCRIPT'))
		*EM CASO DE PROBLEMA NA CONEXÃO
		*GRAVA LOG
		DO GRAVALOG WITH 'O',0,'',LEFT('Ocorreu um problema para retornar os scripts do Volpe(LAC).'+CHR(13)+CHR(10)+'Motivo:'+ALLTRIM(MESSAGE()),70),'ATIVAÇÃO VOLPE(LAC)'
	ELSE
		IF USED('TMPATIVACAOSCRIPT')
			SELE TMPATIVACAOSCRIPT
			GO TOP
			SCAN WHILE NOT EOF('TMPATIVACAOSCRIPT')
				TRY
					lcMACRO = STRCONV(TMPATIVACAOSCRIPT.DS_SCRIPT,14)
					EXECSCRIPT(lcMACRO)
				CATCH
					llERRO = .T.
				ENDTRY
			ENDSCAN
		ENDIF
	ENDIF
	*FECHANDO CONEXÃO
	TRY
		=SQLDISCONNECT(lnLAC_ALCACONEXAO)
	CATCH
	ENDTRY
	IF USED('TMPATIVACAO')
		USE IN TMPATIVACAO
	ENDIF
	WAIT CLEAR
	RETURN .T.
ENDPROC

FUNC ALTERARGB
	**********************************************************************************************************************************
	* FUNÇÃO QUE MANIPULA UMA COR INICIAL PARA RETORNAR UMA VARIAÇÃO DA MESMA 
	* EM UM TOM MAIS CLARO OU ESCURO 
	*
	* PARAMETROS.: COR.........: NÚMERO ABSOLUTO, APÓS CÁLCULADO RGB
	*			   INCREMENTO..: NUMERO ABSOLUTO A SER INCREMENTADO NA TONALIDADE (CASO POSITIVO) OU DECREMENTADO (CASO NEGATIVO)
	*
	* RETORNO....: NÚMERO DA COR OU ZERO CASO HAJA ALGUM ERRO 
	**********************************************************************************************************************************
	LPARAMETERS tnCOR, tnINCREMENTO

	* VALIDA PARAMETROS 
	IF TYPE('tnCOR') <> 'N'
		RETURN(0)
	ENDIF   
	IF EMPTY(tnCOR)
		RETURN(0)
	ENDIF 

	* CASO NÃO HAJA INCREMENTO RETORNA COR ORIGINAL 
	IF TYPE('tnINCREMENTO') <> 'N'
		RETURN(tnCOR)
	ENDIF   
	IF EMPTY(tnCOR)
		RETURN(tnCOR)
	ENDIF 

	* DEFINE 
	LOCAL lnRED, lnGREEN, lnBLUE, lnVALORMAX  AS Integer
	LOCAL lcOPERADOR, lcVALORES, lcVALOR, lcCONDICAO, lcAUX 

	* VALOR DEFAULT 
	STORE 0 TO lnRED, lnGREEN, lnBLUE, lnVALORMAX 
	STORE '' TO lcOPERADOR, lcVALORES, lcVALOR, lcCONDICAO, lcAUX

	* DESCOBRE TAXAS ISOLADAS DE VERMELHO/VERDE/AZUL 
	lnBLUE 	= INT(tnCOR		/ (256^2))
	lnGREEN = INT((tnCOR	- lnBLUE*256^2) / 256)
	lnRED 	= INT(tnCOR		- (lnBLUE*256^2 + lnGREEN * 256))

	* FAZ MANIPULAÇÃO NAS CORES
	IF tnINCREMENTO > 0
		lnBLUE 	= lnBLUE 	+ MIN(tnINCREMENTO,(255-lnBLUE))
		lnGREEN = lnGREEN 	+ MIN(tnINCREMENTO,(255-lnGREEN))
		lnRED	= lnRED 	+ MIN(tnINCREMENTO,(255-lnRED))
	ELSE
		IF lnBLUE + tnINCREMENTO < 0
			lnBLUE = 0
		ELSE
			lnBLUE = lnBLUE + tnINCREMENTO 
		ENDIF
		IF lnGREEN + tnINCREMENTO < 0
			lnGREEN = 0
		ELSE
			lnGREEN = lnGREEN + tnINCREMENTO 
		ENDIF
		IF lnRED + tnINCREMENTO < 0
			lnRED = 0
		ELSE
			lnRED = lnRED + tnINCREMENTO
		ENDIF
	ENDIF

	* VERIFICA SE HAVERÁ INCREMENTO OU DECREMENTO 
	IF tnINCREMENTO < 0	
		lnVALORMAX = 0
		lcOPERADOR = '<'
	ELSE
		lnVALORMAX = 255
		lcOPERADOR = '>'
	ENDIF 

	* VERIFICA SE HOUVE TAXA FORA DO RANGE (0-255)
	lcVALORES = ',lnRED,lnGREEN,lnBLUE,'
	FOR lnX = 1 TO OCCURS(',',lcVALORES) - 1
		lcVALOR = STREXTRACT(lcVALORES,',',',',lnX)
		
		lcCONDICAO = lcVALOR + lcOPERADOR + TRANSFORM(lnVALORMAX)
		IF &lcCONDICAO
			lcAUX = lcVALOR + '=' + TRANSFORM(lnVALORMAX)
			&lcAUX
		ENDIF 
	ENDFOR

	* RETORNA COR
	RETURN(RGB(lnRED,lnGREEN,lnBLUE))

ENDFUNC 

FUNC CONFIGFRMFLAT
	*********************************************************************
	* ROTINA RESPONSÁVEL POR ALTERAR LAYOUT DOS FORMS PARA O PADRÃO FLAT 
	* 
	* PARAMETROS : FORMULÁRIO
	*********************************************************************
	LPARAMETERS toOBJETO

	* VALIDA PARÂMETROS 
	IF TYPE('toOBJETO') <> 'O'
		RETURN(.F.)
	ENDIF 

	* VERIFICA SE LAYOUT FLAT ESTÁ ATIVO 
	IF goAPLICATIVO.FLAT = 0  
		RETURN(.T.)	
	ENDIF 	

	* DEFINE 
	LOCAL lcCLASSE, lcCORPAGINA, lcNOMEOBJETO, lcANCHOR, lcOBJETO, lcCLASSEBASE, lcPATH AS String 
	LOCAL lnCORIDENTIDADE, lnLARGURABORDA, lnLEFT, lnTOP, lnFORMHEIGHT, lnFORMWIDTH, lcCLASSEBASE, lnESPACAMENTO, lnLEFTFUNDO, lnTOPFUNDO AS Integer

	* VALOR DEFAULT 
	STORE '' TO lcCLASSE , lcCORPAGINA, lcNOMEOBJETO, lcANCHOR, lcOBJETO, lcCLASSEBASE, lcPATH
	STORE 0 TO lnCORIDENTIDADE, lnLARGURABORDA, lnFORMHEIGHT, lnFORMWIDTH, lnESPACAMENTO, lnLEFTFUNDO, lnTOPFUNDO

	* OBTEM CLASSE DO OBJETO 
	lcCLASSE 	= ALLTRIM(UPPER(toOBJETO.Class))

	* ARMAZENA LARGURA E ALTURA ORIGINAL DO FORM 
	lnFORMHEIGHT = toOBJETO.Height
	lnFORMWIDTH	 = toOBJETO.Width

	lnCORIDENTIDADE = toOBJETO.BackColor 
	 
	* LARGURA DA BARRA DE TÍTULOS E ESPAÇAMENTO 
	lnLARGURABORDA  = 48  
	lnESPACAMENTO	= 10

	* SE BORDA NÃO É DIMENSIONÁVEL ATRIBUI BORDA FIXED DIALOG 
	IF toOBJETO.BorderStyle <> 3 
		toOBJETO.BorderStyle = 2 &&fixed dialog
	ENDIF 

	* >> REDIMENSIONAMENTO E PRÉ-DEFINIÇÕES
	* DIGITAR 
	IF lcCLASSE == 'FORMDIG'
		toOBJETO.Width				= toOBJETO.Width  + lnESPACAMENTO * 4
		toOBJETO.Height 			= toOBJETO.Height + lnLARGURABORDA + (lnESPACAMENTO * 2)
		
		* REDUZ TAMANHO ORIGINAL DO FORM PARA ÍCONES DO RODAPÉ (CLIPS) FICAREM VAZADOS NA COR DE IDENTIDADE 
		lnFORMHEIGHT 				= lnFORMHEIGHT -30
	ENDIF 
	* RELATÓRIO 
	IF lcCLASSE == 'FORMREL'
		toOBJETO.Width 				= toOBJETO.Width 	+ lnESPACAMENTO * 2
		toOBJETO.Height 			= toOBJETO.Height 	+ lnLARGURABORDA  + lnESPACAMENTO 
	ENDIF 
	* FORMDBF 
	IF INLIST(lcCLASSE,'FORMDBF')
		toOBJETO.Width 				= toOBJETO.Width 	+ lnESPACAMENTO * 4
		toOBJETO.Height 			= toOBJETO.Height 	+ lnLARGURABORDA  + lnESPACAMENTO
	ENDIF 
	* FORMGEN / COMBONN   
	IF INLIST(lcCLASSE,'FORMGEN','FORMCOMBONN')
		toOBJETO.Width 				= toOBJETO.Width 	+ lnESPACAMENTO * 4
		toOBJETO.Height 			= toOBJETO.Height 	+ lnLARGURABORDA + (lnESPACAMENTO * 2)
		lnFORMHEIGHT = lnFORMHEIGHT + 10
	ENDIF 

	* CONSULTAR 
	IF lcCLASSE == 'FORMSUPER'
		toOBJETO.Width 				= toOBJETO.Width  + lnLARGURABORDA + lnESPACAMENTO * 2  
		toOBJETO.Height 			= toOBJETO.Height + (lnLARGURABORDA - 23) + lnESPACAMENTO * 3
		
		* CONFIGURA OBJETOS DA CLASSE 
		WITH toOBJETO 
			.lbltotreg.Anchor 		= 0
			.lbltotreg.Autosize 	= .T. 
			.lbltotreg.Width 		= 120
			.lbltotreg.fontsize 	= 10
			.lbltotreg.forecolor 	= RGB(255,255,255)
			.lbltotreg.ALIGNMENT 	= 1
			.lbltotreg.LEFT 		= toOBJETO.Width - .lbltotreg.Width - 10 
			.lbltotreg.top 			= 30
			.lbltotreg.Anchor 		= 9
			.cmdsair.Top 			= - 200
			.shape2.Visible 		= .F.
			.shpdiv1.Visible 		= .F.
			.shape3.Visible 		= .F.
			.shape3.Visible 		= .F.
			.linSEPARA.Visible 		= .F.
		ENDWITH  
	ENDIF 

	* SCAN NOS OBJETOS DO FORM 
	FOR EACH loOBJETO IN toOBJETO.Objects 
		
		* OBJETOS COM PROPRIEDADE ANCHOR 
		IF TYPE('loOBJETO.Anchor') == 'N'
			* ARMAZENA E REMOVE ANCHOR DO OBJETO 
			lcANCHOR = loOBJETO.Anchor
			loOBJETO.Anchor = 0 
		ELSE 
			lcANCHOR = 0
		ENDIF 

		* NOME DO OBJETO 
		lcNOMEOBJETO = ALLTRIM(UPPER(loOBJETO.NAME))
		
		* FORM CONSULTAR 
		IF lcCLASSE == 'FORMSUPER'
			* REDESENHA TOOLBAR  
			IF INLIST(lcNOMEOBJETO,'CMDREFRESH','CMDFILTRAR','CMDLIMPARFILTRO','CMDPKFILTRAR','CMDINDEXAR','CMDIMPRIMIR','CMDCONTEXTO','CMDEXPORTAR')
				* ADICIONA IMAGEM DE FUNDO FLAT 
				lcOBJETO = 'img' +  ALLTRIM(lcNOMEOBJETO)
				IF TYPE('toOBJETO.' + lcOBJETO) <> 'O'
					lnLEFT 					= loOBJETO.Top 	+ 11
					lnTOP 					= loOBJETO.Left + 54
					loOBJETO.Top 			= lnTOP 
					loOBJETO.MousePointer	= 15 && MÃO 
					loOBJETO.Left 			= lnLEFT
					loOBJETO.Style 			= 1 && invisível
				
					lcOBJETO = 'img' +  ALLTRIM(lcNOMEOBJETO)
					toOBJETO.Addobject(lcOBJETO,'Image')
					lcOBJETO = 'toOBJETO.' + lcOBJETO 			
					WITH &lcOBJETO as image 
						.Visible 			= .T.
						.Left 				= lnLEFT 
						.MousePointer 		= 15 
						.Picture 			= POEIMG(lcNOMEOBJETO + '.PNG')
						.Stretch 			= 1
						.Top 				= lnTOP 
						.Width 				= 16
						.Height 			= 16
						.Zorder(1)
					ENDWITH 
				ENDIF 
			ELSE 
				IF NOT INLIST(lcNOMEOBJETO,'LBLTOTREG') AND NOT 'IMG' $ 'lcNOMEOBJETO'
					loOBJETO.Top 	= loOBJETO.Top 	+ 37 
					loOBJETO.Left 	= loOBJETO.Left + lnLARGURABORDA  
				ENDIF 
			ENDIF 
		ENDIF 
		
		* FORM DIGITAR 
		IF lcCLASSE == 'FORMDIG'
		 	loOBJETO.Top 	= loOBJETO.Top 		+ lnLARGURABORDA + lnESPACAMENTO 
			loOBJETO.Left 	= loOBJETO.Left 	+ lnESPACAMENTO * 2
		ENDIF  
		
		* FORMREL E DBF  
		IF INLIST(lcCLASSE,'FORMREL','FORMDBF') 
			loOBJETO.Top 	= loOBJETO.Top 		+ lnLARGURABORDA   
			loOBJETO.Left 	= loOBJETO.Left 	+ lnESPACAMENTO 	
		ENDIF 	
		
		* FORMGEN / COMBONN 
		IF INLIST(lcCLASSE,'FORMGEN','FORMCOMBONN') 
			loOBJETO.Top 	= loOBJETO.Top 		+ lnLARGURABORDA + lnESPACAMENTO 
			loOBJETO.Left 	= loOBJETO.Left 	+ lnESPACAMENTO * 2
		ENDIF 	
		
		* RETORNA ANCHOR 
		IF NOT EMPTY(lcANCHOR)
			loOBJETO.Anchor = lcANCHOR
		ENDIF 
	ENDFOR 

	* ADICIONA MARCAÇÃO DE AMBIENTE 
	TRY
		lcPATH= SYS(1271,toOBJETO)
		lcPATH= ALLTRIM(lcPATH)
		IF "\TEMP\"$UPPER(lcPATH)
			* CRIA MARCAÇÃO DE AMBIENTE
			toOBJETO.AddObject('FLATTEMP','FLATTEMP')
			toOBJETO.FLATTEMP.Left 		= toOBJETO.Width - toOBJETO.FLATTEMP.Width - 160
			toOBJETO.FLATTEMP.Top		= 5
			toOBJETO.FLATTEMP.Visible	= .T.
			toOBJETO.FLATTEMP.Anchor	= 9
		ENDIF
	CATCH
	ENDTRY

	* ADIÇÃO DE TÍTULO 
	IF INLIST(lcCLASSE,'FORMSUPER','FORMDIG','FORMREL','FORMDBF','FORMGEN','FORMCOMBONN')	
		IF TYPE('toOBJETO.lblFORMTITULO') <> 'O'
			toOBJETO.Addobject('lblFORMTITULO','Label')
			WITH toOBJETO.lblFORMTITULO AS Label 
				.AutoSize 	= .T.
				.BackStyle 	= 0
				.FontSize 	= 20
				.FontName 	= goAPLICATIVO.FLATFONT1
				.Caption 	= toOBJETO.Caption
				.ForeColor 	= RGB(255,255,255)
				.Visible 	= .T. 
				.Top 		= 5
				.Left 		= 5
				.ZOrder(1)
			ENDWITH 
			=BINDEVENT(toOBJETO.lblFORMTITULO,'DblClick',toOBJETO,'HmyDblClick')
			=BINDEVENT(toOBJETO.lblFORMTITULO,'RightClick',toOBJETO,'RightClick')
			=BINDEVENT(toOBJETO.lblFORMTITULO,'MouseMove',toOBJETO,'HmyMouseMove')
		ENDIF 
	ENDIF 

	* ADIÇÃO DE SHAPE DE CONTENÇÃO 
	IF INLIST(lcCLASSE,'FORMSUPER','FORMDIG','FORMDBF','FORMGEN','FORMCOMBONN')	

		* DEFINE INICIO VERTICAL E HORIZONTAL DO SHAPE DE CONTENÇÃO 
		lnTOPFUNDO = lnLARGURABORDA

		IF lcCLASSE == 'FORMSUPER'
			lnLEFTFUNDO = lnLARGURABORDA - 10
		ELSE 
			lnLEFTFUNDO	= lnESPACAMENTO 
		ENDIF 

		* ADICIONA SHAPE PARA O CONTEÚDO DO FORM 
		toOBJETO.Addobject('shpFLATFUNDO','Shape')
		WITH toOBJETO.shpFLATFUNDO AS Shape
			.Backcolor 		= RGB(255,255,255)
			.Visible 		= .T.
			.Top 			= lnTOPFUNDO
			.Left			= lnLEFTFUNDO
			.Height 		= lnFORMHEIGHT 
			.Width 			= lnFORMWIDTH + (lnESPACAMENTO * 2)
			.Anchor 		= 15 
			.Zorder(1)
			.Zorder(1)
		ENDWITH
		
	ENDIF 

	* ADICIONA FUNDO DA TOOLBAR
	IF lcCLASSE == 'FORMSUPER'
		toOBJETO.Addobject('shpFUNDOTOOLBAR','Shape')
		WITH toOBJETO.shpFUNDOTOOLBAR AS Shape
			.Backcolor 		= ALTERARGB(toOBJETO.BackColor,-50)
			.BorderStyle	= 0
			.Visible 		= .T.
			.Top 			= 48 
			.Left			= 5 
			.Height 		= 215 
			.Width 			= 30
			.ZOrder(1)
		ENDWITH 
	ENDIF 
		
	* CONFIGURA OBJETOS DA CLASSE 
	IF lcCLASSE == 'FORMDIG'
		WITH toOBJETO as Form
			.cmdOK.FontBold 		= .T. 
			.cmDCANCELAR.FontBold 	= .T.
			.cmdOK.Top 				= toOBJETO.Height - .cmdOK.Height - 10
			.cmdCANCELAR.Top		= toOBJETO.Height - .cmdCANCELAR.Height - 10 
			.lblPK.ForeColor		= RGB(255,255,255)
		ENDWITH 	
	ENDIF 	
		
	* REMOVE PARCIALMENTE A BORDA DO FORM 
	toOBJETO.TitleBar = 0 

	* CONFIGURA OBJETOS
	DO CONFIGOBJETOSFLAT WITH toOBJETO, lnCORIDENTIDADE

ENDFUNC 

FUNC CONFIGOBJETOSFLAT
**********************************************
* CONFIGURA OBJETOS DE ACORDO COM PADRÃO FLAT
**********************************************
LPARAMETERS toFORM, tnCORIDENTIDADE

IF GOAPLICATIVO.FLAT = 0
	RETURN
ENDIF

* DEFINE 
LOCAL loSUB, loPAGINA AS Object
LOCAL lcBASE, lcMODULO AS String

* VALOR DEFAULT 
STORE '' TO lcBASE, lcMODULO

* SCAN NOS OBJETOS DO FORM
FOR EACH loSUB IN toFORM.COntrols 
	* NOME E CLASSE BASE DO OBJETO 
	lcBASE		= ALLTRIM( UPPER(loSUB.BASECLASS ) )
	lcOBJETO	= ALLTRIM(UPPER(loSUB.Name))

	* TRATAMENTO PARA GRADES FORA DA PLATAFORMA
	IF lcBASE == 'GRID' AND ALLTRIM(UPPER(loSUB.CLASS)) <> 'SUPER'
		WITH loSUB AS Grid
			* TRATAMENTO PARA CABEÇALHOS COM MÚLTIPLAS LINHAS 
			IF .HeaderHeight < 25 
				.HeaderHeight 				= 25 && CABEÇALHO MAIOR 
			ENDIF 
		
			.FontName 					= goAPLICATIVO.FLATFONT2 
			.HighlightBackColor 		= RGB(247,247,247)
			.HighlightForeColor 		= RGB(0,0,0)
			.HighlightRowLineWidth 		= 2
			.HighlightStyle 			= 2
			.GridLines 					= 0
			.GridLineColor 				= RGB(107,106,112)
			.ForeColor 					= RGB(83,83,83)
			.ForeColor 					= RGB(60,60,60)		
			.GridLineColor 				= RGB(205,197,228)
			.GridLines 					= 2
			
			IF .RowHeight < 25
				.RowHeight 				= 25
			ENDIF 
		ENDWITH 
	ENDIF 

	* TRATAMENTO POR CLASSES
	DO CASE
		* TROCA DE FONTES 
		
		* DADOS PRENCHIDOS PELO USUÁRIO 
		CASE INLIST(lcBASE,'SPINNER','TEXTBOX','EDITBOX','COMBOBOX')
			* NÃO CONFIGURAR 
			IF '<NOCONFIG>' $ loSUB.Comment
				RETURN
			ENDIF
		
			* CONFIGURA COMBO 
			IF lcBASE == 'COMBOBOX' 
				WITH loSUB AS ComboBox 
					.FontBold 				= .T.
					.Height 				= 24 
					.ItemForeColor 			= RGB(50,50,50)
					.SelectedBackColor 		= RGB(255,255,255)
					.SelectedForeColor 		= RGB(0,0,0)
					.SelectedItemBackColor 	= tnCORIDENTIDADE
					.SelectedItemForeColor 	= RGB(255,255,255)
				ENDWITH 
			ENDIF 
		
			loSUB.FontName = gOAPLICATIVO.FLATFONTDADOS
		
		* CONTEÚDO FIXO 
		CASE INLIST(lcBASE,'OPTIONBUTTON','LABEL','COMMANDBUTTON','CHECKBOX','LISTBOX')
			* APENAS TROCA CASO FONTE ESJEJA DEFAULT 
			IF ALLTRIM(UPPER(loSUB.FontName)) == 'ARIAL' OR ALLTRIM(UPPER(loSUB.FontName)) == 'FIXEDSYS'  	
				loSUB.FontName  = goAPLICATIVO.FLATFONT2
				
				IF lcBASE == 'COMMANDBUTTON'
					loSUB.Themes = .T.
				ENDIF 
			ENDIF 
	
		* PAGEFRAME
		CASE lcBASE	== 'PAGEFRAME'
			* PAGEFRAME TEMADO
			loSUB.Themes = .T.
			FOR EACH loPAGINA IN loSUB.PAGES
				loPAGINA.FontName  = goAPLICATIVO.FLATFONT2
				loPAGINA.BackColor = RGB(255,255,255)
				DO CONFIGOBJETOSFLAT WITH loPAGINA, tnCORIDENTIDADE
			ENDFOR

		* CONTAINER
		CASE lcBASE == 'CONTAINER'
			DO CONFIGOBJETOSFLAT WITH loSUB, tnCORIDENTIDADE
			
			* FUNDO TEMADO PARA SHAPES SEM COR DE FUNDO 
			IF loSUB.BackColor = RGB(240,240,240) AND loSUB.BorderColor = RGB(100,100,100)
				loSUB.Style 		= 3 
				loSUB.ColorSource 	= 0 	
			ENDIF 
			
		* OPTIONGROUP
		CASE lcBASE == 'OPTIONGROUP'
		
			loSUB.BackStyle = 0 && transparente 
			FOR EACH loOPT IN loSUB.OBJECTS
				loOPT.BackStyle = 0 && transparente 
				loOPT.FontName 	= goAPLICATIVO.FLATFONT2 
			ENDFOR
			
		* SHAPE
		CASE lcBASE == 'SHAPE'
			* FUNDO TEMADO PARA SHAPES SEM COR DE FUNDO 
			IF loSUB.BackColor = RGB(240,240,240) AND loSUB.BorderColor = RGB(100,100,100)
				*loSUB.Style = 3 &&TEMADO 
				loSUB.BackColor = RGB(255,255,255)
			ENDIF 			
			
		* LABEL 
		CASE lcBASE == 'LABEL'
			* FUNDO TRANSPARENTE PARA LABELS SEM ALTERAÇÕES NAS CORES DEFAULT 
			IF loSUB.BackColor = RGB(240,240,240)
				loSUB.Backstyle = 0 &&FUNDO TRANSPARENTE
			ENDIF 	
		 
	ENDCASE
ENDFOR

ENDFUNC 

FUNC VCORFLAT
*****************************************************************
* RETORNA SE UMA COR PERTENCE A TABELA DE CORES FLAT DO SISTEMA
*
* PARÂMETROS: COR (NO FORMATO NUMÉRICO INTEIRO)
* RETORNO: .T. / .F. 
*****************************************************************

LPARAMETERS tnCOR 

* VALIDA PARÂMETROS 
IF TYPE('tnCOR') <> 'N'
	RETURN(.F.)
ENDIF  

* TENTA ENCONTRAR COR INFORMADA NA TABELA DE CORES 
IF "," + ALLTRIM(TRANSFORM(tnCOR)) + "," $ goAPLICATIVO.FLATCORES
	RETURN(.T.)
ELSE 	
	RETURN(.F.)
ENDIF

ENDFUNC

FUNC LOGPERF_GRAVAR
	LPARAMETERS tdDATETIME , tnTEMPOEXEC, tnREGS, tcACTION, tcCOMANDO
	IF TYPE('tdDATETIME') <> 'T'
		tdDATETIME = DATETIME()
	ENDIF
	IF TYPE('tnTEMPOEXEC') <> 'N'
		tnTEMPOEXEC = 0
	ENDIF
	IF TYPE('tnREGS') <> 'N'
		tnREGS = 0
	ENDIF
	IF TYPE('tcACTION') <> 'C'
		tcACTION = ''
	ENDIF
	IF TYPE('tcCOMANDO') <> 'C'
		tcCOMANDO = ''
	ENDIF
	
	IF GOAPLICATIVO.LOGPERF = 0 OR EMPTY(GOAPLICATIVO.LOGPERFTXT) OR NOT FILE(GOAPLICATIVO.LOGPERFTXT)
		RETURN(.F.)
	ENDIF
	
	* REMOVE CARACTERES DE QUEBRA DE LINHA E TAB DO COMANDO
	tcCOMANDO = STRTRAN(tcCOMANDO,CHR(10),'')
	tcCOMANDO = STRTRAN(tcCOMANDO,CHR(13),' ')
	tcCOMANDO = STRTRAN(tcCOMANDO,CHR(9),' ')
	
	LOCAL lcUSERID, lcFORM, lcGRAVA AS String
	STORE '' TO lcUSERID, lcFORM, lcGRAVA
	
	LOCAL lnALCA, lnSTACK AS Integer
	STORE 0 TO lnALCA, lnSTACK
	
	* ID DO USUÁRIO CORRENTE
	lcUSERID = NVL(ALLTRIM(TRANSFORM(GOCONEXAO.FK_USUARIO)),'')
	
	* ROTINA/FORM DO FORM CORRENTE
	IF TYPE('_SCREEN.ActiveForm.Name') = 'C'
		lcFORM = NVL(ALLTRIM(_SCREEN.ActiveForm.Name),'')
		lnSTACK	= ASTACKINFO(laSTACK)
		IF TYPE('laSTACK[lnSTACK-2,3]') = 'C'
			lcFORM	= ALLTRIM(laSTACK[lnSTACK-2,3])
		ELSE
			lcFORM = NVL(ALLTRIM(_SCREEN.ActiveForm.Name),'')
		ENDIF
	ENDIF
	
	* CRIA STRING PARA GRAVAÇÃO
	lcGRAVA = lcGRAVA + NVL(TTOC(tdDATETIME),'') + CHR(9) 											&& DATA/HORA
	lcGRAVA = lcGRAVA + NVL(ALLTRIM(TRANSFORM(tnTEMPOEXEC,'999,999,999.999')),'') + CHR(9) 			&& TEMPO DE EXECUÇÃO
	lcGRAVA = lcGRAVA + lcUSERID + CHR(9) 															&& ID DO USUÁRIO CORRENTE
	lcGRAVA = lcGRAVA + lcFORM + CHR(9) 															&& NOME DO FORM
	lcGRAVA = lcGRAVA + NVL(ALLTRIM(TRANSFORM(tnREGS)),'') + CHR(9) 								&& REGISTROS AFETADOS
	lcGRAVA = lcGRAVA + NVL(ALLTRIM(tcACTION),'') + CHR(9)				 							&& AÇÃO
	lcGRAVA = lcGRAVA + NVL(ALLTRIM(tcCOMANDO),'') + CHR(13) + CHR(10) 								&& COMANDO EXECUTADO
	
	TRY 
		STRTOFILE(lcGRAVA,GOAPLICATIVO.LOGPERFTXT,1)
	CATCH

	FINALLY

	ENDTRY
ENDFUNC

DEFINE CLASS TSUMARIO AS Custom 
	Titulo = '(Título do processo não informado)'
	ExibeValor = 1
	ExibeGrade = 1
	ExibeTempo = 1
	Colunasextras = ''
	DtIniciado = 	''
	DtEncerrado = 	''
	MyCampos = 		''
	
  * EXEMPLO: 	|FIELDNAME	| FIELD TYPE |
	
	PROCEDURE CRIARCURSOR
		THIS.DtIniciado = TTOC(DATETIME())
		LOCAL lcCURSOR, lcCOLUNAS, lcCOLUNAVALOR AS String 		
		
		TEXT TO lcCURSOR NOSHOW PRETEXT 15
			CREATE CURSOR TMPSUMARIO
			( 
				DS_BOLINHA C(2)
				,DS_REGSTATUS C(10)
				,DS_STATUS C(30)
				,DS_OBS C(50)
				,NR_COR C(10)
				[VALOR]
				[COLUNAS]
			)
		ENDTEXT
		lcCOLUNAS = ''
		lcCOLUNAVALOR = ''
		
		FOR lnXI = 1 TO MEMLINES(THIS.COLUNASEXTRAS)
			lcLINHADEF = MLINE(THIS.COLUNASEXTRAS, lnXI)
			lcNOME = ALLTRIM(STREXTRACT(lcLINHADEF,'|','|',1))
			lcTIPAGEM = ALLTRIM(STREXTRACT(lcLINHADEF,'|','|',2))
			lcLINHA = ',' + lcNOME + ' ' + lcTIPAGEM
			lcCOLUNAS = lcCOLUNAS + lcLINHA
		ENDFOR
		
		IF THIS.ExibeValor = 1 THEN 
			lcCOLUNAVALOR = ',VL_VALOR N(13,2)'
		ENDIF
		
		lcCURSOR = 	STRTRAN( lcCURSOR , '[VALOR]', lcCOLUNAVALOR )
		lcCURSOR =	STRTRAN( lcCURSOR , '[COLUNAS]', lcCOLUNAS )
		&lcCURSOR
			
	ENDPROC 

	PROCEDURE INCLUIR
		
		LPARAMETERS tcREGSTATUS, tcSTATUS, tcOBS, tnVALOR
		
		IF EMPTY(tnVALOR) THEN 
			tnVALOR = 0
		ENDIF
		
		SELE TMPSUMARIO
		SCATTER NAME loREG MEMO
		loREG.DS_BOLINHA	= 'n'						&& BOLINHA/WINGDINGS
		loREG.DS_REGSTATUS	= tcREGSTATUS				&& ERRO/ALERTA/SUCESSO
		loREG.DS_STATUS		= tcSTATUS
		loREG.DS_OBS		= tcOBS
		IF THIS.ExibeValor = 1 THEN 
			loREG.VL_VALOR		= tnVALOR
		ENDIF
		
		* MONTAGEM DE CORES
		DO CASE
			CASE UPPER(loREG.DS_REGSTATUS)='ERRO'
				loREG.NR_COR		= RGB(127,0,0)		&& VERMELHO
			CASE UPPER(loREG.DS_REGSTATUS)='ALERTA'
				loREG.NR_COR		= RGB(127,127,0)	&& LARANJA/AMARELADO
			CASE UPPER(loREG.DS_REGSTATUS)='SUCESSO'
				loREG.NR_COR		= RGB(0,127,0)		&& VERDE
			OTHERWISE
				loREG.NR_COR		= RGB(0,0,127)		&& AZUL
		ENDCASE
		APPEND BLANK
		SELE TMPSUMARIO
		GATHER NAME loREG MEMO
		
	ENDPROC 

	PROCEDURE EXIBIR
		THIS.DtEncerrado = TTOC(DATETIME())
		=CHAMAFORM('SYS_TSUMARIO','MODAL',THIS)
	ENDPROC 
ENDDEFINE 

DEFINE CLASS SHAPEFORMCUSTOM AS Shape
************************************************************
* SHAPE UTILIZADO PARA IDENTIFICAÇÃO DE FORMS CUSTOMIZADOS *
************************************************************
	Height = 12
	Width = 12
	BorderWIdth = 2
	BorderColor = RGB(255,255,255)
	Curvature = 50
	BackColor = RGB(0,0,0)
	MousePointer = 15
	Visible = .F.
	
	PROC Init
		This.Left = 2
		This.Top = This.Parent.Height - 14
		This.Anchor = 6
		This.ZOrder(0)
	ENDPROC
	
	PROC Click
		MENS(THIS.Tag)
	ENDPROC
	
	PROC RightClick
			THIS.ZOrder(1)
			THIS.Visible = .F.
	ENDPROC
ENDDEFINE

DEFINE CLASS IMAGEMAJUDA AS Image
********************************************************************************************
* IMAGEM UTILIZADA PARA IDENTIFICAÇÃO DE TELAS QUE POSSUME TÓPICO DE AJUDA CONFIGURADO (F1) *
*********************************************************************************************
	Height			= 15
	Width			= 15
	MousePointer	= 15
	Visible 		= .F.
	Stretch			= 1
	
	PROC Init
		
		* SÓ FAZ ALGO SE JÁ TIVER CONECTADO NA BASE DE DADOS
		IF TYPE('GOCONEXAO.ALCA') <> 'N'
			RETURN(.F.)
		ELSE
			IF GOCONEXAO.ALCA <= 0
				RETURN(.F.)
			ENDIF
		ENDIF			
				
		IF GOAPLICATIVO.ALERTAHELP <> 'ON'
 			RETURN(.F.)
		ENDIF
		
		LOCAL lcCOMANDO AS String
		STORE '' TO lcCOMANDO
		
		LOCAL loFORM AS Object
		loFORM = THIS.Parent
		
		IF ALLTRIM(UPPER(loFORM.BaseClass)) <> 'FORM'
			RETURN(.F.)
		ENDIF
		
		* NÃO CRIA A IMAGEM NA TELA DE RECONEXAO PARA EVITAR PROBLEMA DE LOOPING INFINITO NA HORA DE CONSULTAR A TS_AJUDA
		IF ALLTRIM(UPPER(loFORM.Name)) = 'SYSTEM_ERROCONEXAO'
			RETURN(.F.)
		ENDIF
		
		* SALVA NOME DO CURSOR ATUAL
		lcALIAS = ALIAS()
		
		* VERIFICA SE A TELA POSSUÍ TÓPICO DE AJUDA CADASTRADO
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT PK_ID FROM TS_AJUDA WHERE PK_ID = [[FORM]]
		ENDTEXT
		lcCOMANDO	= STRTRAN( lcCOMANDO, '[[FORM]]', XX(loFORM.NAME) )
		=PESQUISASQL(lcCOMANDO,'TMPAJUDA')
		
		IF NOT USED('TMPAJUDA') OR RECCOUNT('TMPAJUDA') < 1
			* VOLTA CURSOR SELECIONADO ANTERIORMENTE
			IF NOT EMPTY(lcALIAS) AND USED(lcALIAS)
				SELE (lcALIAS)
			ENDIF
			RETURN(.F.)
		ENDIF
		
		USE IN TMPAJUDA
		
		THIS.Visible = .T.

		IF GOAPLICATIVO.FLAT = 1
			THIS.Picture = POEIMG('HELPFLAT.PNG')
			
			* SEMPRE FICA NO TOP DIREITO DA TELA
			THIS.Top			= 5
			THIS.Left			= loFORM.Width - 120
			THIS.Height			= 20
			THIS.Width			= 20
		ELSE
			THIS.Picture = POEIMG('HELP.PNG')
			
			* POSICIONA IMAGEM
			THIS.Top	= 3
			THIS.Left	= loFORM.Width - 18
			
			* REPOSICIONA LABEL DE REGISTROS NO FORMSUPER
			IF ALLTRIM(UPPER(loFORM.Class)) = 'FORMSUPER'
				loFORM.lblTOTREG.Anchor = 0
				loFORM.lblTOTREG.Left = THIS.Left - loFORM.lblTOTREG.Width - 20
				loFORM.lblTOTREG.Anchor = 9
			ENDIF
		ENDIF
		THIS.Anchor = 9 && SUPERIOR DIREITA
		
		* VOLTA CURSOR SELECIONADO ANTERIORMENTE
		IF NOT EMPTY(lcALIAS) AND USED(lcALIAS)
			SELE (lcALIAS)
		ENDIF
	ENDPROC
	
	PROC Click
		LOCAL loFORM AS Object
		loFORM = THIS.Parent
		
		IF ALLTRIM(UPPER(loFORM.BaseClass)) <> 'FORM'
			RETURN(.F.)
		ENDIF
		
		DO SYSHELP WITH loFORM
	ENDPROC
	
	PROC RightClick
			THIS.ZOrder(1)
			THIS.Visible = .F.
	ENDPROC
ENDDEFINE

FUNC BUSCACAMPO
*********************************************************************
* FUNCAO QUE RETORNA VALOR DO PRIMEIRO CAMPO DO PRIMEIRO REGISTRO	*
*********************************************************************
	LPARAMETERS tcCOMANDO AS String
	
	LOCAL luRETORNO
	
	* ARMAZENA CUSOR QUE ESTAVA SELECIONADO
	lcCURSOR = ALIAS()

	* REALIZA BUSCA ENVIADA PELO USUARIO
	PESQUISASQL(tcCOMANDO, 'TMPRES')
	
	* VEFIFICA QUAL É O NOME DO PRIMEIRO CAMPO
	AFIELDS(laCAMPOS, 'TMPRES')
	
	SELE TMPRES
	luRETORNO = &laCAMPOS(1,1)
	
	USE IN TMPRES
	
	TRY
		SELE &lcCURSOR 
	CATCH
	ENDTRY
	
	RETURN luRETORNO
ENDFUNC

FUNC RETORNA_UTCPORUF
**************************************
* FUNCAO PARA RETORNAR UTC DE UMA UF *
**************************************
	LPARAMETERS tcUF

	IF TYPE('tcUF') <> 'C'
		tcUF	= ''
	ENDIF
	
	IF NOT LEN(ALLTRIM(tcUF)) = 2
		tcUF	= ''
	ENDIF
	
	IF NOT EMPTY(tcUF)
	
		LOCAL lnUTC AS Number
		STORE 0 TO lnUTC
		
		IF TYPE('GOAPLICATIVO.UTC') = 'C'
			lnUTC = VAL(STREXTRACT(GOAPLICATIVO.UTC,'<' + tcUF + '>','</' + tcUF + '>',1))
		ENDIF 
		
		IF EMPTY(lnUTC)
			lnUTC = 0
		ENDIF
		
	ELSE
	
		lnUTC = 0
		
	ENDIF
	
	RETURN(lnUTC)
ENDFUNC

PROC MONTARUTCPORUF
*******************************************
* CARREGA VALORES DE UTC ATUAL POR ESTADO *
******************************************
	LOCAL lcCOMANDO,lcUTC AS String
	LOCAL lnRETORNO AS Integer
	STORE 0 TO lnRETORNO
	STORE '' TO lcCOMANDO,lcUTC

	TEXT TO lcCOMANDO NOSHOW PRETEXT 7
		SELECT 
			TOP 1
			PK_ID
		FROM 
			TB_UTC
		ORDER BY
			NR_VERSAO
		DESC
	ENDTEXT
	lnRETORNO = SQLEXEC(goCONEXAO.ALCA,lcCOMANDO,'TMPUTC')	
	
	IF lnRETORNO > 0
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT 
				NR_UTC
				,FK_UF
			FROM 
				TB_UTCITEM
			WHERE
				FK_UTC = [[FK_UTC]]
				AND [[DATATUAL]] BETWEEN DT_INICIO AND DT_FIM
		ENDTEXT
		lcCOMANDO	= STRTRAN( lcCOMANDO, '[[FK_UTC]]', XX(TMPUTC.PK_ID) )
		lcCOMANDO	= STRTRAN( lcCOMANDO, '[[DATATUAL]]', XX(DATASERVER()) )
		lnRETORNO 	= SQLEXEC(goCONEXAO.ALCA,lcCOMANDO,'TMPUTCITEM')
	ENDIF

	IF lnRETORNO <= 0
		IF VMODULO('FT')
			DO MENS WITH 'Problemas ao carregar Fuso Horário! - UTC (Tempo Universal Coordenado), isso pode causar problemas na emissão de NF-e, entre em contato com o administrador do sistema.'
		ENDIF
		RETURN(.F.)
	ENDIF
	
	IF RECCOUNT('TMPUTCITEM') > 28 && Para o mesmo período, o número máximo de registros é igual ao número de UF's existentes.
		IF VMODULO('FT')
			DO MENS WITH 'Problemas ao carregar Fuso Horário! - UTC (Tempo Universal Coordenado), favor revisar o cadastro para a data atual'
		ENDIF
		RETURN(.F.)
	ENDIF
	
	SELE TMPUTCITEM
	GO TOP
	SCAN WHILE NOT EOF('TMPUTCITEM')
		lcUTC = lcUTC + '<' + TMPUTCITEM.FK_UF + '>' + ALLTRIM(STR(TMPUTCITEM.NR_UTC)) + '</' + TMPUTCITEM.FK_UF + '>'
	ENDSCAN
	GOAPLICATIVO.UTC = lcUTC
	
	*FECHANDO CURSORES
	IF USED('TMPUTC')
		USE IN 'TMPUTC'
	ENDIF
	
	IF USED('TMPUTCITEM')
		USE IN 'TMPUTCITEM'
	ENDIF
	
ENDPROC

PROC QUICKMAIL_CALL
*****************
*CHAMADA DE FORMULARIO GENERICO DE ENVIO DE MENSAGENS
	LOCAL lnDATASESSION AS Integer
	LOCAL llOPEN AS Boolean
	
	LOCAL lcQUICKMAIL AS String
	STORE '' TO lcQUICKMAIL
	
	lnDATASESSION = 0
	llOPEN = .F.
	lcQUICKMAIL = UPPER(ALLTRIM(RETORNASET('SISTEMA.QUICKMAIL','C',1)))
	IF lcQUICKMAIL == 'ON'
		IF TYPE('_SCREEN.ACTIVEFORM')='O'
			lnDATASESSION = _SCREEN.ActiveForm.DATASESSIONID
			IF _SCREEN.ActiveForm.NAME = 'SYSTEM_QUICKMAIL'
				llOPEN = .T.
			ENDIF
		ENDIF
		IF NOT llOPEN 
			DO FORM 'SYSTEM_QUICKMAIL' WITH lnDATASESSION
		ENDIF
	ENDIF
RETURN

PROC VAZIO
	PARAMETERS tuVALOR
	IF ISNULL(tuVALOR)
		RETURN(.T.)
	ENDIF
	IF EMPTY(tuVALOR)
		RETURN(.T.)
	ENDIF
	
	* SE NÃO TIVER NULL NEM VAZIO RETORNA .F.
	RETURN(.F.)
ENDPROC

FUNC LIMPAPASTA
	LPARAMETERS tcESQ, ttDTLIM, tcEXT, tcOUT
	
	* OBJETIVO: EXCLUIR OS ARQUIVOS DE UMA PASTA
	*************************************************************************************************
	* tcESQ		= ESQUELETO (CAMINHO + MÁSCARA DOS ARQUIVOS EX: C:\LIXO\PREFIXO_*.*)				*
	* ttDTLIM	= DATETIME DE CORTE (APAGAR SÓ OS ARQUIVOS ANTERIORES)								*
	* tcEXT		= EXTENÇÕES A EXCLUR OU MANTER (EX: 'PDF,DOC')										*
	* tcOUT		= OUTROS STRING COM OPÇÕES ADICIONAIS:												*
	*	  		'EXT=MANTER'	= MANTER EXTENSÔES INFORMADAS										*
	*     		'EXT=APAGAR'	= APAGAR EXTENSÔES INFORMADAS										*
	*	  		'WAIT=OFF'		= NÃO EXIBIR WAIT DO PROGRESSO DE PROCESSAMENTO DOS ARQUIVOS		*
	*************************************************************************************************
	
	Local lnQTD, lnEXCLUIDOS, lnX, lnWAIT, lnFALHA, lnBARRAS, lnPOSICAOBARRA As Number
	LOCAL lcEXTENSAO, lcCAMPOAFORMATAR, lcPATH, lcKILL, lcFILENAME, lcEXTARQ, lcFILEDEL as String
	LOCAL ldARQ as Date
	LOCAL ltALTERACAO as Datetime

	STORE 0 TO lnQTD, lnEXCLUIDOS, lnX, lnWAIT, lnFALHA, lnBARRAS, lnPOSICAOBARRA
	STORE '' TO lcCAMPOAFORMATAR, lcPATH, lcFILENAME, lcEXTARQ, lcFILEDEL

	IF VARTYPE(tcESQ) <> 'C'
		tcESQ = ''
	ENDIF

	IF EMPTY(tcESQ)
		RETURN(.F.)
	ENDIF

	IF TYPE('ttDTLIM') = 'D'
		ttDTLIM = DTOT(ttDTLIM)
	ENDIF

	IF TYPE('ttDTLIM') <> 'T'
		ttDTLIM = CTOT('')
	ENDIF

	IF TYPE('tcEXT') <> 'C'
		tcEXT = ''
	ENDIF

	IF TYPE('tcOUT') <> 'C'
		tcOUT = ''
	ENDIF

	* PARAMETRIZAÇÃO: REGRA PARA APAGAR OU MANTER EXTENSÕES
	* KILL = '' =  APAGA TODAS EXTENSÕES
	* KILL = A => APAGAR ARQUIVOS DESTAS EXTENSÕES (DEFAULT)
	* KILL = M => APAGAR TUDO, MENOS OS ARQUIVOS DESTAS EXTENSÕES
	
	lcKILL = ''
	
	IF OCCURS('EXT=MANTER', UPPER(tcOUT)) > 0
		lcKILL = 'M'
	ENDIF
	IF OCCURS('EXT=APAGAR', UPPER(tcOUT)) > 0
		lcKILL = 'A'
	ENDIF

	* PARAMETRIZAÇÃO: EXIBIR OU NÃO MENSAGEM DURANTE EXECUÇÃO (DEFAULT=SIM)
	lnWAIT = 1
	IF OCCURS('WAIT=OFF', UPPER(tcOUT)) > 0
		lnWAIT = 0
	ENDIF

	lnBARRAS = OCCURS('\', tcESQ)
	lnPOSICAOBARRA = AT('\', tcESQ, LNBARRAS)
	lcCAMPOAFORMATAR = SUBSTR(tcESQ, lnPOSICAOBARRA)
	lcPATH = STRTRAN( tcESQ, lcCAMPOAFORMATAR, '')

	* MONTA ARRAY DE ARQUIVOS
	lnQTD = ADIR(laARQ, tcESQ)
	
	IF lnQTD = 0
		RETURN(.F.)
	ENDIF
	
	* VARIÁVEL PRIVATE PARA RETORNO 	
	pnQT_TOTAL = lnQTD
	
	FOR lnX = 1 TO lnQtD
		lcFILENAME = laARQ[lnX,1]
		IF lnWAIT = 0
			WAIT WIND 'Arquivo: ' + lcFILENAME + CHR(13) + TRANSFORM(lnX) + ' de ' + TRANSFORM(lnQTD) NOWAIT NOCLEAR
		ENDIF

		lcEXTARQ = UPPER( JUSTEXT( lcFILENAME ))
		
		IF lcKILL='M' AND ',' + lcEXTARQ + ',' $ ',' + UPPER(tcEXT) + ','
			* APAGAR ARQUIVOS, EXCETO ESTAS EXTENSÕES
			pnQT_TOTAL = pnQT_TOTAL - 1 
			LOOP
		ENDIF
		IF lcKILL='A' AND NOT ',' + lcEXTARQ + ',' $ ',' + UPPER(tcEXT) + ','
			* APAGAR SÓ OS ARQUIVOS DESTAS EXTENSÕES
			pnQT_TOTAL = pnQT_TOTAL - 1 
			LOOP
		ENDIF
		
		ldARQ = laARQ[lnX,3]
		ltALTERACAO = CTOT(TRANSFORM(YEAR(ldARQ)) + '-' + TRANSFORM(MONTH(ldARQ));
			+ '-' + TRANSFORM(DAY(ldARQ)) + 'T' + laARQ[lnX,4] + 'Z')

		IF NOT EMPTY(ttDTLIM) AND ltALTERACAO >= ttDTLIM
			pnQT_TOTAL = pnQT_TOTAL - 1 
			LOOP
		ENDIF
		lcFILEDEL = FORCEPATH(laARQ[lnX,1], lcPATH)
		
		IF NOT FILE(lcFILEDEL)
			pnQT_TOTAL = pnQT_TOTAL - 1 
			LOOP
		ENDIF
		
		TRY
			DELETE FILE(lcFILEDEL)
		CATCH
			lnFALHA = lnFALHA + 1
		ENDTRY
		
		IF NOT FILE(lcFILEDEL)
			lnEXCLUIDOS = lnEXCLUIDOS + 1
		ENDIF
		
	ENDFOR

	WAIT CLEAR

	* ALIMENTA VARIEIS PRIVATES PARA RETORNO
	pnQT_DELETADOS	= lnEXCLUIDOS
	pnQT_FALHAS		= lnFALHA

	RETURN(.T.)
ENDFUNC

* Função responsavel por lançar uma exceção, simula um CATCH de erro
* Em ambiente de produção criará um erro do sistema
* Em ambiente de testes gera uma exception na IDE.
FUNC FORCAR_ERRO
	LPARAMETERS tcMENSAGEM AS String, tnNUMEROERRO AS Integer, tcDETALHES AS String
	IF TYPE('tcMENSAGEM') <> 'C'
		tcMENSAGEM = ''
	ENDIF
	IF TYPE('tnNUMEROERRO') <> 'N'
		tnNUMEROERRO = ''
	ENDIF
	IF TYPE('tcDETALHES') <> 'C'
		tcDETALHES = ''
	ENDIF
	
	* LANÇAR UM ERRO CAPTURÁ-LO E RELANÇA-LO MODIFICADO
	LOCAL loEXCEPTION, lnLEVEL, laSTACKINFO[1]
	TRY 
		THROW
	CATCH TO loEXCEPTION
		* PREENCHE COM OS VALORES PADRÕES E ADICIONA OS VALORES CUSTOMIZÁVEIS.
		lnLEVEL						= ASTACKINFO(laSTACKINFO) - 1
		loEXCEPTION.Message			= EVL(tcMENSAGEM, "") 
		loEXCEPTION.ErrorNo			= EVL(tnNUMEROERRO, loEXCEPTION.ErrorNo) 
		loEXCEPTION.Details			= EVL(tcDETALHES, "") 
		loEXCEPTION.Procedure		= laSTACKINFO[lnLEVEL, 3]
		loEXCEPTION.LineNo			= laSTACKINFO[lnLEVEL, 5]
		loEXCEPTION.LineContents	= laSTACKINFO[lnLEVEL, 6]
		loEXCEPTION.StackLevel		= lnLEVEL
		THROW
	ENDTRY 
ENDFUNC

* Classe responsavel pelos utilitarios do sistema
* oDotNetBridge - Objeto resposavel pela ponte de .NET com o FOX
* Repositório
*	- https://github.com/RickStrahl/wwDotnetBridge
* oJSONParser - Objeto responsavel por tratar JSON e XML
DEFINE CLASS Utilitarios AS Custom
	oDotNetBridge	= .NULL.	&& Objeto que faz a ponte do .net com o FOX
	oJSONParser		= .NULL.
	HIDDEN cPasta_Sitema		&& Indica a pasta do sistema.
	
	FUNC Init
		THIS.oDotNetBridge	= .NULL.
		THIS.oJSONParser	= .NULL.
		THIS.cPasta_Sitema	= ADDBS(FULLPATH(''))
	ENDFUNC
	
	* Função responsavel por instanciar uma classe de uma DLL
	* Parametos
	* tcDLL[Obrigatorio] - Nome da dll a ser instanciada
	* tcClasse[Obrigatorio] - Nome da classe a ser instanciada normalmente segue o padrão Nome_da_DLL.Nome_da_Classe
	* RETORNO
	*	Objeto	- Instancia da classe
	*	NULL	- Em caso de não ter sido carregado corretamente.
	FUNC InstanciarDLL
		LPARAMETERS tcDLL AS String, tcClasse AS String
		IF TYPE('tcDLL') <> 'C'
			tcDLL		= ''
		ENDIF
		IF TYPE('tcClasse') <> 'C'
			tcClasse	= ''
		ENDIF
		IF EMPTY(tcDLL)
			MENS("Não foi informado o nome de uma DLL válida.")
			RETURN .NULL.
		ENDIF
		IF EMPTY(tcClasse)
			MENS("Não foi informado o nome de uma Classe válida.")
			RETURN .NULL.
		ENDIF
		IF NOT TYPE('THIS.oDotNetBridge') == 'O'
			RETURN .NULL.
		ENDIF
		
		LOCAL lcDLL AS String
		STORE '' TO lcDLL
		lcDLL = THIS.cPasta_Sitema + FORCEEXT(tcDLL, 'DLL')
		IF NOT THIS.oDotNetBridge.LoadAssembly(lcDLL)
			MENS(THIS.oDotNetBridge.cErrorMsg)
		ENDIF
		
		LOCAL loINSTANCIA AS Object
		loINSTANCIA = THIS.oDotNetBridge.CreateInstance(tcClasse)
		
		IF THIS.oDotNetBridge.lError
			MENS(THIS.oDotNetBridge.cErrorMsg)
		ENDIF
		
		RETURN loINSTANCIA
	ENDFUNC
	
	* Funções de apoio
	FUNC oDotNetBridge_Access
		IF NOT TYPE('THIS.oDotNetBridge') == 'O'
			* Tenta carregar o componente padrão de ponte entre o .net e o FOX
			THIS.oDotNetBridge = THIS.Carregar_DotNetBridge()
		ENDIF
		
		RETURN THIS.oDotNetBridge
	ENDFUNC
	
	FUNC oJSONParser_Access
		IF NOT TYPE('THIS.oJSONParser') == 'O'
			* Carrega o objeto de JSONParser
			THIS.oJSONParser = THIS.Carregar_JSONParser()
		ENDIF
		
		RETURN THIS.oJSONParser
	ENDFUNC
	
	* Função responsavel por carregar o componente de ponte entre o .net e o fox
	HIDDEN FUNC Carregar_DotNetBridge
		* Verificando Dependencias
		IF NOT FILE(THIS.cPasta_Sitema + 'CLRHOST.DLL')
			MENS('O sistema não conseguiu encontrar o arquivo ' + THIS.cPasta_Sitema + 'CLRHOST.DLL')
			RETURN .NULL.
		ENDIF
		IF NOT FILE(THIS.cPasta_Sitema + 'WWDOTNETBRIDGE.DLL')
			MENS('O sistema não conseguiu encontrar o arquivo ' + THIS.cPasta_Sitema + 'WWDOTNETBRIDGE.DLL')
			RETURN .NULL.
		ENDIF
		
		* Instanciando a classe
		LOCAL loBridge AS 'wwDotNetBridge'
		loBridge = CREATEOBJECT("wwDotNetBridge", "V4")

		RETURN loBridge
	ENDFUNC
	
	* Carrega a DLL e classe do JSONParser
	HIDDEN FUNC Carregar_JSONParser
		* Verificando Dependencias
		IF NOT FILE(THIS.cPasta_Sitema + 'NEWTONSOFT.JSON.DLL')
			MENS('O sistema não conseguiu encontrar o arquivo ' + THIS.cPasta_Sitema + 'NEWTONSOFT.JSON.DLL')
			RETURN .NULL.
		ENDIF
		IF NOT FILE(THIS.cPasta_Sitema + 'PWISISTEMAS_UTILITARIOS.DLL')
			MENS('O sistema não conseguiu encontrar o arquivo ' + THIS.cPasta_Sitema + 'PWISISTEMAS_UTILITARIOS.DLL')
			RETURN .NULL.
		ENDIF
		
		* Instanciando a classe
		LOCAL loINSTANCIA AS Object
		LOCAL loJSONParser AS 'JSONParser'
		loINSTANCIA = THIS.InstanciarDLL('PWISISTEMAS_UTILITARIOS', 'Utilitarios.JSONParser')
		
		* Verifica se conseguiu instanciar a classe corretamente.
		IF NOT TYPE('loINSTANCIA') == 'O'
			RETURN .NULL.
		ENDIF
		
		* Cria a classe de JSONParser que contém todos os métodos para o Intelissense
		loJSONParser = CREATEOBJECT('JSONParser', loINSTANCIA)

		RETURN loJSONParser
	ENDFUNC
ENDDEFINE

* Classe responsavel por lidar com JSON no sistema.
DEFINE CLASS JSONParser AS Custom
	HIDDEN oJSONParser && Objeto que faz referencia a DLL, não deve ser usado diretamente
	
	FUNC Init
		LPARAMETERS toJSONParser AS Object
		THIS.oJSONParser = .NULL.
		
		IF TYPE('toJSONParser') == 'O'
			THIS.oJSONParser = toJSONParser
		ENDIF
	ENDFUNC
	
	* Verifica se a instancia da classe foi carregada corretamente.
	HIDDEN FUNC VerificarClasse
		IF NOT TYPE('THIS.oJSONParser') == 'O'
			MENS('Instancia do JSONParser não carregada.')
			RETURN .F.
		ENDIF
		RETURN .T.
	ENDFUNC
	
	* Função JsonToXml
	* Converte uma string JSON para um XML
	FUNC JsonToXml
		LPARAMETERS tcJSON AS String, tcNODERAIZ AS String, tlPretty AS Logical
		IF TYPE('tcJSON') <> 'C'
			tcJSON	= ''
		ENDIF
		IF TYPE('tcNODERAIZ') <> 'C'
			tcNODERAIZ	= ''
		ENDIF
		IF TYPE('tlPRETTY') <> 'L'
			tlPRETTY	= .F.
		ENDIF
		IF NOT THIS.VerificarClasse()
			RETURN .NULL.
		ENDIF
		
		RETURN THIS.oJSONParser.JsonToXml(tcJSON, tcNODERAIZ, tlPRETTY)
	ENDFUNC

	* Função XmlToJson
	* Converte uma string XML para uma string JSON
	FUNC XmlToJson
		LPARAMETERS tcXML AS String, tlPretty AS Logical
		IF TYPE('tcXML') <> 'C'
			tcXML	= ''
		ENDIF
		IF TYPE('tlPRETTY') <> 'L'
			tlPRETTY	= .F.
		ENDIF
		IF NOT THIS.VerificarClasse()
			RETURN .NULL.
		ENDIF
		
		RETURN THIS.oJSONParser.XmlToJson(tcXML, tlPRETTY)
	ENDFUNC
	
	* Função BeautifyXml
	* Embeleza uma String Xml
	FUNC BeautifyXml
		LPARAMETERS tcXML AS String
		IF TYPE('tcXML') <> 'C'
			tcXML	= ''
		ENDIF
		IF NOT THIS.VerificarClasse()
			RETURN .NULL.
		ENDIF
		
		RETURN THIS.oJSONParser.BeautifyXml(tcXML)
	ENDFUNC
	
	* Função BeautifyJson
	* Embeleza uma String Json
	FUNC BeautifyJson
		LPARAMETERS tcJSON AS String
		IF TYPE('tcJSON') <> 'C'
			tcJSON	= ''
		ENDIF
		IF NOT THIS.VerificarClasse()
			RETURN .NULL.
		ENDIF
		
		RETURN THIS.oJSONParser.BeautifyJson(tcJSON)
	ENDFUNC
	************************************************************
ENDDEFINE

FUNC NUVEM_CONNECT
	* MÉTODO PARA CONECTAR NO SERVIÇO DE NUVEM E RETORNAR OBJETO DE COMUNICAÇÃO OU STRING DE ERRO
	* SÓ FUNCIONA COM A AWS POR ENQUANTO
	* RETORNA SEMPRE UM OBJETO
	
	LOCAL llERRO AS Boolean
	STORE .F. TO llERRO
	
	LOCAL lcNUVEMCONFIG, lcBUCKETNOME, lcBUCKETREGIAO, lcACCESSKEY, lcSECRETKEY, lcXML, lcXMLRETORNO  AS String
	STORE '' TO lcNUVEMCONFIG, lcBUCKETNOME, lcBUCKETREGIAO, lcACCESSKEY, lcSECRETKEY, lcXML, lcXMLRETORNO
	
	* OBJETO DE RETORNO
	LOCAL loRET AS Object
	loRET = CREATEOBJECT('Custom')
	loRET.AddProperty('SUCESSO')
	loRET.AddProperty('DESCRICAO')
	loRET.AddProperty('DLLMENSAGEM')
	loRET.AddProperty('DLLXML')
	loRET.AddProperty('OBJ')
	loRET.SUCESSO		= .F.
	loRET.DESCRICAO		= ''
	loRET.DLLMENSAGEM	= ''
	loRET.DLLXML		= ''
	loRET.OBJ			= CREATEOBJECT('EMPTY')
		
	* CARREGA PARÂMETRO COM DADOS DA AWS
	lcNUVEMCONFIG = RETORNASET('NUVEM.CONFIG','C',1)
	
	lcBUCKETNOME	= ALLTRIM(STREXTRACT(lcNUVEMCONFIG,'BUCKETNOME=',';'))
	lcBUCKETREGIAO	= ALLTRIM(STREXTRACT(lcNUVEMCONFIG,'BUCKETREGIAO=',';'))
	lcACCESSKEY		= ALLTRIM(STREXTRACT(lcNUVEMCONFIG,'ACCESSKEY=',';'))
	lcSECRETKEY		= ALLTRIM(STREXTRACT(lcNUVEMCONFIG,'SECRETKEY=',';'))
	
	IF EMPTY(lcBUCKETNOME) OR EMPTY(lcBUCKETREGIAO) OR EMPTY(lcACCESSKEY) OR EMPTY(lcSECRETKEY)
		loRET.SUCESSO 	= .F.
		loRET.DESCRICAO = 'Parâmetros de conexão com AWS incompletos (Parâmetro="NUVEM.CONFIG").'
		RETURN(loRET)
	ENDIF
	
	* TENTA CRIAR OBJETO DE INTEGRAÇÃO
	LOCAL loCONNECT AS Object
	TRY 
		loCONNECT = CREATEOBJECT('FoxAwsStore.Core.AwsStoreCore')
	CATCH
		llERRO = .T.
	ENDTRY
	
	IF llERRO
		loRET.SUCESSO 	= .F.
		loRET.DESCRICAO = 'Erro ao criar objeto de comunicação da AWS. As DLLs de integração com a AWS não estão instaladas/funcionando.'
		RETURN(loRET)
	ENDIF
	
	DO ESPERANDO WITH 'Conectando no serviço da AWS...'
	
	* XML BASE
	TEXT TO lcXML NOSHOW PRETEXT 7
		<AWSSetupModel xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
			<SetupAmbiente>PRODUCAO</SetupAmbiente>
			<BucketNome>[[BUCKETNOME]]</BucketNome>
			<BucketRegiao>[[BUCKETREGIAO]]</BucketRegiao>
			<AccessKey>[[ACCESSKEY]]</AccessKey>
			<SecretKey>[[SECRETKEY]]</SecretKey>
		</AWSSetupModel>
	ENDTEXT
	
	* ALIMENTA INFORMAÇÕES CONTIDAS NA ZW
	lcXML = STRTRAN(lcXML, '[[BUCKETNOME]]', lcBUCKETNOME)
	lcXML = STRTRAN(lcXML, '[[BUCKETREGIAO]]', lcBUCKETREGIAO)
	lcXML = STRTRAN(lcXML, '[[ACCESSKEY]]', lcACCESSKEY)
	lcXML = STRTRAN(lcXML, '[[SECRETKEY]]', lcSECRETKEY)
	
	* FAZ A CONEXÃO
	lcXMLRETORNO 		= UPPER(loCONNECT.Setup(lcXML))
	loRET.DLLXML		= lcXMLRETORNO
	loRET.DLLMENSAGEM	= ALLTRIM(STREXTRACT(lcXMLRETORNO,'<Mensagem>','</Mensagem>'))
	
	IF EMPTY(lcXMLRETORNO) OR UPPER(ALLTRIM(STREXTRACT(lcXMLRETORNO,'<IsErro>','</IsErro>'))) == 'TRUE'
		loRET.SUCESSO 		= .F.
		loRET.DESCRICAO 	= 'Falha ao conectar no serviço AWS. Verifique os dados configurados.'
	ELSE
		loRET.SUCESSO 	= .T.
		loRET.DESCRICAO = 'Sucesso'
		loRET.Obj		= loCONNECT
	ENDIF
	
	DO FIMESPERANDO
	
	RETURN(loRET)
ENDFUNC

FUNC NUVEM_UPLOAD
	* MÉTODO PARA FAZER UPLOAD DE ARQUIVOS NO SERVIÇO DE NUVEM
	* SÓ FUNCIONA COM A AWS POR ENQUANTO
	* FUNÇÃO RETORNARÁ SEMPRE UM OBJETO
	
	LPARAMETERS tcARQUIVO
	
	LOCAL lcXMLENVIO, lcXMLRETORNO, lcARQUIVONOME, lcCOMANDO, lcHASHARQ AS String
	STORE '' TO  lcXMLENVIO, lcXMLRETORNO, lcARQUIVONOME, lcCOMANDO, lcHASHARQ
	
	LOCAL lnTAMANHOKB AS Integer
	STORE 0 TO lnTAMANHOKB
	
	* OBJETO DE RETORNO
	LOCAL loRET AS Object
	loRET = CREATEOBJECT('CUSTOM')
	loRET.AddProperty('SUCESSO')
	loRET.AddProperty('DESCRICAO')
	loRET.AddProperty('DLLMENSAGEM')
	loRET.AddProperty('DLLXML')
	loRET.AddProperty('IDENTIFICADOR')
	loRET.AddProperty('LINK')
	loRET.AddProperty('FK_NUVEMUPLOAD')
	loRET.SUCESSO			= .F.
	loRET.DESCRICAO			= ''
	loRET.DLLMENSAGEM		= ''
	loRET.DLLXML			= ''
	loRET.IDENTIFICADOR		= ''
	loRET.LINK				= ''
	loRET.FK_NUVEMUPLOAD	= 0
	
	IF TYPE('tcARQUIVO') <> 'C'
		tcARQUIVO = ''
	ENDIF
		 
	tcARQUIVO = ALLTRIM(tcARQUIVO) 
	
	IF EMPTY(tcARQUIVO)
		loRET.SUCESSO 	= .F.
		loRET.DESCRICAO = 'Arquivo para upload não informado.'
 		RETURN(loRET)
	ENDIF
 
	IF NOT FILE(tcARQUIVO)
		loRET.SUCESSO 	= .F.
		loRET.DESCRICAO = 'Arquivo não encontrado:' + CHR(13) + CHR(10) + tcARQUIVO
 		RETURN(loRET)
	ENDIF
	
	* PEGA SOMENTE O NOME DO ARQUIVO
	lcARQUIVONOME = ALLTRIM(JUSTFNAME(tcARQUIVO))

	* TENTA CRIAR E INSTANCIAR OBJETO DE COENXAO
	loCONNECT = NUVEM_CONNECT()
	
	IF NOT loCONNECT.SUCESSO
		loRET.SUCESSO 		= .F.
		loRET.DESCRICAO		= loCONNECT.DESCRICAO
		loRET.DLLMENSAGEM	= loCONNECT.DLLMENSAGEM
		loRET.DLLXML		= loCONNECT.DLLXML
 		RETURN(loRET)
	
	ENDIF
	
	DO ESPERANDO WITH 'Realizando upload do arquivo...'
	
	* PEGA OBJETO CRIADO NO MÉTODO DE SETUP
	LOCAL loUPLOAD AS Object
	loUPLOAD = loCONNECT.Obj
		
	* XML DE ENVIO
	TEXT TO lcXMLENVIO NOSHOW PRETEXT 7
		<AWSUploadModel xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
			xmlns:xsd="http://www.w3.org/2001/XMLSchema">
			<ArquivoNome>[[ARQUIVONOME]]</ArquivoNome>
			<ArquivoLocal>[[ARQUIVOLOCAL]]</ArquivoLocal>
		</AWSUploadModel>
	ENDTEXT
	lcXMLENVIO = STRTRAN( lcXMLENVIO, '[[ARQUIVONOME]]', lcARQUIVONOME )
	lcXMLENVIO = STRTRAN( lcXMLENVIO, '[[ARQUIVOLOCAL]]', tcARQUIVO )
	
	* FAZ UPDLOAD
	lcXMLRETORNO 		= loUPLOAD.Upload(lcXMLENVIO)
	loRET.DLLXML		= lcXMLRETORNO
	loRET.DLLMENSAGEM	= ALLTRIM(STREXTRACT(lcXMLRETORNO,'<Mensagem>','</Mensagem>'))
	
	IF EMPTY(lcXMLRETORNO) OR UPPER(ALLTRIM(STREXTRACT(lcXMLRETORNO,'<IsErro>','</IsErro>'))) == 'TRUE'
		* ERRO
		loRET.SUCESSO		= .F.
		loRET.DESCRICAO 	= 'Falha ao realizar updload do arquivo. Verifique os dados informados.'
	ELSE
		* SUCESSO
		loRET.SUCESSO 		= .T.
		loRET.DESCRICAO 	= 'Upload realizado com sucesso.'
		loRET.IDENTIFICADOR	= ALLTRIM(STREXTRACT(lcXMLRETORNO,'<Identificador>','</Identificador>'))
		loRET.LINK			= ALLTRIM(STREXTRACT(lcXMLRETORNO,'<UrlAcesso>','</UrlAcesso>'))
		
		* GRAVA LOG DE UPLOAD
		
		* TAMANHO DO ARQUIVO EM KBs
		=ADIR(laARQS,tcARQUIVO)
		lnTAMANHOKB = ROUND(laARQS[1,2]/1024,0) 
		
		* CALCULA HASH DO ARQUIVO (MESMO METODO DA WAW_ARQUIVO)
		* COEMNTADO POIS TEM UM BUG QUE AINDA NÃO DESCOBRIMOS A SOLUÇÃO NA CLASSE myZIP
		*lcHASHARQ = ALLTRIM(STRCONV(goAPLICATIVO.myZIP.HASHFILE(tcARQUIVO), 13))
		
		* ESTRUTURA DA TABELA DE LOG
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT * FROM TS_NUVEMUPLOAD WHERE PK_ID IS NULL
		ENDTEXT
		=PESQUISASQL(lcCOMANDO,'TMPUPLOADLOG')
		
		SELE TMPUPLOADLOG
		APPEND BLANK
		SCATTER NAME loLOG MEMO
			loLOG.DS_NOMEARQUIVO	= lcARQUIVONOME
			loLOG.DS_IDENTIFICADOR	= loRET.IDENTIFICADOR
			loLOG.DS_LINK			= loRET.LINK
			loLOG.DS_HASH			= lcHASHARQ
			loLOG.NR_TAMANHO		= lnTAMANHOKB
		SELE TMPUPLOADLOG
		GATHER NAME loLOG MEMO
		
		loRET.FK_NUVEMUPLOAD = ATUSQL('A','TS_NUVEMUPLOAD')

	ENDIF
	
	DO FIMESPERANDO
	
	RETURN(loRET)
	
ENDFUNC

FUNC NUVEM_DELETE
	* MÉTODO PARA DELETAR ARQUIVOS NO SERVIÇO DE NUVEM
	* SÓ FUNCIONA COM A AWS POR ENQUANTO
	* FUNÇÃO RETORNARÁ SEMPRE UM OBJETO
	
	LPARAMETERS tcIDENTIFICADOR
	* É POSSÍVEL RECEBER O IDENTIFICADOR OU LINK DO ARQUIVO PARA FAZER O DELETE
	
	LOCAL lcXMLENVIO, lcXMLRETORNO, lcARQUIVONOME AS String
	STORE '' TO  lcXMLENVIO, lcXMLRETORNO, lcARQUIVONOME
	
	* OBJETO DE RETORNO
	LOCAL loRET AS Object
	loRET = CREATEOBJECT('CUSTOM')
	loRET.AddProperty('SUCESSO')
	loRET.AddProperty('DESCRICAO')
	loRET.AddProperty('DLLMENSAGEM')
	loRET.AddProperty('DLLXML')
	loRET.SUCESSO		= .F.
	loRET.DESCRICAO		= ''
	loRET.DLLMENSAGEM	= ''
	loRET.DLLXML		= ''

	IF TYPE('tcIDENTIFICADOR') <> 'C'
		tcIDENTIFICADOR = ''
	ENDIF
		
	* FAZ O JUSTFNAME SÓ PARA QUANDO RECEBER O LINK COMO PARÂMETRO
	tcIDENTIFICADOR = ALLTRIM(JUSTFNAME(tcIDENTIFICADOR))
	
	IF EMPTY(tcIDENTIFICADOR)
		loRET.SUCESSO 	= .F.
		loRET.DESCRICAO = 'Identificador para deletar arquivo não informado.'
 		RETURN(loRET)
	ENDIF
 	
	* TENTA CRIAR E INSTANCIAR OBJETO DE COENXAO
	loCONNECT = NUVEM_CONNECT()
	
	IF NOT loCONNECT.SUCESSO
		loRET.SUCESSO 		= .F.
		loRET.DESCRICAO		= loCONNECT.DESCRICAO
		loRET.DLLMENSAGEM	= loCONNECT.DLLMENSAGEM
		loRET.DLLXML		= loCONNECT.DLLXML
 		RETURN(loRET)
	ENDIF
	
	DO ESPERANDO WITH 'Deletando aquivo da nuvem...'

	* PEGA OBJETO CRIADO NO MÉTODO DE SETUP
	LOCAL loDELETE AS Object
	loDELETE = loCONNECT.Obj
		
	* XML DE ENVIO
	TEXT TO lcXMLENVIO NOSHOW PRETEXT 7
		<AWSDeletarModel xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
		    xmlns:xsd="http://www.w3.org/2001/XMLSchema">
			<ArquivoIdentificador>[[IDENTIFICADOR]]</ArquivoIdentificador>
		</AWSDeletarModel>
	ENDTEXT
	lcXMLENVIO = STRTRAN( lcXMLENVIO, '[[IDENTIFICADOR]]', tcIDENTIFICADOR)
	
	* FAZ DELETE
	lcXMLRETORNO 		= loDELETE.Delete(lcXMLENVIO)
	loRET.DLLXML		= lcXMLRETORNO
	loRET.DLLMENSAGEM	= ALLTRIM(STREXTRACT(lcXMLRETORNO,'<Mensagem>','</Mensagem>'))
	
	IF EMPTY(lcXMLRETORNO) OR UPPER(ALLTRIM(STREXTRACT(lcXMLRETORNO,'<IsErro>','</IsErro>'))) == 'TRUE'
		* ERRO
		loRET.SUCESSO		= .F.
		loRET.DESCRICAO 	= 'Falha ao realizar deletar arquivo. Verifique os dados informados.'
	ELSE
		* SUCESSO
		loRET.SUCESSO 		= .T.
		loRET.DESCRICAO 	= 'Upload realizado com sucesso.'
		
		* FALTA ENTEDER SE FAREMOS ALGO NA TABELA DE LOG DE UPLOAD
	ENDIF
	
	DO FIMESPERANDO
	
	RETURN(loRET)

ENDFUNC

FUNC NUVEM_OPEN
	* A CRIAR
ENDFUNC

FUNC DOWNLOADFILE
	LPARAMETERS tcURL, tcFILENAME, tlNAOSOBRESCREVER
	* FUNÇÃO PARA FAZER DOWNLOAD DE ARQUIVOS
	
	* PARÂMETROS:
	* tcURL 			= URL DO ARQUIVO
	* tcFILENAME		= DEVE RECEBER O CAMINHO COMPLETO DO ARQUIVO DE DESTINO
	* tlNAOSOBRESCREVER	= VERIFICA SE ARQUIVO JÁ EXISTE, SE JÁ EXISTIR NÃO SOBRESCREVE
	
	* RETORNO: OBJETO loRET
	* loRET.SUCESSO		= TRUE / FALSE
	* loRET.DESCRICAO	= DETALHES DE SUCESSO OU ERRO
	
	* OBJETO DE RETORNO
	
	LOCAL loRET AS Object
	loRET = CREATEOBJECT('CUSTOM')
	loRET.AddProperty('SUCESSO')
	loRET.AddProperty('DESCRICAO')
	
	IF TYPE('tcURL') <> 'C'
		tcURL = ''
	ENDIF
	
	IF EMPTY(tcURL)
		loRET.SUCESSO	= .F.
		loRET.DESCRICAO	= 'Url para download não informada.'
		RETURN(loRET)
	ENDIF
	
	IF TYPE('tcFILENAME') <> 'C'
		tcFILENAME= ''
	ENDIF
	
	IF EMPTY(tcFILENAME)
		loRET.SUCESSO	= .F.
		loRET.DESCRICAO	= 'Caminho de destino do arquivo não informado.'
		RETURN(loRET)
	ENDIF
	
	IF TYPE('tlNAOSOBRESCREVER') <> 'L'
		tlNAOSOBRESCREVER =.F.
	ENDIF
	
	* VERIFICA SE NÃO É PRA SOBRESCREVER
	IF tlNAOSOBRESCREVER AND FILE(tcFILENAME)
		loRET.SUCESSO	= .F.
		loRET.DESCRICAO	= 'Já existe um arquivo com o mesmo nome do arquivo de destino.'
		RETURN(loRET)
	ENDIF
		
	* VERIFICA SE JÁ EXISTE UM ARQUIVO COM O MESMO NOME E EXLCUI
	IF FILE(tcFILENAME)
		TRY 
			DELETE FILE (tcFILENAME)
		CATCH
			
		ENDTRY
		
		* SE ARQUIVO AINDA EXISTIR É PQ NÃO CONSEGUIU EXCLUIR
		IF FILE(tcFILENAME)
			loRET.SUCESSO	= .F.
			loRET.DESCRICAO	= 'Falha ao exlcuir arquivo com o mesmo nome do arquivo de destino. Verifique se você tem acesso de gravação à pasta informada, se o arquivo já está em uso e tente novamente.'
			RETURN(loRET)
		ENDIF
	ENDIF
	
	* TENTA CRIAR OBJETO PARA DOWNLOAD
	LOCAL loREQUEST AS Object
	llERRO = .F.
	TRY 
		loREQUEST = CREATEOBJECT('MsXml2.XmlHttp')
	CATCH
		llERRO = .T.
	ENDTRY
	
	IF llERRO
		loRET.SUCESSO	= .F.
		loRET.DESCRICAO	= 'Erro ao criar objeto MsXml2.XmlHttp para downlaod.'
		RETURN(loRET)
	ENDIF
	
	* ABRE URL
	loREQUEST.Open('GET',tcURL,.F.)
		
	* FAZ DOWNLOAD
	loREQUEST.Send()
	
	* ESPERA O REQUEST TERMINAR
	DO WHILE loREQUEST.readyState <> 4
		* ESPERA
	ENDDO
		
	* SE DEU CERTO, SALVA ARQUIVO
	IF loREQUEST.Status <> 200
		loRET.SUCESSO	= .F.
		loRET.DESCRICAO	= 'Erro no download do arquivo.'
		RETURN(loRET)
	ENDIF

	lnRET = STRTOFILE(loREQUEST.responseBody,tcFILENAME)
	IF lnRET <= 0
		loRET.SUCESSO	= .F.
		loRET.DESCRICAO	= 'Falha ao gravar o arquivo, verifique se o arquivo já está em uso e se você possuí direitos de gravação na pasta informada.'
	ELSE
		loRET.SUCESSO	= .T.
		loRET.DESCRICAO	= 'Download do arquivo realizado com sucesso.'
	ENDIF
	
	RETURN(loRET)

ENDFUNC

FUNC VETERMOLGPD

	* VERIFICA SE O TERMO DE ACEITE LGPD ESTA HABILITADO PARA SOLICITAR O ACEITE DO USUÁRIO *
	LOCAL lcCOMANDO AS String 
	STORE '' TO lcCOMANDO

	LOCAL lnLGPD AS Integer
	STORE 0 TO lnLGPD
	
	LOCAL llRETORNO AS Logical
	STORE .F. TO llRETORNO 
	
	lnLGPD 		= INT(RETORNASET('LGPD.TERMOACEITE', 'N', 0))
	
	llRETORNO 		= .F.
	llRETURNLGPD	= .F.
	
	* VALIDA SE O TERMO LGPD ESTÁ HABILITADO NO SISTEMA
	IF goAPLICATIVO.LGPD > 0 AND lnLGPD > 0
		* BUSCA O TERMO LGPD
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT
				PK_ID
			FROM PD_TERMO
			WHERE TG_PRIORIDADE = 1
		ENDTEXT
		=PESQUISASQL(lcCOMANDO, 'TMPTERMOLGPD')
		
		SELE TMPTERMOLGPD
		GO TOP
		IF EOF('TMPTERMOLGPD')	
			llRETORNO = .T.
		ENDIF 

		* SE O USUARIO JÁ TIVER ACEITO O TERMO NÃO CHAMA A TELA 
		IF TMPUSU.FK_TERMOACEITE >= TMPTERMOLGPD.PK_ID
			llRETORNO = .F.
		ELSE
				
			* CHAMA A TELA DE ACEITE DO TERMO LGPD, PASSANDO SCATTER DO USUÁRIO E ID DO TERMO PENDENTE POR PARÂMETRO
			LOCAL loUSUARIO AS Object
			SELE TMPUSU
			SCATTER NAME loUSUARIO MEMO
			
			DO FORM SYSTEM_TERMOLGPD WITH loUSUARIO, TMPTERMOLGPD.PK_ID TO llRETURNLGPD
			IF NOT llRETURNLGPD
				llRETORNO = .T.
			ELSE
				llRETORNO = .F.
			ENDIF
			
		ENDIF 	
	ENDIF 
	
	IF USED('TMPTERMOLGPD')
		USE IN TMPTERMOLGPD
	ENDIF 
	
	RETURN(llRETORNO)
ENDFUNC

FUNC ANONIMIZAR
	LPARAMETERS tuPARAM, tcJF AS String 
	* FUNÇÃO CRIADA PARA ANONIMIZAR DADOS, POR DEFAULT SEMPRE ANONIMIZA SE NÃO PASSAR O PARAMETRO tcJF = J
	* 1º PARAMETRO: RECEBE UM VALOR A SER TRATADA NOME, EMAIL, CPF OU CNPJ
	* 2º PARAMETRO: RECEBE POR PARAMETROS J=PESSOA JURÍDICA/F=PESSOA FISÍCA
	* RETORNA UMA STRING 
	
	LOCAL lcRETORNO AS String 
	STORE '' TO lcRETORNO 
		
	IF TYPE('tcJF') <> 'C'
		tcJF = 'F'
	ENDIF 
		
	* PESSOA JURÍDICA RETORNA OS DADOS DIRETO
	IF ALLTRIM(UPPER(tcJF)) == 'J' 
		lcRETORNO = TRANSFORM(tuPARAM)
	ENDIF 
	
	* PESSOA FISÍCA RETORNA OS DADOS ANONIMIZADOS
	IF ALLTRIM(UPPER(tcJF)) == 'F' 
		lcRETORNO = SUBSTR(TRANSFORM(tuPARAM), 1, 3) + '******'
	ENDIF
	
	RETURN(lcRETORNO)
ENDFUNC

FUNC VERIFICARBLOQIP()
	* FUNÇÃO QUE VALIDA BLOQUEI POR IP
	LOCAL USUARIO_IP, IPLIBERADOS, lcMENS AS String 
	STORE '' TO USUARIO_IP, IPLIBERADOS, lcMENS
	
	LOCAL lnBLOQIP AS Integer 
	STORE 0 TO lnBLOQIP 
	
	LOCAL llRETORNO AS Logical
	STORE .F. TO llRETORNO 
	
	lnBLOQIP = INT(RETORNASET('ACESSO.BLOQUEIOIP', 'N', 0))
	
	* CASO BLOQUEIO POR IP ESTEJA DESABILITADO
	IF lnBLOQIP == 0
		RETURN .T.
	ENDIF 
	
	* CASO BLOQUEIO POR IP ESTEJA HABILITADO, BUSCA IPs PERMITIDOS
	IF lnBLOQIP == 1 
		* PEGA IP DO USUÁRIO
		USUARIO_IP	= ALLTRIM(GETMEUIP())

		IF EMPTY(USUARIO_IP)
			RETURN .F.
		ENDIF 
		
		IPLIBERADOS = ALLTRIM(RETORNASET('ACESSO.IPLIBERADOS', 'C', 0))
		
		IF NOT EMPTY(IPLIBERADOS)
			IPLIBERADOS = ';' + ALLTRIM(RETORNASET('ACESSO.IPLIBERADOS', 'C', 0)) + ';'

			FOR lnXI = 1 TO OCCURS(';', IPLIBERADOS) 
				IF NOT EMPTY(ALLTRIM(UPPER(STREXTRACT(IPLIBERADOS, ';', ';', lnXI)))) 
					
					IF EMPTY(ALLTRIM(UPPER(STREXTRACT(IPLIBERADOS, ';', ';', lnXI)))) 
						llRETORNO = .F.
						LOOP 
					ENDIF 
					
	 				IF ALLTRIM(UPPER(STREXTRACT(IPLIBERADOS, ';', ';', lnXI))) $ ALLTRIM(UPPER(ALLTRIM(USUARIO_IP)))
						llRETORNO = .T.
						EXIT
					ELSE
						llRETORNO = .F.
					ENDIF  
				ENDIF 
			ENDFOR
		ENDIF

		SELE TMPUSU
		* CHECAR SE O USUÁRIO TEM PERMISSÃO ESPECÍFICA (TG_IPRESTRICAO) E SE SEM, CHECAR SE O IP ESTÁ LIBERADO PARA O USUÁRIO (DS_IPRESTRICAO)
		IF TMPUSU.TG_IPRESTRICAO == 1 AND NOT EMPTY(ALLTRIM(TMPUSU.DS_IPRESTRICAO))
			IPLIBERADOS = ';' + ALLTRIM(TMPUSU.DS_IPRESTRICAO) + ';'
			
			FOR lnJI = 1 TO OCCURS(';', IPLIBERADOS)
				IF NOT EMPTY(ALLTRIM(UPPER(STREXTRACT(IPLIBERADOS, ';', ';', lnJI))))
					
					IF EMPTY(ALLTRIM(UPPER(STREXTRACT(IPLIBERADOS, ';', ';', lnJI)))) 
						llRETORNO = .F.
						LOOP 
					ENDIF 
					
					* VALIDA SE O IP DO USUÁRIO ESTA NO DS_IPRESTRICAO
					* VERIFICA SE POSSUE ACESSO IRRESTRITO PARA QUALQUER IP
					IF ALLTRIM(UPPER(STREXTRACT(IPLIBERADOS, ';', ';', lnJI))) $ ALLTRIM(UPPER(ALLTRIM(USUARIO_IP))) OR ALLTRIM(UPPER(STREXTRACT(IPLIBERADOS, ';', ';', lnJI))) $ '*'
						llRETORNO = .T.
						EXIT
					ELSE
						llRETORNO = .F.
					ENDIF  
				ENDIF 
			ENDFOR
		ENDIF 
	ENDIF
	
	IF NOT llRETORNO	
		TEXT TO lcMENS NOSHOW PRETEXT 7
			ACESSO BLOQUEADO POR LOCALIZAÇÃO

			Você não pode acessar o sistema a partir do seu endereço atual.
			Seu IP: [[IP]]
		ENDTEXT
		lcMENS = STRTRAN(lcMENS, '[[IP]]', USUARIO_IP)
		
		DO MENS WITH lcMENS		
	ENDIF 
	
	RETURN llRETORNO 
ENDFUNC 

FUNC GETMEUIP
	* FUNÇÃO CRIADA PARA BUSCAR O IP DO USUÁRIO
	LOCAL lcRETORNO AS String 
	STORE '' TO lcRETORNO
	
	LOCAL loREQUEST AS Object
	
	LOCAL llERRO AS LOGICAL
	STORE .F. TO llERRO
		
	TRY 
		loREQUEST = CREATEOBJECT("Microsoft.XMLHTTP")
		llERRO = .F.
	CATCH
		llERRO = .T.
	ENDTRY
 
	IF VARTYPE(loREQUEST) <> 'O'
		TRY 
			loREQUEST = CREATEOBJECT('MSXML2.ServerXMLHTTP.4.0')
			llERRO = .F.
		CATCH
			llERRO = .T.
		ENDTRY
	ENDIF
	
	IF llERRO
		RETURN('')
	ENDIF
	
	* CONSULTA NO SITE DA PWI PRIMEIRO	
	loREQUEST.OPEN('GET', 'https://www.pwi.com.br/meuip', .F.)
	loREQUEST.Send()
	
	lcRETORNO = ALLTRIM(STRTRAN(loREQUEST.ResponseText, '"', ''))
	
	* CASO O STATUS SEJA 200 E O RETORNO NÃO ESTEJA EM BRANCO RETORNA O IP
	IF loREQUEST.Status = 200 AND NOT EMPTY(ALLTRIM(loREQUEST.ResponseText))
		RELEASE loREQUEST
		RETURN lcRETORNO 
	ENDIF 
	
	* CONSULTA SEGUNDO LINK NO CANAL LGPD
	loREQUEST.OPEN('GET', 'https://lgpd-canal.com.br/meuip', .F.)
	loREQUEST.Send()
	
	lcRETORNO = ALLTRIM(STRTRAN(loREQUEST.ResponseText, '"', ''))
	
	* CASO O STATUS SEJA 200 E O RETORNO NÃO ESTEJA EM BRANCO RETORNA O IP
	IF loREQUEST.Status = 200 AND NOT EMPTY(ALLTRIM(loREQUEST.ResponseText)) && SUCESSO
		RELEASE loREQUEST
		RETURN lcRETORNO 
	ENDIF 
ENDFUNC

FUNC QRCODE_GERAR
* GERADOR DE QRCODE (ARQUIVO IMAGEM)
PARAMETERS tcTEXTO, tcFILE, tnSIZE
	*!*	tcTEXTO = TEXTO PARA COLOCAR NO QR CODE
	*!*	tcFILE = FILE NAME DA IMAGEM DO QR CODE A SER GERADO (OPCIONAL)
	*!*	tnSIZE = PIXELS (DE 2 A 12) DEFAULT = 4 (OPCIONAL)
			*!*	2 = 66 X 66
			*!*	3 = 99 X 99
			*!*	4 = 132 X 132
			*!*	5 = 165 X 165
			*!*	6 = 198 X 198
			*!*	7 = 231 X 231
			*!*	8 = 264 X 264
			*!*	9 = 297 X 297
			*!*	10 = 330 X 330
			*!*	11 = 363 X 363
			*!*	12 = 396 X 396

	IF TYPE('tcTEXTO') <> 'C' OR EMPTY(tcTEXTO)
		RETURN(.F.)
	ENDIF
	
	IF TYPE('tnSIZE') <> 'N' OR EMPTY(tnSIZE)
		tnSIZE = 4 && DEFAULT
	ENDIF
	
	LOCAL lcRETORNO AS String
	
	IF EMPTY(tcFILE)
		tcFILE = 'QR' + RIGHT(SYS(2015), 6)
	ENDIF
	
	IF OCCURS('\', tcFILE) = 0
		tcFILE = GETENV("TEMP") + tcFILE
	ENDIF
	lcRETORNO = tcFILE
	
	LOCAL lnTYPE AS Integer
	lnTYPE = 2
	IF UPPER(JUSTEXT(tcFILE))='JPG'
		lnTYPE = 1
	ENDIF
	IF UPPER(JUSTEXT(tcFILE))='BMP'
		lnTYPE = 0
	ENDIF
	
	TRY 
		* DECLARANDO DLL E FUNCOES
		DECLARE INTEGER GenerateFile IN BARCODELIBRARY.DLL STRING cDATA, STRING cFILENAME
		DECLARE INTEGER SetConfiguration IN BARCODELIBRARY.DLL INTEGER nSIZE, INTEGER nIMAGETYPE
	
		SetConfiguration(tnSIZE, lnTYPE)
		GenerateFile(tcTEXTO, tcFILE)
	
		CLEAR DLLS SetConfiguration, GenerateFile
	CATCH
		lcRETORNO = ''
	ENDTRY
	
	* RETORNO: SE OK=filename, NãO OK=vazio
	RETURN(lcRETORNO)
ENDPROC

FUNC ABREVIARNOME
	* RETORNA STRING ABREVIADA MANTENDO PRIMWEIRO E ULTIMO NOME
	LPARAMETERS tcIN, tnSIZE

	IF TYPE('tnSIZE')<>'N'
		tnSIZE = 40
	ENDIF

	LOCAL lcOUT AS String
	LOCAL lnI AS Integer

	lcOUT = ALLTRIM(UPPER(ALLTRIM(tcIN)))
	IF LEN(lcOUT)<=tnSIZE
		RETURN(lcOUT)
	ENDIF

	* ELIMINANDO LIXO DO MEIO DA STRING, SE HOUVER
	lcOUT = CHRTRAN( lcOUT, '-/\=[]<>,:;', '' )
	lcOUT = STRTRAN( lcOUT, '.',' ')
	lcOUT = STRTRAN( lcOUT, ' DE ',' ')
	lcOUT = STRTRAN( lcOUT, ' de ',' ')
	lcOUT = STRTRAN( lcOUT, ' DA ',' ')
	lcOUT = STRTRAN( lcOUT, ' da ',' ')
	lcOUT = STRTRAN( lcOUT, ' DO ',' ')
	lcOUT = STRTRAN( lcOUT, ' do ',' ')
	lcOUT = STRTRAN( lcOUT, '  ',' ')
	lcOUT = STRTRAN( lcOUT, '  ',' ')
	lcOUT = STRTRAN( lcOUT, '  ',' ')
	lcOUT = ALLTRIM( lcOUT )
	IF LEN(lcOUT)<=tnSIZE
		RETURN(lcOUT)
	ENDIF

	* ABREVIANDO NOMES DO MEIO
	LOCAL lnQE, lnOCO, lnINI, lnFIN AS INTEGER
	lnQE = OCCURS(' ',lcOUT)
	lnINI = RAT(' ',lcOUT)
	lnFIN = AT(' ',lcOUT)

	* ABREVIAR OS NOMES DO MEIO E MANTER OS DAS PONTAS
	LOCAL lnNOME1, lcNOME2, lcMEIO, lcABREVIADO, lcLETRA, lcULTLET AS STRING
	lcNOME1 = ALLTRIM(SUBSTR(lcOUT, 1, lnFIN))
	lcNOME2 = ALLTRIM(SUBSTR(lcOUT, lnINI))
	lcMEIO  = ' '+ALLTRIM(SUBSTR(lcOUT, lnFIN, lnINI-lnFIN))

	lcABREVIADO = ALLTRIM(lcNOME1)+' '+ALLTRIM(lcNOME2)
	IF LEN(lcABREVIADO) >= tnSIZE - 3
		* NÃO TEM O QUE ABREVIAR, SÓ NOME E SOBRENOME
		lcOUT = LEFT(lcABREVIADO, tnSIZE)
		RETURN(lcOUT)
	ENDIF

	LOCAL lnABREVIANDO, lnCONTADEL, lnOBJETIVO AS INTEGER
	IF lnQE <= 1
		* NÃO HÁ O QUE ABREVIAR, SÓ TRUNCAR
	ELSE
		lcULTLET = ''
		lcABREVIADO = ''
		lnABREVIANDO = 1
		lnCONTADEL = 0
		lnOBJETIVO = LEN(lcOUT) - tnSIZE
		
		FOR lnOCO = LEN(lcMEIO) TO 1 STEP -1
			lcLETRA = SUBSTR(lcMEIO, lnOCO, 1)
			IF lnABREVIANDO=0
				* NÃO PRECISA MAIS ABREVIAR (OBJETIVO ATINGIDO)
				lcABREVIADO = lcLETRA + lcABREVIADO
				LOOP
			ENDIF
			IF lcLETRA = ' '
				lcABREVIADO = ' ' + lcULTLET + lcABREVIADO
				lcULTLET = ''
				IF lnCONTADEL >= lnOBJETIVO
					lnABREVIANDO = 0
				ENDIF
				LOOP
			ENDIF
			* CONTA LETRA REMOVIDA
			lnCONTADEL = lnCONTADEL + 1
			lcULTLET = lcLETRA
		ENDFOR
		lcOUT = lcNOME1 + ' ' + ALLTRIM(lcABREVIADO) + ' ' + lcNOME2
	ENDIF

	lcOUT = LEFT(lcOUT, tnSIZE)
	RETURN(lcOUT)

ENDFUNC

FUNC HASHMD5
	* FUNÇÃO PARA CRIAR HASH MD5 DE UMA STRING
	LPARAMETERS tcSTRING
	
	IF TYPE('tcSTRING') <> 'C'
		tcSTRING = ''
	ENDIF
	
	goAPLICATIVO.myZIP.INIT()
	goAPLICATIVO.myZIP.OPENLIB('VFPENCRYPTION.FLL')
	
	RETURN(STRCONV(goAPLICATIVO.MYZIP.HASH(STRCONV(tcSTRING,9)),15))

ENDFUNC

DEFINE CLASS EDITOR_HTML AS Custom
	PATHTEMP		 	= ''
	ARQUIVOS			= .NULL.
	CARREGAR_ERRO		= .F.
	
	PROC Init
		* Cada editor carregado deve possuir a propria pasta de editor para evitar problemas de edição de arquivo
		LOCAL lcPATHTEMP AS String
		STORE '' TO lcPATHTEMP
		lcPATHTEMP = goAPLICATIVO.PATHTEMP
		lcPATHTEMP = lcPATHTEMP + 'EDITOR_HTML'
		lcPATHTEMP = lcPATHTEMP + SYS(2015)
		lcPATHTEMP = ADDBS(lcPATHTEMP)
		THIS.PATHTEMP = lcPATHTEMP
		
		THIS.ARQUIVOS = CREATEOBJECT('COLLECTION')
		THIS.ARQUIVOS.Add('codemirror.css')
		THIS.ARQUIVOS.Add('dracula.css')
		THIS.ARQUIVOS.Add('show-hint.css')
		THIS.ARQUIVOS.Add('editor_html.css')
	
		THIS.ARQUIVOS.Add('codemirror.js')
		THIS.ARQUIVOS.Add('show-hint.js')
		THIS.ARQUIVOS.Add('css.js')
		THIS.ARQUIVOS.Add('css-hint.js')
		THIS.ARQUIVOS.Add('closebrackets.js')
		THIS.ARQUIVOS.Add('formatting.js')
		THIS.ARQUIVOS.Add('xml.js')
		THIS.ARQUIVOS.Add('editor_html.js')
		THIS.ARQUIVOS.Add('editor_css.js')
	ENDPROC
	
	FUNC Iniciar
		LOCAL loFSO	AS Scripting.FileSystemObject
		LOCAL loPASTA AS Scripting.Folder
		STORE .NULL. TO loFSO, loPASTA
		loFSO = CREATEOBJECT('Scripting.FileSystemObject')
		
		IF NOT loFSO.FolderExists(THIS.PATHTEMP)
			loFSO.CreateFolder(THIS.PATHTEMP)
		ELSE
			* Limpando os arquivos da pasta
			loPASTA = loFSO.GetFolder(THIS.PATHTEMP)
			FOR EACH loFILE AS Scripting.File IN loPASTA.Files
				TRY 
					loFILE.Delete()
				CATCH
				ENDTRY
			ENDFOR
		ENDIF
		
		IF NOT THIS.usBAIXAR_ARQUIVOS()
			MENS('Falha ao copiar arquivos do sistema de edição.')
			RETURN .F.
		ENDIF
	ENDFUNC
	
	FUNC usBAIXAR_ARQUIVOS
		LOCAL loFSO	AS Scripting.FileSystemObject
		LOCAL loFile AS Scripting.File
		STORE .NULL. TO loFSO, loFile
		loFSO = CREATEOBJECT('Scripting.FileSystemObject')
		LOCAL lcARQUIVO, lcHASH AS String
		STORE '' TO lcARQUIVO, lcHASH
		ESPERANDO('Baixando arquivos do editor...')
		FOR EACH lcARQUIVO IN THIS.ARQUIVOS
			lcHASH = THIS.usBUSCAR_ARQUIVO_BANCO(JUSTSTEM(lcARQUIVO), JUSTEXT(lcARQUIVO))
			IF NOT EMPTY(lcHASH)
				loFile = loFSO.CreateTextFile(THIS.PATHTEMP + ALLTRIM(lcARQUIVO), .T.)
				loFile.Write(lcHASH)
				loFile.Close()
			ELSE
				THIS.CARREGAR_ERRO = .T.
			ENDIF
		ENDFOR
		FIMESPERANDO()
	ENDFUNC
	
	FUNC usBUSCAR_ARQUIVO_BANCO
	LPARAMETERS tcNOME_ARQUIVO AS String, tcEXTENSAO AS String
		IF NOT VARTYPE(tcNOME_ARQUIVO) == 'C'
			tcNOME_ARQUIVO	= ''
		ENDIF
		IF NOT VARTYPE(tcEXTENSAO) == 'C'
			tcEXTENSAO	= ''
		ENDIF
		IF EMPTY(tcNOME_ARQUIVO) OR EMPTY(tcEXTENSAO)
			RETURN ''
		ENDIF
		
		LOCAL lcCOMANDO, lcARQUIVO AS String
		STORE '' TO lcCOMANDO, lcARQUIVO
		* Procura a imagem
		TEXT TO lcCOMANDO NOSHOW PRETEXT 7
			SELECT
				COALESCE(HX_ARQUIVO, '') AS HX_ARQUIVO
			FROM TS_EDITORHTML
			WHERE
				DS_NOMEARQUIVO	= [[DS_NOMEARQUIVO]]
			AND DS_EXTENSAO		= [[DS_EXTENSAO]]
		ENDTEXT
		lcCOMANDO	= STRTRAN(lcCOMANDO, '[[DS_NOMEARQUIVO]]'	, XX(tcNOME_ARQUIVO))
		lcCOMANDO	= STRTRAN(lcCOMANDO, '[[DS_EXTENSAO]]'		, XX(tcEXTENSAO))
		PESQUISASQL(lcCOMANDO, '_TMPARQUIVO')
		SELE _TMPARQUIVO
		GO TOP
		
		* Converte o Hash
		lcARQUIVO = ALLTRIM(_TMPARQUIVO.HX_ARQUIVO)
		lcARQUIVO = STRCONV(lcARQUIVO, 16)
		
		IF USED('_TMPARQUIVO')
			USE IN _TMPARQUIVO
		ENDIF

		RETURN lcARQUIVO
	ENDFUNC
	
	PROC APAGAR_PASTA_TEMPORARIA
		LOCAL loFSO	AS Scripting.FileSystemObject
		LOCAL loPASTA AS Scripting.File
		STORE .NULL. TO loFSO, loPASTA 
		loFSO = CREATEOBJECT('Scripting.FileSystemObject')
		
		IF loFSO.FolderExists(THIS.PATHTEMP)
			loPASTA = loFSO.GetFolder(THIS.PATHTEMP)
			TRY
				loPASTA.Delete(.T.)
			CATCH
			ENDTRY
		ENDIF
	ENDPROC
ENDDEFINE

FUNC VERIFCAMPOSSIGILOSOS
	LPARAMETERS tcCURSOR
	
	* VERIFICA OS CAMPOS SIGILOSOS EXISTEM NO CURSOR
	LOCAL lcDADOS_SIGILOSOS, lcCAMPO AS String
	LOCAL lnQTCAMPOS, lnCAMPOSLGPD, lnRETORNO AS Integer
	
	STORE 1 TO lnRETORNO
	
	* CAMPOS SIGILOSOS
	lcDADOS_SIGILOSOS	= goAPLICATIVO.CAMPOSLGPD
	lcDADOS_SIGILOSOS	= STRTRAN(lcDADOS_SIGILOSOS, ',', CHR(13))
	lnQTCAMPOS			= MEMLINES(lcDADOS_SIGILOSOS)
	
	* VERIFICANDO O CURSOR
	FOR lnCAMPOSLGPD = 1 TO lnQTCAMPOS
		IF EMPTY(ALLTRIM(MLINE(lcDADOS_SIGILOSOS, lnCAMPOSLGPD)))
			LOOP
		ENDIF
		
		lcCAMPO = tcCURSOR + '.' + MLINE(lcDADOS_SIGILOSOS, lnCAMPOSLGPD)
		IF TYPE(lcCAMPO) != "U"
			* CURSOR COM DADOS SIGILOSOS
			lnRETORNO = 2
			EXIT
		ENDIF
	ENDFOR
	RETURN lnRETORNO
ENDFUNC