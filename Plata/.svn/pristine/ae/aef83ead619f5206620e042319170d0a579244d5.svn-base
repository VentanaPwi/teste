* LAUNCH.PRG - PROGRAMA PRINCIPLA DO LAUNCH DO VOLPE
****************************************************
PARAMETERS tcPARAMEXE, tcP1, tcP2, tcP3, tcP4, tcP5, tcP6, tcP7, tcP8, tcP9
	IF TYPE('tcPARAMEXE')<>'C'
		tcPARAMEXE = ''
	ENDIF
	tcPARAMEXE = ALLTRIM(UPPER(tcPARAMEXE))+';'

	SET TALK OFF
	SET ESCAPE OFF
	SET EXCL OFF
	CLOSE ALL
	SET RESOURCE OFF
	SQLSETPROP(0,"DispLogin",3)
	
	* TRATAMENTO DE ERROS
	IF '\TESTES' $ CURDIR()
		ON KEY LABEL CTRL+F2 ACTIVATE WINDOW COMMAND
		SET STATUS BAR ON
	ELSE
		SET RESOURCE OFF
		ON ERROR DO ROTERRO WITH ERROR(),MESSAGE(),PROGRAM(),LINENO()
		ON SHUTDOWN QUIT
		SET STATUS BAR OFF
	ENDIF
	
	PUBLIC goAPLICATIVO,gOCONEXAO AS Object
	PUBLIC goZIP AS ZIPCLASS OF ZIPCLASS.VCX
	
	LOCAL llERROR AS Boolean
	
	STORE .F. TO llERROR

	goCONEXAO	= CREATEOBJECT('CONECTADB')
	goAPLICATIVO= CREATEOBJECT('APLICATIVO')
	goZIP		= NEWOBJECT('ZIPCLASS','ZIPCLASS.VCX')
	
	* Pasta temp
	IF NOT CRIATEMPDIR()
		RETURN .F.
	ENDIF
	
	* Arquivo de bloqueio de sistema
	LOCAL lcEXE, lcBLOQ AS STRING
	lcBLOQ = 'TRAVADO.SIT'
	IF FILE(lcBLOQ)
		DO PROGTRAVADO
		RETURN
	ENDIF
	
	* Carregando arquivo de configuração
	LOCAL lcFILE,lcCONTEUDO as String
	LOCAL llERRO AS Boolean
	
	STORE '' TO lcFILE,lcCONTEUDO
	STORE .F. TO llERRO
	lcFILE = FULLPATH('START.CFG' )
	
	IF NOT FILE(lcFILE)
		MESSAGEBOX('Arquivo de configuração não encontrado' + CHR(13)+CHR(10)+CHR(10)+'Path: ' + lcFILE,48,'ERRO')
		RETURN(.F.)
	ENDIF
	TRY
		lcCONTEUDO = FILETOSTR(lcFILE)
		llERRO	= .F.
	CATCH
		llERRO	= .T.
	ENDTRY
	IF llERRO
		MESSAGEBOX('Erro ao abrir arquivo de configuração' + CHR(13)+CHR(10)+CHR(10)+'Path: ' + lcFILE,48,'ERRO')
		RETURN .F.
	ENDIF
	
	IF EMPTY(lcCONTEUDO)
		DO MENS WITH 'Arquivo de configuração está em branco.'
		RETURN .F.
	ELSE
		lcCONTEUDO 	= WAW_DECRIPTAR(lcCONTEUDO)
		IF EMPTY(lcCONTEUDO)	&& Se estiver em branco quer dizer que ocorreu um erro ao decriptar o arquivo
			DO MENS WITH 'Não foi possível ler arquivo de configuração.'
			RETURN .F.
		ENDIF
	ENDIF
	goCONEXAO.CONNECTIONSTRING	= STREXTRACT(lcCONTEUDO,'<DATABASE>','</DATABASE>',1,1)
	goAPLICATIVO.PATHLOCAL		= ADDBS(STREXTRACT(lcCONTEUDO,'<PATHLOCAL>','</PATHLOCAL>',1,1)) + ADDBS(STREXTRACT(lcCONTEUDO,'<NAME>','</NAME>',1,1))
	
	* Criando pasta principal do sistema
	IF NOT DIRECTORY(goAPLICATIVO.PATHLOCAL)
		STORE .F. TO llERROR
		TRY
			MKDIR(goAPLICATIVO.PATHLOCAL)
			llERROR	= .F.
		CATCH
			llERROR	= .T.
		ENDTRY
		
		IF llERROR
			DO ROTERRO WITH ERROR(),MESSAGE(),PROGRAM(),LINENO(),'Erro ao criar pasta do sistema.'+CHR(13)+CHR(10)+CHR(10)+'Pasta local: ' + goAPLICATIVO.PATHLOCAL
			RETURN .f.
		ENDIF
	ENDIF

	DO FORM SPLASH
	
	DO ENCERRAR
RETURN

PROC CRIATEMPDIR
****************
* CRIA PASTA SEPARADA DE ARQ.TEMPORARIOS
	LOCAL lcPASTA AS STRING
	lcPASTA = goAPLICATIVO.PATHTEMP
	IF ADIR(laDIR,lcPASTA,'DHS')=0
		TRY
			MD (lcPASTA)
		CATCH
			DO MENS WITH 'Erro de acesso: Falha para gravar/criar em pasta de arquivos temporários.'+CHR(13)+CHR(10)+;
			'Verifique seus priviégios para gravar dados neste computador (sem acesso na pasta de temporários)'+CHR(13)+CHR(10)+;
			lcPASTA
			CLOSE ALL
			CANCEL
		ENDTRY
	ENDIF
RETURN

FUNC TEMPFILE
*************
LPARAMETERS tcEXTENSAO
	IF TYPE('tcEXTENSAO')<>'C'
		tcEXTENSAO = 'TMP'
	ENDIF
	LOCAL lcCPOOUT AS String
	lcCPOOUT = goAPLICATIVO.PATHTEMP+SYS(2015)+'.'+tcEXTENSAO
RETURN(lcCPOOUT)

PROC ROTERRO
************
PARAMETERS tnMYERRO, tcMYMESS, tcMYPROG, tnMYLINH,tcMSGPADRAO
	IF TYPE('tcMSGPADRAO') <> 'C'
		tcMSGPADRAO = ''
	ENDIF
	IF EMPTY(tcMSGPADRAO)
		tcMSGPADRAO	= 'Ocorreu uma falha para iniciar o seu aplicativo e ele terá que ser encerrado! Anote a mensagem de erro e entre em contato com o suporte técnico do seu software.'
	ENDIF
	
	LOCAL lcMENSAGEM AS String 
	TEXT TO lcMENSAGEM NOSHOW PRETEXT 3
		[[MSGPADRAO]]
	
		ERRO:		[[MYERRO]]
		MENSAGEM:	[[MYMESS]]
		LINHA:		[[MYLINE]]
	ENDTEXT
* 	ROTINA:		[[MYPROGRAM]]
	lcMENSAGEM 	= STRTRAN(lcMENSAGEM,'[[MSGPADRAO]]',tcMSGPADRAO)
	lcMENSAGEM 	= STRTRAN(lcMENSAGEM,'[[MYERRO]]',ALLTRIM(STR(tnMYERRO)))
	lcMENSAGEM 	= STRTRAN(lcMENSAGEM,'[[MYMESS]]',tcMYMESS)
	lcMENSAGEM 	= STRTRAN(lcMENSAGEM,'[[MYPROGRAM]]',tcMYPROG)
	lcMENSAGEM 	= STRTRAN(lcMENSAGEM,'[[MYLINE]]',ALLTRIM(STR(tnMYLINH)))
	
	=MESSAGEBOX(lcMENSAGEM, 'ERRO',16)
	CANCEL
RETURN

PROC STARTAFILE
***************
LPARAMETERS tcARQUIVO AS String, tcPARAMETROS AS STRING
	IF TYPE('tcARQUIVO') <> 'C'
		tcARQUIVO = ''	
	ENDIF
	IF EMPTY(tcARQUIVO)
		RETURN
	ENDIF
	IF NOT FILE(tcARQUIVO)
		MESSAGEBOX( 'EXECUTAVEL NÃO ENCONTRADO: '+tcARQUIVO, 0, 'AVISO')
		RETURN
	ENDIF
	
	DECLARE LONG ShellExecute IN "shell32.dll" ;
		LONG HWND, STRING lpszOp, ;
		STRING lpszFile, STRING lpszParams, ;
		STRING lpszDir, LONG nShowCmd

	SHELLEXECUTE( 0, 'Open', FULLPATH(tcARQUIVO), tcPARAMETROS, 0, 1)
RETURN

PROC PROGTRAVADO
****************
LPARAMETERS tcBLOQ
	LOCAL lcTRAVADO1, lcTRAVADO2 AS String, lnALCA AS Integer
	lcTRAVADO1 = 'ACESSO BLOQUEADO TEMPORARIAMENTE!'+CHR(13)+;
				'O SISTEMA ESTÁ EM MANUTENÇÃO TÉCNICA.'+CHR(13)+CHR(13)
	lcTRAVADO2 = 'AGUARDE ATÉ QUE O ACESSO SEJA REESTABELECIDO.'
	TRY
		lcTRAVADO2 = FILETOSTR(tcBLOQ)
	CATCH
	ENDTRY
	=MESSAGEBOX(lcTRAVADO1+lcTRAVADO2,48,'VOLPE')
RETURN

PROC CONECTAR
*************
	LOCAL lcCONTEUDO,lcFILE AS String 
	LOCAL lnALCA AS Integer 
	
	lnALCA		= SQLSTRINGCONNECT(goCONEXAO.CONNECTIONSTRING)

	* Limpando string de conexão por motivo de segurança
	goCONEXAO.CONNECTIONSTRING	= ''
	
    IF lnALCA < 0
    	DO ROTERRO WITH ERROR(),MESSAGE(),PROGRAM(),LINENO(),'Erro ao conectar ao banco de dados.'
    	RETURN(.F.)
    ENDIF
    
    GOCONEXAO.ALCA = lnALCA
    
	RETURN
ENDPROC

PROC ENCERRAR
*************
LPARAMETERS tnPERGUNTAR
* PERGUNTAR SE FINALIZA OU NÃO
	IF TYPE('tnPERGUNTAR')<>'N'
		tnPERGUNTAR=0
	ENDIF

	IF tnPERGUNTAR= 1
		LOCAL lnRESP AS LOGICAL
		lnRESP = SIMOUNAO('Deseja encerrar o aplicativo?','Sair',1)
		IF NOT lnRESP
			RETURN
		ENDIF
	ENDIF
	ON SHUTDOWN
	IF TYPE('goCONEXAO')='O'
		* MATA CONEXÃO
		TRY 
			goCONEXAO.DESCONECTAR()
		CATCH
			CANCEL
		ENDTRY
	ENDIF
	IF TYPE('goAPLICATIVO')='O'
		* DESLIGA TODOS OS FORMS
		TRY 
			goAPLICATIVO.KILLFORMS()
			goAPLICATIVO.UNLOAD
		CATCH
			CANCEL
		ENDTRY
	ENDIF
	CLEAR WINDOWS
	CLOSE DATA
	SET PROCEDURE TO
	CLEAR EVENTS
*	CLEAR PROGRAM
	IF TYPE('goAPLICATIVO')='O'
		IF goAPLICATIVO.TESTE = .T.
			SET SYSMENU TO DEFA
			CLEAR CLASSLIB PWICLASS
			CLEAR CLASSLIB RESCLASS
			IF tnPERGUNTAR<>0
				TRY 
					CLEAR ALL
				CATCH
				ENDTRY
			ENDIF
		ENDIF
	ENDIF
	SET PATH TO
	CANCEL
	
	RETURN
ENDPROC


FUNC PESQUISASQL
****************
PARAMETERS tcSINTAXE, tcARQUIVO
	IF USED(tcARQUIVO)
		USE IN &tcARQUIVO
	ENDIF
	LOCAL lnQTDDATAS, lnXI, lnOCO AS Integer
	LOCAL lcAUX, lcLETRA, lcTAG1, lcTAG2 AS String
	STORE 0 TO lnQTDDATAS, lnXI, lnOCO
	STORE '' TO lcAUX, lcLETRA, lcTAG1, lcTAG2

	lnOCO = AT(CHR(9),tcSINTAXE)
	IF lnOCO > 0
		DO MENS WITH '<TAB> no meio da sintaxe SQL'+CHR(13)+;
					SUBSTR(tcSINTAXE,MAX(1,lnOCO-15),30)
	ENDIF

	* TRATAMENTO DE CAMPOS DATETIME
	IF 'TO_CHART(' $ tcSINTAXE
		lcTAG1 = 'TO_CHART('
		lcTAG2 = ')TO_CHART'
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS'
				lcNEW1 = "DATE_FORMAT("
				lcNEW2 = ",'%D/%m/%Y %H:%I:%S')"
			CASE goCONEXAO.BANCO = 'POS'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY HH24:MI:SS')"
			CASE goCONEXAO.BANCO = 'ORA'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY HH24:MI:SS')"
			CASE goCONEXAO.BANCO = 'DBC'
				lcNEW1 = 'TTOC('
				lcNEW2 = ")"
			OTHERWISE
				lcNEW1 = 'CONVERT(VARCHAR(19),'
				lcNEW2 = ',120)'
		ENDCASE
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG1, lcNEW1 )
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG2, lcNEW2 )
	ENDIF

	* TRATAMENTO DE CAMPOS DATA
	IF 'TO_CHAR(' $ tcSINTAXE
		lcTAG1 = 'TO_CHAR('
		lcTAG2 = ')TO_CHAR'
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS'
				lcNEW1 = 'DATE_FORMAT('
				lcNEW2 = ",'%D/%m/%Y')"
			CASE goCONEXAO.BANCO = 'POS'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY')"
			CASE goCONEXAO.BANCO = 'ORA'
				lcNEW1 = 'TO_CHAR('
				lcNEW2 = ",'DD/MM/YYYY')"
			CASE goCONEXAO.BANCO = 'DBC'
				lcNEW1 = 'DTOC('
				lcNEW2 = ")"
			OTHERWISE
				lcNEW1 = 'CONVERT(VARCHAR(10),'
				lcNEW2 = ',103)'
		ENDCASE
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG1, lcNEW1 )
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG2, lcNEW2 )
	ENDIF

	* CAMPOS DIA DA SEMANA
	IF 'FNOMDIA(' $ tcSINTAXE
		STORE '' TO lcNEW1, lcNEW2
		lcTAG1 = 'FNOMDIA('
		lcTAG2 = ')FNOMDIA'
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS'
				**
			CASE goCONEXAO.BANCO = 'POS'
				**
			CASE goCONEXAO.BANCO = 'ORA'
				**
			CASE goCONEXAO.BANCO = 'DBC'
				**
			OTHERWISE
				lcNEW1 = "SUBSTR('DomingoSegundaTerça  Quarta Quinta Sexta  Sábado ',(DATEPART(dw,"
				lcNEW2 = ')-1)*7+1,7)'
		ENDCASE
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG1, lcNEW1 )
		tcSINTAXE = STRTRAN(tcSINTAXE, lcTAG2, lcNEW2 )
	ENDIF

	* TRATAMENTO DE CAMPOS NULOS
	IF 'ISNULL(' $ tcSINTAXE
		DO CASE
			CASE goCONEXAO.BANCO = 'MYS' &&&  LINHA ALTERADA  &&&
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','COALESCE(')
			CASE goCONEXAO.BANCO = 'POS'
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','COALESCE(')
			CASE goCONEXAO.BANCO = 'ORA'
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','NVL(')
			CASE goCONEXAO.BANCO = 'DBC'
				tcSINTAXE = STRTRAN(tcSINTAXE,'ISNULL(','NVL(')
			OTHERWISE
				* NÃO PRECISA FAZER (PADRÃO MS-SQL SERVER)
		ENDCASE
	ENDIF

	* TRATAMENTOS ESPECIAIS DE SINTAXE
	DO CASE
		CASE goCONEXAO.BANCO = 'DBC'
			tcSINTAXE = TRATASQLFOX(tcSINTAXE)
		CASE goCONEXAO.BANCO = 'POS'
			tcSINTAXE = TRTSINPGSQL(tcSINTAXE)
			tcSINTAXE = TRTFUNPGSQL(tcSINTAXE)
		CASE goCONEXAO.BANCO = 'ORA'
			tcSINTAXE = TRATASQLORACLE(tcSINTAXE)
		CASE goCONEXAO.BANCO = 'MYS'
			tcSINTAXE = TRATAMYSQL(tcSINTAXE)
		OTHERWISE
			tcSINTAXE = TRATASQLMSSQL(tcSINTAXE)
	ENDCASE

	DO CASE
		CASE goCONEXAO.BANCO = 'DBC'
			* BANCO DE DADOS NATIVO DO FOX, NÃO UTILIZA DRIVER ODBC. TODAS AS PESQUISAS FUNCIONAM COM COMANDOS NATIVOS.
			tcSINTAXE	= STRTRAN( tcSINTAXE, CHR(13)+CHR(10), ' ' )
			tcSINTAXE	= STRTRAN( tcSINTAXE, CHR(09), '' )
	ENDCASE

	* EXECUTA COMANDO NA BASE
	gnSQLOK = SQLEXEC(goCONEXAO.ALCA,tcSINTAXE,tcARQUIVO)
        
	IF gnSQLOK<0
		=AERROR(laERRO)

		lcNUMERRO	= ALLTRIM(STR(laERRO(1)))
		lcERRO		= laERRO(3)

		lnRESP	= MESSAGEBOX('ERRO NO ACESSO À BASE DE DADOS: ' + CHR(13)+CHR(10)+;
								SYS(16)+CHR(13)+CHR(10)+;
								lcNUMERRO+CHR(13)+CHR(10)+;
								lcERRO,'AVISO: SQL-ERRO',48+2+256)
		IF lnRESP = 3
			_CLIPTEXT	= tcSINTAXE
			DEBUG
			SUSP
		ENDIF
		IF lnRESP = 4
			_CLIPTEXT = tcSINTAXE
		ENDIF
	ELSE
		* TRATAMENTO DE ARREDONDAMENTO DAS CASAS DECIMAIS SOMENTE NO ORACLE
		** DEVIDO A BUG DO DRIVER {MICROSOFT ODBC PARA ORACLE} AO EFETUAR FUNÇÕES COMO SUM, MAX, MIN E ETC...
		LOCAL ARRAY laCAMPOS[1]
		
		LOCAL lnXI AS Integer
		STORE 0 TO lnXI
		
		LOCAL lcMACRO, lcFIELDS AS String
		STORE '' TO lcMACRO, lcFIELDS

		LOCAL llOK AS Logical
		STORE .F. TO llOK

		IF 'ORACLE' $ UPPER(goCONEXAO.DRIVER)
			=AFIELDS(laCAMPOS,tcARQUIVO)
			FOR lnXI = 1 TO ALEN(laCAMPOS,1)
				IF 'VL_' $ UPPER(laCAMPOS[lnXI,1]) AND laCAMPOS[lnXI,2] = 'N' AND laCAMPOS[lnXI,3] = 20 AND laCAMPOS[lnXI,4] = 0
					lcFIELDS = lcFIELDS + ',CAST(' + laCAMPOS[lnXI,1] + ' AS N(20,2)) AS ' + laCAMPOS[lnXI,1]
					llOK = .T.
				ELSE
					lcFIELDS = lcFIELDS + ',' + laCAMPOS[lnXI,1]
				ENDIF
			ENDFOR
			IF llOK
				lcFIELDS = SUBSTR(lcFIELDS,2)
				lcMACRO = 'SELECT ' + lcFIELDS + ' FROM ' + tcARQUIVO + ' INTO CURSOR ' + tcARQUIVO + ' READWRITE'
				&lcMACRO
			ENDIF
		ENDIF
	ENDIF
RETURN

FUNC TRATASQLFOX
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	IF ' CASE WHEN ' $ lcCPOOUT
		lcCPOOUT = STRTRAN( lcCPOOUT, ' CASE WHEN '	, ' IIF( '	)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' THEN '			, ' , '		)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' ELSE '			, ' , '		)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' END '			, ' ) '		)
	ENDIF
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LPAD(', 'PADL(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'RPAD(', 'PADR(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(')
RETURN(lcCPOOUT)

FUNC TRTSINPGSQL
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(')
	lcCPOOUT = STRTRAN( lcCPOOUT, "\'", "\.'" )
RETURN(lcCPOOUT)

FUNC TRTFUNPGSQL
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = REMOVERTOPSQL(lcCPOOUT,'LIMIT')
	lcCPOOUT = STRTRAN( lcCPOOUT, ' SPACE( ', ' LPAD(" ",')
RETURN(lcCPOOUT)

FUNC TRATASQLORACLE
*******************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT, lcP1, lcP2 AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT	= tcCPOIN
	lcCPOOUT	= STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(' )
	lcCPOOUT	= STRTRAN( lcCPOOUT, ' SPACE( ', ' LPAD(" ",' )
	* TRATANDO POR PARTES
	IF 'FROM' $ lcCPOOUT
		lcP1 = STREXTRACT(lcCPOOUT,'','FROM',1,4)
		lcP2 = STREXTRACT(lcCPOOUT,'FROM','',1,0)
		lcP2 = STRTRAN( lcP2, ' AS ', ' ')
		lcP1 = REMOVERTOPSQL(lcP1,'ROWNUM')
		lcCPOOUT = lcP1+lcP2
	ENDIF
	IF 'DATE_PART(' $ lcCPOOUT
		LOCAL lcAUX, lcCONTEUDO AS String
		LOCAL lnXI AS Integer
		FOR lnXI = 1 TO OCCURS('DATE_PART(',lcCPOOUT)
			lcCONTEUDO = STREXTRACT(lcCPOOUT,'DATE_PART(',')',lnXI)
			IF EMPTY(lcCONTEUDO)
				LOOP
			ENDIF
			DO CASE
				CASE 'DAY' $ lcCONTEUDO
					lcAUX = STREXTRACT( lcCONTEUDO, ',' , '' ) + ", 'DD'" 
					lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
				CASE 'MONTH' $ lcCONTEUDO
					lcAUX = STREXTRACT( lcCONTEUDO, ',' , '' ) + ", 'MM'"
					lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
				CASE 'YEAR' $ lcCONTEUDO
					lcAUX = STREXTRACT( lcCONTEUDO, ',' , '' ) + ", 'YYYY'"
					lcCPOOUT= STRTRAN(lcCPOOUT,lcCONTEUDO,lcAUX,1,1)
				OTHERWISE
					LOOP
			ENDCASE										
		ENDFOR
		lcCPOOUT= STRTRAN(lcCPOOUT,'DATE_PART(','TO_CHAR(')
	ENDIF
RETURN(lcCPOOUT)

FUNC TRATAMYSQL
***************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT, lcP1, lcP2 AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT	= tcCPOIN
	lcCPOOUT 	= REMOVERTOPSQL(lcCPOOUT,'LIMIT')
RETURN(lcCPOOUT)

FUNC TRATASQLMSSQL
******************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT, lcCONTEUDO, lcSUBSTITUI, lcAUX AS String
	LOCAL lnXI, lnOCO AS Integer
	STORE '' TO lcCPOOUT, lcCONTEUDO, lcSUBSTITUI, lcAUX
	STORE 0 TO lnXI, lnOCO
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = STRTRAN( lcCPOOUT, '||' , '+' )
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTR(', 'SUBSTRING(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LENGTH(', 'LEN(')
	IF 'LPAD(' $ lcCPOOUT
		FOR lnXI = 1 TO 100
			lcCONTEUDO	= STREXTRACT(lcCPOOUT,'LPAD(',')')
			IF EMPTY(lcCONTEUDO)
				EXIT
			ENDIF
			lnOCO		= RAT( ',' , lcCONTEUDO )
			lcSUBSTITUI	= 'CAST( ' + ;
							LEFT( lcCONTEUDO,lnOCO-1 ) + ;
							' AS CHAR(' + ;
							RIGHT( lcCONTEUDO,lnOCO-2 ) + '))'
			lcCPOOUT	= STRTRAN( lcCPOOUT, 'LPAD(' + lcCONTEUDO + ')', lcSUBSTITUI )
		ENDFOR
	ENDIF
	IF 'RPAD(' $ lcCPOOUT
		FOR lnXI = 1 TO 100
			lcCONTEUDO	= STREXTRACT(lcCPOOUT,'RPAD(',')')
			IF EMPTY(lcCONTEUDO)
				EXIT
			ENDIF
			lnOCO		= RAT( ',' , lcCONTEUDO )
			lcSUBSTITUI	= 'CAST( ' + ;
							LEFT( lcCONTEUDO,lnOCO-1 ) + ;
							' AS ' + ;
							RIGHT( lcCONTEUDO,lnOCO-2 ) + ')'
			lcCPOOUT	= STRTRAN( lcCPOOUT, 'LPAD('+lcCONTEUDO+')', lcSUBSTITUI )
		ENDFOR
	ENDIF
	IF 'DATE_PART(' $ lcCPOOUT
		FOR lnXI = 1 TO 100
			lcCONTEUDO	= STREXTRACT(lcCPOOUT,'DATE_PART(',')')
			IF EMPTY(lcCONTEUDO)
				EXIT
			ENDIF
			lcAUX		= UPPER(STREXTRACT(lcCONTEUDO, "'", "'," ))
			IF NOT lcAUX $ 'DAY,MONTH,YEAR'
				LOOP
			ENDIF
			lcSUBSTITUI	= UPPER(lcAUX) + '(' + ;
							UPPER(STREXTRACT(lcCONTEUDO, "',")) + ')'
			lcCPOOUT	= STRTRAN( lcCPOOUT, 'DATE_PART('+lcCONTEUDO+')', lcSUBSTITUI )
		ENDFOR
	ENDIF
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LENGTH(', 'LEN(')
RETURN(lcCPOOUT)

FUNC REMOVERTOPSQL
******************
LPARAMETERS tcSQL, tcOUTROS
	LOCAL lcOUT AS String
	lcOUT = tcSQL
	IF ' TOP ' $ lcOUT
		LOCAL lcAUX, lcLETRA AS String
		LOCAL lnOCO AS Integer
		lcAUX	= ''
		lnOCO	= AT(' TOP ',lcOUT)
		FOR lnXI = lnOCO+5 TO LEN(lcOUT)
			lcLETRA = SUBSTR(lcOUT,lnXI,1)
			IF EMPTY(lcLETRA)
				EXIT
			ENDIF
			lcAUX = lcAUX + lcLETRA
		ENDFOR
		lcOUT	= STRTRAN(lcOUT,' TOP '+lcAUX,'')
		IF 'LIMIT' $ tcOUTROS
			lcOUT	= lcOUT + ' LIMIT '+lcAUX
		ENDIF
	ENDIF
RETURN(lcOUT)

PROC MENS
*********
LPARAMETERS tcMENSAGEM,tnERRO
* MENSAGEM AO USUARIO, SE TNERRO=1 A MENSAGEM É MAIS GRAVE.
	IF TYPE('tnERRO')<>'N'
		tnERRO = 0
	ENDIF
	tnERRO = IIF(tnERRO>0,48,64)
	=MESSAGEBOX(tcMENSAGEM,'AVISO',tnERRO)
RETURN

PROC SIMOUNAO
*************
LPARAMETERS tcPERGUNTA, tcTITULO, tnDEFAULT
	LOCAL lnBOTAO AS Number
	IF VARTYPE(tnDEFAULT) <> 'N'
		tnDEFAULT = 0
	ENDIF
	IF tnDEFAULT = 1
		tnBOTAO = 0
	ELSE
		tnBOTAO = 256
	ENDIF
	IF MESSAGEBOX( tcPERGUNTA, tcTITULO, 32+4+tnBOTAO )=6
		RETURN(.T.)
	ENDIF
RETURN(.F.)

PROC WAW_DECRIPTAR
******************
	LPARAMETERS tcIN
		LOCAL llERROR AS Boolean
		STORE .F. TO llERROR
		TRY 
			tcIN 	= goZIP.DECRYPT(tcIN,"CONFIG0105SÃO'")
			llERROR	= .F.
		CATCH
			llERROR	= .T.
		ENDTRY
		
		* Tratamento de erro
		IF llERROR
			tcIN	= ''
		ENDIF
	RETURN tcIN
ENDPROC

* Classe padrão
DEFINE CLASS CONECTADB AS Custom 
	BANCO 				= ''
	ALCA 				= -1
	DRIVER 				= ''
	CONNECTIONSTRING	= ''
ENDDEFINE

DEFINE CLASS APLICATIVO AS Custom
	TESTE 			= .F.
	PATHLOCAL		= ''
	PATHTEMP		= GETENV("TEMP")+'\PWI\'
	NOME			= ''
ENDDEFINE