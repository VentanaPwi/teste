**********************************************
* MENURAIZ - MENU DO CONFIGURADOR DE CONEXÃO *
* AUTHOR: PASSWORD SISTEMAS LTDA             *
**********************************************
PARAMETERS tcROTINA AS String

DO AMBIENTAR

IF TYPE('tcROTINA') <> 'C'
	tcROTINA = 'PRINCIPAL'
ENDIF
tcROTINA = UPPER(tcROTINA)

_SCREEN.visible = .t.
_SCREEN.WindowState = 2		&& tela cheia

CLOSE ALL EXCEPT t*
ACTI SCREEN

PUBLIC glTESTE AS Logical
glTESTE = IIF( 'TESTES'$CURDIR() , .T., .F.)
IF glTESTE
	ON KEY LABEL CTRL+F2 ACTIVATE WINDOW COMMAND
	SET STATUS BAR ON
ELSE
	SET RESOURCE OFF
	ON ERROR DO ROTERRO WITH ERROR(),MESSAGE(),PROGRAM(),LINENO()
	SET STATUS BAR OFF
ENDIF

IF NOT glTESTE
	_SCREEN.CAPTION = 'Xconfig - Configurador do Volpe'
	IF SENHAOK()=0
		CANCEL
	ENDIF
ENDIF

* VARIAVEIS GERAIS DO PROGRAMA
PUBLIC gcCONN AS String
gcCONN = ''

* ABRINDO ARQUIVO DE CONFIGURAÇÃO
DO WHILE .T.
	IF FILE('CONFIG.PWI')
		EXIT
	ENDIF
	IF FILE('CONECTA.PWI')
		EXIT
	ENDIF
	lcMENS = 'ARQUIVO DE CONFIGURAÇÃO NÃO FOI ENCONTRADO NA PASTA CORRENTE.'+CHR(13)+;
			'Você precisa escolher uma pasta de sistema para que o Xconfig'+CHR(13)+;
			'possa acessar o arquivo de configuração (conexão à base de dados)'+CHR(13)+CHR(13)+;
			'Deseja prosseguir ?'
	IF SIMOUNAO(lcMENS,'DIRETORIO DE SISTEMA',2)
		lcPATH = GETDIR(FULLPATH(''),'Selecione a pasta do sistema a ser configurado:','SELECIONAR PASTA',16)
		IF !EMPTY(lcPATH)
			SET DEFAULT TO &lcPATH
		ENDIF
		LOOP
	ELSE
		RETURN
	ENDIF
ENDDO
IF NOT FILE('CONFIG.PWI') AND FILE('CONECTA.PWI')
	* ESPECIAL P/ PROGRAMAS FORA DA PLATAFORMA VOLPE
	USE CONECTA.PWI IN 0 ALIAS CONFIG
	DO FORM PRINCIPAL WITH 'NOPLATA'
ELSE
	LOCAL lcPLATA AS STRING
	lcPLATA = ''
	IF NOT FILE('SISTEMA.PWI')
		lcPLATA = 'NOPLATA'
	ENDIF
	* PADRÃO - PLATAFORMA VOLPE
	USE CONFIG.PWI IN 0 ALIAS CONFIG
	DO FORM PRINCIPAL WITH lcPLATA
ENDIF

DO ENCERRAR
RETURN

PROC AMBIENTAR
**************
	SET TALK OFF
	SET ESCAPE OFF
	SET EXCL OFF
	SET DELE ON
	SET DATE BRITISH
	SET CURSOR ON
	SET NOTIFY OFF
	SET SAFETY OFF
	SET READBORDER ON
	SET DECIMAL TO 8
	SET REPROCESS TO 3 SECONDS
	SET POINT TO ','
	SET SEPA TO '.'
	SET EXACT OFF
	SET NEAR OFF
	SET CONFIRM ON
	SET CLOCK STATUS
	SET CENTURY ON
	SET MEMOWIDTH TO 512
	SET HOURS TO 24
	SET ENGINEBEHAVIOR 80
	SET REPORTBEHAVIOR 90
RETURN

PROC SIMOUNAO
*************
PARAMETERS tcQUESTION,tcTITSN,tnDEFASN
	lnRESPSN = MESSAGEBOX( tcQUESTION, tcTITSN, IIF(tnDEFASN=1,36,292) )
	CLEA TYPEAHEAD
	IF lnRESPSN = 6
		RETU(.T.)
	ENDIF
RETU(.F.)

FUNC SBDVAI
***********
* ENCRIPTA SENHA DE BANCO DE DADOS
PARAMETERS tcSENHA
	tcSENHA = ALLTRIM(tcSENHA)
	LOCAL lcHIDEN, lcSEMENTE, lcLETRA AS String
	lcHIDEN = ''
	LOCAL X, Y AS INTEGER
	X = INT(RAND()*25)
	Y = MOD(ASC(tcSENHA+' '),10)
	lcSEMENTE = CHR(X+65)
	lcHIDEN = STR(Y,1)+lcSEMENTE
	FOR X = LEN(tcSENHA) TO 1 STEP -1
		lcLETRA = SUBSTR(tcSENHA,X,1)
		Y = ASC(lcLETRA)+ASC(lcSEMENTE)
		lcLETRA = PADL( ALLTRIM(STR(Y)) ,3,'0')
		lcHIDEN = lcHIDEN + lcLETRA
	ENDFOR
RETURN(lcHIDEN)

FUNC SBDVEM
***********
* DECRIPTA SENHA DE BANCO DE DADOS
PARAMETERS tcHIDEN
	tcHIDEN = ALLTRIM(tcHIDEN)
	LOCAL lcSENHA, lcSEMENTE, lcLETRA AS String
	lcSENHA = ''
	lcSEMENTE = SUBSTR(tcHIDEN,2,1)
	LOCAL X, Y AS INTEGER

	FOR X = LEN(tcHIDEN) TO 3 STEP -3
		Y = VAL( SUBSTR(tcHIDEN,X-2,3) ) -ASC(lcSEMENTE)
		lcLETRA = ''
		IF Y>27 AND Y<256
			lcLETRA = CHR(Y)
		ENDIF
		lcSENHA = lcSENHA + lcLETRA
	ENDFOR
RETURN(lcSENHA)

PROC MENS
*********
PARAM tcMENS
 	=MESSAGEBOX(tcMENS,"AVISO",48)
RETURN

PROC ROTERRO
************
PARAMETERS tnMYERRO, tcMYMESS, tcMYPROG, tnMYLINH
	DO CASE
	CASE tnMYERRO = 1705
		=MESSAGEBOX('ACESSO NAO PERMITIDO NO MOMENTO! ARQUIVO BLOQUEADO','ERRO',32)
	OTHERWISE
		=MESSAGEBOX('Ocorreu uma falha no seu aplicativo e ele terá que ser encerrado! Anote a mensagem de erro e entre em contato com o suporte técnico do seu software. ERRO: '+;
		ALLTRIM(STR(tnMYERRO)) + '=' + tcMYMESS + ' LINHA ' + ALLTRIM(STR(tnMYLINH)) + ':' + tcMYPROG, 'ERRO',32)
	ENDCASE
	CANCEL
RETURN

FUNC SENHAOK
************
	DO FORM SENHA_DIGITAR TO lcLOGIN
*	lcLOGIN = INPUTBOX('INFORME A SENHA DO X-CONFIG:','ACESSO AO X-CONFIG','')
	lcLOGIN = ALLTRIM(UPPER(lcLOGIN))
	IF lcLOGIN==LEFT('SPYALE',3)+LEFT('PRETOBRANCO',5)
		RETURN(1)
	ENDIF
	DO MENS WITH 'ACESSO NEGADO - SENHA INVÁLIDA'
RETURN(0)

PROC MONTACONN
**************
LPARAMETERS tnSCAT
* PARAMETRO P/ SCATTEAR OU NÃO (1=FAZ, 0=NÃO FAZ)
	IF TYPE('tnSCAT')<>'N'
		tnSCAT = 1
	ENDIF
	IF tnSCAT=1
		IF NOT USED('CONFIG')
			USE CONFIG.PWI IN 0
		ENDIF
		SELE CONFIG
		SCATTER MEMVAR
		M.PWD = SBDVEM(M.PWD)
	ENDIF
	IF EMPTY(M.DRIVER)
		RETURN('')
	ENDIF
	lcDRIVER = ALLTRIM(M.DRIVER)
	IF 'DSN' $ UPPER(lcDRIVER)
		lcCONN = 'FILEDSN='+FULLPATH('')+ALLTRIM(M.DBNAME)+';'+;
				'UID='   +ALLTRIM(M.USER)+';'+;
				'PWD='   +ALLTRIM(M.PWD)
	ELSE
		lcCONN = 'DRIVER='+lcDRIVER
		IF !EMPTY(M.SERVER)
			lcCONN = lcCONN+';SERVER='+ALLTRIM(M.SERVER)
		ENDIF
		IF !EMPTY(M.USER)
			lcCONN = lcCONN+';UID='   +ALLTRIM(M.USER)
		ENDIF
		IF !EMPTY(M.PWD)
			lcCONN = lcCONN+';PWD='   +ALLTRIM(M.PWD)
		ENDIF
		IF !EMPTY(M.DBNAME)
			lcCONN = lcCONN+';DATABASE='+ALLTRIM(M.DBNAME)
		ENDIF
		IF !EMPTY(M.OUTROS)
			lcCONN = lcCONN + ';'+ALLTRIM(M.OUTROS)
		ENDIF
	ENDIF
RETURN(lcCONN)

PROC ESPERANDO
**************
	PARAMETER tcMESS
	WAIT WINDOW tcMESS NOWAIT NOCLEAR
RETURN

PROC SAIDA
**********
	IF glTESTE
		SET SYSMENU TO DEFA
		REST MACROS
	ENDIF
	CLOSE ALL
	CLEAR WIND
	CANCEL
RETURN

PROC LIMPA_ARQS
***************
	* - ARRAY COM OS LOCAIS DO SISTEMA (RAIZ, OBJETOS, ICONES, ETC.)
	* - [N,1] = NOME DE APRESENTAÇÃO
	* - [N,2] = LOCAL (PATH)
	* - [N,3] = EXTENSÕES ACEITÁVEIS
	DECLARE laLOCAIS[4,3]
	laLOCAIS[1,1] = '(RAIZ)'
	laLOCAIS[1,2] = '.\'
	laLOCAIS[1,3] = ';PRG;FXP;SCX;SCT;BMP;ICO;EXE;DLL;FLL;PWI;'
	laLOCAIS[2,1] = '  ICONES'
	laLOCAIS[2,2] = 'ICONES\'
	laLOCAIS[2,3] = ';ICO;'
	laLOCAIS[3,1] = '  OBJETOS'
	laLOCAIS[3,2] = 'OBJETOS\'
	laLOCAIS[3,3] = ';PRG;FXP;'
	laLOCAIS[4,1] = '  REPORTS'
	laLOCAIS[4,2] = 'REPORTS\'
	laLOCAIS[4,3] = ';FRT;FRX;'
	* - ARRAY COM OS ARQUIVOS RESULTANTES
	DECLARE laFILES[1]
	laFILES = ''
	DO FORM LIMPAFILE
RETURN

PROC ENCERRAR
*************
	* NÃO TEM COMO COLOCAR CLEAR ALL NO OBJETO
	CLEAR EVENTS
	SET SYSMENU TO DEFA
	DEACTIVATE WINDOW ALL
	CLEAR WINDOW ALL
	CLOSE DATA
	CLEAR ALL
	CANCEL
RETURN

PROC STARTAFILE
***************
LPARAMETERS tcARQUIVO AS String
	IF TYPE('tcARQUIVO') <> 'C'
		tcARQUIVO = ''	
	ENDIF
	IF EMPTY(tcARQUIVO)
		RETURN
	ENDIF
	IF NOT FILE(tcARQUIVO)
		DO MENS WITH 'Arquivo não encontrado: '+tcARQUIVO
		RETURN
	ENDIF

	DECLARE LONG ShellExecute IN "shell32.dll" ;
		LONG HWND, STRING lpszOp, ;
		STRING lpszFile, STRING lpszParams, ;
		STRING lpszDir, LONG nShowCmd

	SHELLEXECUTE( 0, 'Open', FULLPATH(tcARQUIVO), 0, 0, 1)
RETURN

PROC ATUSQL
***********************************************************************
* ATUSQL - ATUALIZA BASE SQL DE ACORDO COM A AÇÃO DESEJADA	- *
***********************************************************************
PARAMETERS tnALCA, tcACTION, tcTABELA, tcOUTROS, tcCAMPOSUPDATE, tcDRIVER
	* PARAMETRO1 - ALCA DE CONEXÃO
	* PARAMETRO2 - ACAO (A/M/D)
	* PARAMETRO3 - TABELA
	* PARAMETRO4 - STRING CONTENDO PALAVRAS-CHAVE
	* PARAMETRO5 - CAMPOS EXCEÇÕES (SE VAI GRAVAR OU NÃO, DEPENDE DAS PALAVRAS-CHAVE)
	* PARAMETRO6 - DRIVER DE CONEXÃO COM O BANCO DE DADOS
	* PALAVRAS-CHAVE:
	* NOAUTOINC = INDICA QUE O PK_ID NÃO É AUTONUMERAÇÃO (PRECISA GRAVA-LO)
	* NOPK      = INDICA QUE O NÃO HÁ PK_ID (VALIDO PARA INSERTS ONLY)
	* UPDATE=NO = INDICA QUE OS CAMPOS RELACIONADOS DEVEM SER IGNORADOS
	* UPDATE=YES= INDICA QUE OS SÓ CAMPOS RELACIONADOS DEVEM SER GRAVADOS
	IF TYPE('tnALCA') <> 'N'
		tnALCA = 0
	ENDIF
	IF EMPTY(tnALCA)
		RETURN(0)
	ENDIF
	IF TYPE('tcACTION') <> 'C'
		DO MENS WITH 'NENHUMA AÇÃO FOI INFORMADA (ATUSQL)'
		RETURN(0)
	ENDIF
	IF EMPTY(ALIAS())
		DO MENS WITH 'NENHUMA TABELA SELECIONADA (ATUSQL)'
		RETURN(0)
	ENDIF
	IF NOT tcACTION $ 'AMD'
		DO MENS WITH 'AÇÃO INFORMADA NÃO FOI RECONHECIDA: ('+tcACTION+') ATUSQL'
		RETURN(0)
	ENDIF
	IF TYPE('tcTABELA') <> 'C'
		tcTABELA = ALIAS()
	ENDIF
	IF TYPE('tcOUTROS') <> 'C'
		tcOUTROS = ''
	ENDIF
	IF TYPE('tcCAMPOSUPDATE') <> 'C'
		tcCAMPOSUPDATE = ''
	ENDIF
	tcCAMPOSUPDATE = VIRGULAR(tcCAMPOSUPDATE)
	IF TYPE('tcDRIVER') <> 'C'
		tcDRIVER	= ''
	ENDIF
	IF EMPTY(tcDRIVER)
		tcDRIVER	= CONFIG.DRIVER
	ENDIF

	lnUPDATE = 0
	IF 'UPDATE=NO' $ tcOUTROS
		lnUPDATE = 1
	ENDIF
	IF 'UPDATE=YES' $ tcOUTROS
		lnUPDATE = 2
	ENDIF

	PRIVATE ARRAY laERRO[1]
	PRIVATE lnSQLOK, lnRESP, lnIDENTITY, lnCONTEUXID, lnRESPIDENTITY AS Integer
	PRIVATE lcATUSQL, lcERRO, lcALIASUI, lcCMDIDENTITY, lcMOTIVO, lcSQLCONDI AS String

	lnSQLOK		= -1				&& CONTROLE DE OPERAÇÃO BEM SUCEDIDA
	lcATUSQL	= ''
	lcALIASFOX  = ALIAS()

	pnNOPK = 0
	IF 'NOPK' $ tcOUTROS
		* PODE-SE ESCOLHER IGNORAR OK PK_ID
		pnNOPK = 1
	ENDIF
	pnAUTOINC = 0
	IF NOT 'NOAUTOINC' $ tcOUTROS
		* POR DEFAULT OS PK NUMERICOS SÃO AUTONUMERAÇÃO
		pnAUTOINC = 1
	ENDIF

*!*		* PEGA PROX.NUMERO (RECNO)
*!*		IF pnAUTOINC=1 AND tcACTION='A' AND pnNOPK<>1
*!*			IF NOT EMPTY(tcSTRINGCON)
*!*			ELSE
*!*			ENDIF
*!*			AND ( 'ORACLE' $ UPPER(tcDRIVER) OR 'ORACLE' $ tcSTRINGCON )

*!*				lcPROXIMO = 'SELECT '+tcTABELA+'_S.NEXTVAL AS PROXIMO FROM DUAL'
*!*				=SQLEXEC(tnALCA,lcPROXIMO,'TMPLASTPK')
*!*				luPK_ID		= TMPLASTPK.PROXIMO
*!*				USE IN TMPLASTPK
*!*				pnAUTOINC = 0
*!*				SELE &lcALIASFOX
*!*				REPLACE PK_ID WITH luPK_ID
*!*		ENDIF

	* MONTA SINTAXE COMPLETA
	DO MONTASQLC

*	LOCAL lcNOVASTRING AS String
*	lcNOVASTRING	= ''
*	* TRATAMENTOS ESPECIAIS DE SINTAXE
*	DO CASE
*		CASE 'FOXPRO' $ UPPER(tcDRIVER)
*			lcNOVASTRING = TRATASQLFOX(lcATUSQL)
*		CASE 'POSTGRE' $ UPPER(tcDRIVER)
*			lcNOVASTRING = TRATASQLPGSQL(lcATUSQL)
*		CASE 'ORACLE' $ UPPER(tcDRIVER)
*			lcNOVASTRING = TRATASQLORACLE(lcATUSQL)
*		OTHERWISE
*			lcNOVASTRING = TRATASQLMSSQL(lcATUSQL)
*	ENDCASE
*	lcATUSQL	= lcNOVASTRING

	* EXECUTA COMANDO NA BASE SQL
	lnSQLOK		= SQLEXEC(tnALCA,lcATUSQL)
	IF lnSQLOK<0
		=AERROR(laERRO)
		lnERRO = ALLTRIM(STR(laERRO(1)))
		lcERRO = laERRO(3)
		=MESSAGEBOX('ERRO NO ACESSO A BASE DE DADOS: '+lnERRO+CHR(13)+lcERRO,'AVISO: SQL-ERRO',48)
		lnRESP=MESSAGEBOX('ESCOLHA O TRATAMENTO','TRATANDO ERRO SQL',2)
		IF lnRESP=3
			_CLIPTEXT = lcATUSQL
			DEBUG
			SUSP
		ENDIF
		IF lnRESP=4
			_CLIPTEXT = lcATUSQL
		ENDIF
		RETURN(0)
	ENDIF
	IF 'ORACLE' $ UPPER(tcDRIVER)
		=SQLEXEC(tnALCA,'COMMIT')
	ENDIF

*!*		IF tcACTION='A' AND pnAUTOINC=1
*!*			* SE FOI UM INSERT, PEGAR O CAMPO C/ AUTOINCREMENTO (IDENTITY)
*!*			lcALIASUI	= ALIAS()
*!*			lnIDENTITY	= 0
*!*			DO PEGAULTINC
*!*			SELECT &lcALIASUI
*!*			IF lnIDENTITY>0
*!*				* ATUALIZA CAMPO AUTO-NUMERAÇÃO NA BASE LOCAL
*!*				REPLACE PK_ID WITH lnIDENTITY
*!*			ELSE
*!*				lnSQLOK = -2
*!*				* EXCLUIR REGISTRO (NAO FOI INCLUIDO NO SQL)
*!*				DELETE
*!*				SKIP-1
*!*				IF BOF() AND NOT EOF()
*!*					SKIP
*!*				ENDIF
*!*			ENDIF
*!*		ENDIF
	LOCAL lnRETORNO AS Integer
	IF TYPE('PK_ID') $ 'CNIDT'
		lnRETORNO = PK_ID
	ELSE
		lnRETORNO = 1
	ENDIF
RETURN(lnRETORNO)

PROC PEGAULTINC
***************
	DO CASE
		CASE 'MYSQL' $ UPPER(tcDRIVER)
			lcCMDIDENTITY	= "SELECT MAX(PK_ID) AS ULTIMAINC FROM "+tcTABELA
			lnRESPIDENTITY	= SQLEXEC(tnALCA,lcCMDIDENTITY,'TMPLASTPK')
			
		CASE 'POSTGRES' $ UPPER(tcDRIVER)
			lcCMDIDENTITY	= "SELECT CURRVAL('"+tcTABELA+"_S'::text) AS ULTIMAINC" &&tcSEQUENCIA
			lnRESPIDENTITY	= SQLEXEC(tnALCA,lcCMDIDENTITY,'TMPLASTPK')
		CASE 'ORACLE' $ UPPER(tcDRIVER)
			lcCMDIDENTITY	= 'SELECT '+tcSEQUENCIA+'.CURRVAL AS ULTIMAINC FROM DUAL'
			lnRESPIDENTITY	= SQLEXEC(tnALCA,lcCMDIDENTITY,'TMPLASTPK')
		CASE 'FOXPRO' $ UPPER(tcDRIVER)
			* FALTA: MÉTODO PARA PEGAR ÚLTIMO REGISTRO NO FOX
		OTHERWISE
			*SQL SERVER
			lcCMDIDENTITY	= 'SELECT @@IDENTITY AS ULTIMAINC'
			lnRESPIDENTITY	= SQLEXEC(tnALCA,lcCMDIDENTITY,'TMPLASTPK')
	ENDCASE

	lcMOTIVO = ''

	IF lnRESPIDENTITY<0
		lcMOTIVO = 'EXEC-SQL'
	ENDIF
	IF ULTIMAINC<=0
		lcMOTIVO = 'PK_ID SEM CONTEUDO'
	ENDIF
	IF TYPE('ULTIMAINC')<>'N'
		lcMOTIVO = 'SEM PK_ID'
	ENDIF	

	IF NOT EMPTY(lcMOTIVO)
		DO MENS WITH 'ERRO NA INCLUSÃO (P/RETORNAR PK_ID): '+lcMOTIVO+' ATUSQL'
	ELSE
		*RETORNA ULTIMA INSERÇÃO
		lnIDENTITY = ULTIMAINC
	ENDIF
	USE IN TMPLASTPK
RETURN

PROCEDURE MONTASQLC
*******************
* MONTA COMANDO DE ACORDO COM A ACAO EXECUTADA NA BASE LOCAL
* OBS: A ACAO É EFETUADA NO DBF (CURSOR LOCAL) E DEPOIS PRECISA QUE SEJA ATUALIZADA
* ---- A BASE SQL. ASSIM ESTE COMANDO É MONTADO PARA SER EXECUTADO E EFETUAR ESTA TAREFA

	IF tcACTION='A'
		lcSQLCONDI = ''
	ELSE
		*CONDICAO
		luPK_ID	= PK_ID
		lcSQLCONDI = " WHERE PK_ID="+XX(luPK_ID)
	ENDIF

	* MONTA NOME DA TABELA NO SQL
	IF tcTABELA = 'TMP'
		RETURN
	ENDIF

	* MONTA SINTAXE DE CADA COMANDO, DEPENDENDO DA AÇÃO
	PRIVATE pcCPOAUX AS String
	pcCPOAUX = ''
	DO CASE
		CASE tcACTION = 'D'
			* DELETAR REGISTRO (DELETE)
			lcATUSQL = 'DELETE FROM '+tcTABELA+lcSQLCONDI

		CASE tcACTION = 'A'
			* INCLUIR REGISTRO (INSERT)
			WQF = AFIELDS(WTABF)
			STORE '' TO lcINSERE1, lcINSERE2
			FOR WXC = 1 TO WQF
				pcCPOAUX = ALLTRIM(WTABF[WXC,1])
				IF pcCPOAUX = 'PK_ID' AND pnAUTOINC=1
					* CAMPO IDENTITY 
					LOOP
				ENDIF
				IF pcCPOAUX = 'PK_ID' AND pnNOPK=1
					* NÃO GRAVAR PK
					LOOP
				ENDIF
				IF pcCPOAUX = 'DH_ALTERACAO'
					LOOP
				ENDIF
				IF lnUPDATE=1
					IF VIRGULAR(pcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO A SER IGNORADO
						LOOP
					ENDIF
				ENDIF
				IF lnUPDATE=2
					IF NOT VIRGULAR(pcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO QUE NÃO FAZ PARTE DA RELAÇÃO
						LOOP
					ENDIF
				ENDIF
				IF EMPTY(lcINSERE1)
					lcSEPARA = ''
				ELSE
					lcSEPARA = ', '
				ENDIF

				lcCONTEUDO = "''"
				DO VCONTEUDO
*				IF pcCPOAUX = 'DH_INCLUSAO'
*					lcCONTEUDO = D2SQL(DATE(),'HOJE')
*				ENDIF

				lcINSERE1 = lcINSERE1 + lcSEPARA + pcCPOAUX
				lcINSERE2 = lcINSERE2 + lcSEPARA + lcCONTEUDO
			ENDFOR
			lcATUSQL = 'INSERT INTO '+tcTABELA+' ('+lcINSERE1+') VALUES ('+lcINSERE2+')'

		CASE tcACTION = 'M'
			* ALTERAR REGISTRO (UPDATE)
			WQF = AFIELDS(WTABF)
			WCAMPOSUP = ''
			STORE '' TO lcINSERE1, lcINSERE2
			FOR WXC = 1 TO WQF
				pcCPOAUX = ALLTRIM(WTABF[WXC,1])
				IF pcCPOAUX = 'PK_ID'
					* CAMPO IDENTITY
					LOOP
				ENDIF
				IF pcCPOAUX = 'DH_INCLUSAO'
					LOOP
				ENDIF
				IF lnUPDATE=1
					IF VIRGULAR(pcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO A SER IGNORADO
						LOOP
					ENDIF
				ENDIF
				IF lnUPDATE=2
					IF NOT VIRGULAR(pcCPOAUX) $ VIRGULAR(tcCAMPOSUPDATE)
						* CAMPO QUE NÃO FAZ PARTE DA RELAÇÃO
						LOOP
					ENDIF
				ENDIF
				IF '_KK' $ pcCPOAUX
					* CAMPO DE CONTROLE (NUNCA É FEITO UPDATE POR ESTA ROTINA
					LOOP
				ENDIF
				IF EMPTY(WCAMPOSUP)
					lcSEPARA = ''
				ELSE
					lcSEPARA = ', '
				ENDIF

				lcCONTEUDO = "''"
				DO VCONTEUDO
*				IF pcCPOAUX = 'DH_ALTERACAO'
*					lcCONTEUDO = D2SQL(DATE(),'HOJE')
*				ENDIF

				WCAMPOSUP = WCAMPOSUP + lcSEPARA + pcCPOAUX + "="+lcCONTEUDO
			ENDFOR
			lcATUSQL = 'UPDATE '+tcTABELA+' SET '+ WCAMPOSUP + lcSQLCONDI
	ENDCASE
RETURN

PROC VCONTEUDO
**************
	*formatacao dos campos de acordo com seu tipo
	IF TYPE(pcCPOAUX)$'DT'
		WDATAUX = &pcCPOAUX
		lcCONTEUDO = D2SQL(WDATAUX)
	ENDIF
	IF TYPE(pcCPOAUX)$'CM'
		lcCONTEUDO = "'"+ALLTRIM(STRTRAN(&pcCPOAUX ,"'",""))+"'"
		IF lcCONTEUDO = "''"
			lcCONTEUDO	= "' '"
		ENDIF
	ENDIF
	IF TYPE(pcCPOAUX)='L'
		lcCONTEUDO = IIF(&pcCPOAUX,'1','0')
	ENDIF
	IF TYPE(pcCPOAUX)$'NY'
		lcCONTEUDO = ALLTRIM(TRANS(&pcCPOAUX ,"999999999999999.99999999"))
		IF SET('POINT')<>'.'
			lcCONTEUDO = STRTRAN(lcCONTEUDO,'.','')
			lcCONTEUDO = STRTRAN(lcCONTEUDO,',','.')
		ENDIF
	ENDIF
	IF ISNULL(lcCONTEUDO)
		lcCONTEUDO = 'NULL'
	ENDIF
RETURN

FUNC VIRGULAR
*************
PARAMETERS tcVIRGULAR
	IF TYPE('tcVIRGULAR')='N'
		tcVIRGULAR = ALLTRIM(STR(tcVIRGULAR))
	ENDIF
	LOCAL lcVIRGULAR as String
	lcVIRGULAR = ','+tcVIRGULAR+','
RETURN(lcvirgular)

FUNC XX
*******
*RETORNA STRING PRONTA PARA CONCATENAR C/ COMANDO-SQL
PARAMETERS tnENTRA, tcPICTURE
	LOCAL lcSAI AS String
	lcSAI = 'NULL'
	IF NOT ISNULL(tnENTRA)
		IF TYPE('tnENTRA')='N'
			lcSAI = ALLTRIM(STR(tnENTRA,30))
			IF TYPE('tcPICTURE')='C'
				lcSAI = TRANSFORM(tnENTRA,tcPICTURE)
				lcSAI = STRTRAN(lcSAI,',','.')
			ENDIF
		ENDIF
		IF TYPE('tnENTRA')='C'
			tnENTRA = STRTRAN(tnENTRA,"'","")
			IF EMPTY(tnENTRA)
				lcSAI = "' '"
			ELSE
				lcSAI = "'"+ALLTRIM(tnENTRA)+"'"
			ENDIF
		ENDIF
		IF TYPE('tnENTRA')='D' OR TYPE('tnENTRA')='T'
			lcSAI = D2SQL(tnENTRA)
		ENDIF
	ENDIF
RETURN(lcSAI)

FUNC D2SQL
**********
LPARAMETERS tdENTRA, tcMODO
* PARAMETRO1= DATA A SER TRANSFORMADA (OU STRING)
* PARAMETRO2= MODO (DATA/STRING)
* ONDE: DATA=MONTA A STRING COM A DATA JA CONVERTIDA, EX: CONVERT(DATETIME,20/11/2004,103)
*       STRING=MONTA UMA STRING A SER TRATADA PELO SERVIDOR SQL, EX: CONVERT(DATETIME,CAMPO,103)
*              (ENVIAR O NOME DO CAMPO PARA A CONDIÇÃO)
	IF TYPE('tcMODO') <> 'C'
		tcMODO = 'DATA'
	ENDIF
	IF tcMODO = 'STRING'
		IF TYPE('tdENTRA') <> 'C'
			RETURN('')
		ENDIF
	ELSE
		IF NOT TYPE('tdENTRA') $ 'DT'
			tdENTRA = {}
		ENDIF
	ENDIF
	LOCAL luSAI
	luSAI = 'null'
	IF !EMPTY(tdENTRA)
		DO CASE
			CASE 'MYSQL' $ UPPER(tcDRIVER)
				*data entre aspas no formato aaaammdd
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= 'NOW()'
					CASE tcMODO = 'STRING'
						luSAI = "DATE_FORMAT('"+DTOS(tdENTRA)+"','%D/%M/%Y')"
					OTHERWISE
						IF TYPE('tdENTRA')='D'
							*data entre aspas no formato aaaammdd
							luSAI = "'"+DTOS(tdENTRA)+"'"
						ELSE
							*datahora entre aspas no formato aaaammdd
							luSAI = "'"+TTOC(tdENTRA,3)+"'"
							luSAI = STRT(luSAI,'T',' ')
						ENDIF
				ENDCASE
			CASE 'POSTGRE' $ UPPER(tcDRIVER)
				*data entre aspas no formato aaaammdd
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= "current_date"
					CASE tcMODO = 'STRING'
						luSAI	= "TO_CHAR("+tdENTRA+",'MM/DD/YYYY')"
					OTHERWISE
						LOCAL lcHHMMSS AS STRING
						lcHHMMSS = TTOC(tdENTRA,2)
						IF TYPE('tdENTRA')='D'
							*data entre aspas no formato aaaammdd
							luSAI = "TO_DATE('"+DTOS(tdENTRA)+"','YYYYMMDD')"
						ELSE
							*datahora entre aspas no formato aaaammdd
							lcHHMMSS = SUBSTR(lcHHMMSS,1,2)+SUBSTR(lcHHMMSS,4,2)+SUBSTR(lcHHMMSS,7,2)
							luSAI = "TO_TIMESTAMP('"+DTOS(tdENTRA)+lcHHMMSS+"','YYYYMMDDHH24MISS')"
						ENDIF

				ENDCASE
			CASE 'ORACLE' $ UPPER(tcDRIVER)
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= 'SYSDATE'
					CASE tcMODO = 'STRING'
						luSAI = "TO_CHAR("+tdENTRA+",'DD/MM/YYYY')"
					OTHERWISE
						LOCAL lcHHMMSS AS STRING
						lcHHMMSS = TTOC(tdENTRA,2)
						IF TYPE('tdENTRA')='D'
							*data entre aspas no formato aaaammdd
							luSAI = "TO_DATE('"+DTOS(tdENTRA)+"','YYYYMMDD')"
						ELSE
							*datahora entre aspas no formato aaaammdd
							lcHHMMSS = SUBSTR(lcHHMMSS,1,2)+SUBSTR(lcHHMMSS,4,2)+SUBSTR(lcHHMMSS,7,2)
							luSAI = "TO_DATE('"+DTOS(tdENTRA)+lcHHMMSS+"','YYYYMMDDHH24MISS')"
						ENDIF
				ENDCASE
			CASE 'FOXPRO' $ UPPER(tcDRIVER)
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= "DATETIME()"
					CASE tcMODO = 'STRING'
						luSAI	= "DTOC(DATE())"
					OTHERWISE
						luSAI	= "'"+DTOS(tdENTRA)+"'"
				ENDCASE
			OTHERWISE
				*SQL SERVER
				*onde: convert(formato,conteudo,nro)
				*ex: convert(datetime,'25/08/2003',103)
				DO CASE
					CASE tcMODO = 'HOJE'
						luSAI	= 'GETDATE()'
					CASE tcMODO = 'STRING'
						luSAI	= "convert(varchar,"+tdENTRA+",103)"
					OTHERWISE
						* MARTELANDO A DATA APENAS ACIMA DE 1900 E MENOR QUE 2079
						LOCAL lnANO, lnMES, lnDIA AS Integer
						LOCAL ldDATA AS Date
						lnANO	= YEAR(tdENTRA)
						lnMES	= MONTH(tdENTRA)
						lnDIA	= DAY(tdENTRA)
						IF lnANO < 1900
							lnANO	= YEAR(DATE())
						ENDIF
						IF lnANO > 2079
							lnANO	= YEAR(DATE())
						ENDIF
						ldDATA	= CTOD( STRZERO(lnDIA,2)+'/'+STRZERO(lnMES,2)+'/'+STRZERO(lnANO,4) )
						luSAI	= "convert(smalldatetime,'"+ DTOC(ldDATA) +"',103)"
				ENDCASE
		ENDCASE
	ENDIF
RETURN(luSAI)

FUNC TRATASQLFOX
****************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	IF ' CASE WHEN ' $ lcCPOOUT
		lcCPOOUT = STRTRAN( lcCPOOUT, ' CASE WHEN '	, ' IIF( '	)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' THEN '			, ' , '		)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' ELSE '			, ' , '		)
		lcCPOOUT = STRTRAN( lcCPOOUT, ' END '			, ' ) '		)
	ENDIF
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(')
RETURN(lcCPOOUT)

FUNC TRATASQLPGSQL
******************
LPARAMETERS tcCPOIN AS String
RETURN(lcCPOOUT)

FUNC TRATASQLORACLE
*******************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTRING(', 'SUBSTR(')
RETURN(lcCPOOUT)

FUNC TRATASQLMSSQL
******************
LPARAMETERS tcCPOIN AS String
	LOCAL lcCPOOUT AS String
	IF TYPE('tcCPOIN') <> 'C'
		tcCPOIN = ''
	ENDIF
	IF EMPTY(tcCPOIN)
		RETURN('')
	ENDIF
	lcCPOOUT = tcCPOIN
	lcCPOOUT = STRTRAN( lcCPOOUT, '||' , '+' )
	lcCPOOUT = STRTRAN( lcCPOOUT, 'SUBSTR(', 'SUBSTRING(')
	lcCPOOUT = STRTRAN( lcCPOOUT, 'LENGTH(', 'LEN(')
RETURN(lcCPOOUT)

FUNC STRZERO
************
LPARAMETERS tnVALOR,tnTAM
	LOCAL lcOUT AS STRING
	lcOUT = STR(tnVALOR,tnTAM)
	lcOUT = STRTRAN(lcOUT," ","0")
RETU(lcOUT)
